{
  "uuid": "58264926-678c-4042-89aa-b9c4e2e4fa67",
  "name": "Common IF Queries for IFWorldModel",
  "created_at": "2024-09-24T06:28:36.093940Z",
  "updated_at": "2024-09-24T06:29:05.918340Z",
  "account": {
    "uuid": "760c9b93-a257-47cd-bd61-d0b15a821e02"
  },
  "chat_messages": [
    {
      "uuid": "c6d7e3b8-ccb0-4eb3-a607-7b6311a6efa8",
      "text": "Let's take a side design path for a moment. If we were to add an IFQueries class to the IFWorldModel project, what might be some common \"IF\" queries be? These queries would result in IF results, but pull from the DataStore.",
      "content": [
        {
          "start_timestamp": "2024-09-24T06:29:03.979983Z",
          "stop_timestamp": "2024-09-24T06:29:03.979983Z",
          "type": "text",
          "text": "Let's take a side design path for a moment. If we were to add an IFQueries class to the IFWorldModel project, what might be some common \"IF\" queries be? These queries would result in IF results, but pull from the DataStore.",
          "citations": []
        }
      ],
      "sender": "human",
      "created_at": "2024-09-24T06:29:03.979983Z",
      "updated_at": "2024-09-24T06:29:03.979983Z",
      "attachments": [],
      "files": []
    },
    {
      "uuid": "8c7a735f-32aa-4e41-bb40-ba8b2de0f3c2",
      "text": " Certainly! Creating an `IFQueries` class in the IFWorldModel project is a great idea to encapsulate common queries specific to Interactive Fiction scenarios. These queries would leverage the underlying DataStore graph structure but provide results tailored to IF needs. Here are some common IF queries we might include:\n\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing DataStore;\n\nnamespace IFWorldModel\n{\n    public static class IFQueries\n    {\n        public static IEnumerable<Thing> GetVisibleThingsInRoom(this WorldModel worldModel, Room room)\n        {\n            return worldModel.GetRoomContents(room).Where(thing => thing.IsVisible());\n        }\n\n        public static IEnumerable<Thing> GetTakeableThingsInRoom(this WorldModel worldModel, Room room)\n        {\n            return worldModel.GetRoomContents(room).Where(thing => thing.CanBeTaken());\n        }\n\n        public static IEnumerable<Container> GetOpenContainersInRoom(this WorldModel worldModel, Room room)\n        {\n            return worldModel.GetRoomContents(room)\n                .OfType<Container>()\n                .Where(container => container.IsOpen);\n        }\n\n        public static IEnumerable<Thing> GetContentsOfAllOpenContainers(this WorldModel worldModel, Room room)\n        {\n            return worldModel.GetOpenContainersInRoom(room)\n                .SelectMany(container => container.Contents);\n        }\n\n        public static IEnumerable<Person> GetCharactersInRoom(this WorldModel worldModel, Room room)\n        {\n            return worldModel.GetRoomContents(room).OfType<Person>();\n        }\n\n        public static IEnumerable<Door> GetDoorsInRoom(this WorldModel worldModel, Room room)\n        {\n            return room.GetDoors().Select(d => d.Door);\n        }\n\n        public static IEnumerable<Thing> GetAllAccessibleThings(this WorldModel worldModel, Room room)\n        {\n            return worldModel.GetVisibleThingsInRoom(room)\n                .Concat(worldModel.GetContentsOfAllOpenContainers(room))\n                .Distinct();\n        }\n\n        public static IEnumerable<Thing> GetItemsMatchingDescription(this WorldModel worldModel, Room room, string description)\n        {\n            return worldModel.GetAllAccessibleThings(room)\n                .Where(thing => thing.MatchesDescription(description));\n        }\n\n        public static bool IsItemInInventory(this WorldModel worldModel, Guid playerId, string itemName)\n        {\n            return worldModel.GetPlayerItems(playerId)\n                .Any(item => item.Name.Equals(itemName, StringComparison.OrdinalIgnoreCase));\n        }\n\n        public static IEnumerable<Room> GetConnectedRooms(this WorldModel worldModel, Room currentRoom)\n        {\n            return worldModel.GetRoomExits(currentRoom)\n                .Select(exit => exit.Destination);\n        }\n\n        public static IEnumerable<Thing> GetLightSourcesInRoom(this WorldModel worldModel, Room room)\n        {\n            return worldModel.GetAllAccessibleThings(room)\n                .Where(thing => thing.GetPropertyValue<bool>(\"IsLightSource\", false));\n        }\n\n        public static bool IsRoomDark(this WorldModel worldModel, Room room)\n        {\n            return room.IsDark && !worldModel.GetLightSourcesInRoom(room).Any();\n        }\n\n        public static IEnumerable<Thing> GetThingsPlayerCanInteractWith(this WorldModel worldModel, Guid playerId)\n        {\n            var playerLocation = worldModel.GetPlayerLocation(playerId);\n            return worldModel.GetAllAccessibleThings(playerLocation)\n                .Concat(worldModel.GetPlayerItems(playerId));\n        }\n\n        public static IEnumerable<Thing> FindPathBetweenRooms(this WorldModel worldModel, Room start, Room end)\n        {\n            // This could be implemented using a breadth-first search or A* algorithm\n            // For simplicity, we'll just return an empty list for now\n            return new List<Thing>();\n        }\n    }\n}\n```\n\nThese queries provide a rich set of IF-specific operations that can be easily used throughout the game logic. They abstract away the complexities of working directly with the graph structure and provide a more domain-specific interface for common IF scenarios.\n\nSome key points about these queries:\n\n1. They're implemented as extension methods on `WorldModel`, allowing for a fluent interface when used.\n2. They make heavy use of LINQ and lambda expressions for concise, readable code.\n3. They encapsulate common IF concepts like visibility, accessibility, and interaction possibilities.\n4. They provide a layer of abstraction over the underlying graph structure, making it easier to work with IF-specific concepts.\n\nThese queries can be easily extended or modified as needed for specific game requirements. They also provide a good foundation for implementing more complex game mechanics or puzzle logic in the future.",
      "content": [
        {
          "start_timestamp": "2024-09-24T06:29:03.979983Z",
          "stop_timestamp": "2024-09-24T06:29:03.979983Z",
          "type": "text",
          "text": " Certainly! Creating an `IFQueries` class in the IFWorldModel project is a great idea to encapsulate common queries specific to Interactive Fiction scenarios. These queries would leverage the underlying DataStore graph structure but provide results tailored to IF needs. Here are some common IF queries we might include:\n\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing DataStore;\n\nnamespace IFWorldModel\n{\n    public static class IFQueries\n    {\n        public static IEnumerable<Thing> GetVisibleThingsInRoom(this WorldModel worldModel, Room room)\n        {\n            return worldModel.GetRoomContents(room).Where(thing => thing.IsVisible());\n        }\n\n        public static IEnumerable<Thing> GetTakeableThingsInRoom(this WorldModel worldModel, Room room)\n        {\n            return worldModel.GetRoomContents(room).Where(thing => thing.CanBeTaken());\n        }\n\n        public static IEnumerable<Container> GetOpenContainersInRoom(this WorldModel worldModel, Room room)\n        {\n            return worldModel.GetRoomContents(room)\n                .OfType<Container>()\n                .Where(container => container.IsOpen);\n        }\n\n        public static IEnumerable<Thing> GetContentsOfAllOpenContainers(this WorldModel worldModel, Room room)\n        {\n            return worldModel.GetOpenContainersInRoom(room)\n                .SelectMany(container => container.Contents);\n        }\n\n        public static IEnumerable<Person> GetCharactersInRoom(this WorldModel worldModel, Room room)\n        {\n            return worldModel.GetRoomContents(room).OfType<Person>();\n        }\n\n        public static IEnumerable<Door> GetDoorsInRoom(this WorldModel worldModel, Room room)\n        {\n            return room.GetDoors().Select(d => d.Door);\n        }\n\n        public static IEnumerable<Thing> GetAllAccessibleThings(this WorldModel worldModel, Room room)\n        {\n            return worldModel.GetVisibleThingsInRoom(room)\n                .Concat(worldModel.GetContentsOfAllOpenContainers(room))\n                .Distinct();\n        }\n\n        public static IEnumerable<Thing> GetItemsMatchingDescription(this WorldModel worldModel, Room room, string description)\n        {\n            return worldModel.GetAllAccessibleThings(room)\n                .Where(thing => thing.MatchesDescription(description));\n        }\n\n        public static bool IsItemInInventory(this WorldModel worldModel, Guid playerId, string itemName)\n        {\n            return worldModel.GetPlayerItems(playerId)\n                .Any(item => item.Name.Equals(itemName, StringComparison.OrdinalIgnoreCase));\n        }\n\n        public static IEnumerable<Room> GetConnectedRooms(this WorldModel worldModel, Room currentRoom)\n        {\n            return worldModel.GetRoomExits(currentRoom)\n                .Select(exit => exit.Destination);\n        }\n\n        public static IEnumerable<Thing> GetLightSourcesInRoom(this WorldModel worldModel, Room room)\n        {\n            return worldModel.GetAllAccessibleThings(room)\n                .Where(thing => thing.GetPropertyValue<bool>(\"IsLightSource\", false));\n        }\n\n        public static bool IsRoomDark(this WorldModel worldModel, Room room)\n        {\n            return room.IsDark && !worldModel.GetLightSourcesInRoom(room).Any();\n        }\n\n        public static IEnumerable<Thing> GetThingsPlayerCanInteractWith(this WorldModel worldModel, Guid playerId)\n        {\n            var playerLocation = worldModel.GetPlayerLocation(playerId);\n            return worldModel.GetAllAccessibleThings(playerLocation)\n                .Concat(worldModel.GetPlayerItems(playerId));\n        }\n\n        public static IEnumerable<Thing> FindPathBetweenRooms(this WorldModel worldModel, Room start, Room end)\n        {\n            // This could be implemented using a breadth-first search or A* algorithm\n            // For simplicity, we'll just return an empty list for now\n            return new List<Thing>();\n        }\n    }\n}\n```\n\nThese queries provide a rich set of IF-specific operations that can be easily used throughout the game logic. They abstract away the complexities of working directly with the graph structure and provide a more domain-specific interface for common IF scenarios.\n\nSome key points about these queries:\n\n1. They're implemented as extension methods on `WorldModel`, allowing for a fluent interface when used.\n2. They make heavy use of LINQ and lambda expressions for concise, readable code.\n3. They encapsulate common IF concepts like visibility, accessibility, and interaction possibilities.\n4. They provide a layer of abstraction over the underlying graph structure, making it easier to work with IF-specific concepts.\n\nThese queries can be easily extended or modified as needed for specific game requirements. They also provide a good foundation for implementing more complex game mechanics or puzzle logic in the future.",
          "citations": []
        }
      ],
      "sender": "assistant",
      "created_at": "2024-09-24T06:29:03.979983Z",
      "updated_at": "2024-09-24T06:29:03.979983Z",
      "attachments": [],
      "files": []
    }
  ],
  "_extraction_metadata": {
    "extraction_method": "exact_title_match",
    "matched_title": "Common IF Queries for IFWorldModel",
    "extraction_timestamp": "2025-06-21T06:39:31.648Z",
    "source": "claude_project_sharpee"
  }
}