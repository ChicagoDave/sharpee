{
  "uuid": "0bfe533f-0029-440b-97b6-3ca3cdb159d4",
  "name": "Developing the World Model for Interactive Fiction",
  "created_at": "2025-03-27T21:40:53.933130Z",
  "updated_at": "2025-03-27T22:36:04.725591Z",
  "account": {
    "uuid": "760c9b93-a257-47cd-bd61-d0b15a821e02"
  },
  "chat_messages": [
    {
      "uuid": "0ff9045d-b34b-4e84-8a16-7925f7828017",
      "text": "okay - we have some instructions, some design docs, an existing project.\n\nI believe we should start at the bottom. this would be:\n\npackages\\core\\src\\world-model",
      "content": [
        {
          "start_timestamp": "2025-03-27T21:16:16.277884Z",
          "stop_timestamp": "2025-03-27T21:16:16.277884Z",
          "type": "text",
          "text": "okay - we have some instructions, some design docs, an existing project.\n\nI believe we should start at the bottom. this would be:\n\npackages\\core\\src\\world-model",
          "citations": []
        }
      ],
      "sender": "human",
      "created_at": "2025-03-27T21:40:55.247413Z",
      "updated_at": "2025-03-27T21:40:55.247413Z",
      "attachments": [],
      "files": []
    },
    {
      "uuid": "e7050e7a-4954-4e74-901d-25bbdf152cbe",
      "text": " I'll help you outline a parser-based interactive fiction story based on the design documents and screenplay you've provided. Let's start with developing the foundational structure for Sharpee, focusing on the world model as you suggested.\n\n## Starting with the World-Model Core Component\n\nThe world model is foundational to your interactive fiction engine. It needs to represent the game state, objects, relationships, and support the mirror-based mechanics that are central to your \"Reflections\" story.\n\n### Directory Structure for Core World Model\n\nLet's establish a logical TypeScript directory structure for the `packages/core/src/world-model`:\n\n```\npackages/\n└── core/\n    └── src/\n        ├── world-model/\n        │   ├── entities/\n        │   │   ├── base-entity.ts\n        │   │   ├── character.ts\n        │   │   ├── container.ts\n        │   │   ├── location.ts\n        │   │   ├── mirror.ts (specific to Reflections)\n        │   │   ├── object.ts\n        │   │   └── supporter.ts\n        │   ├── state/\n        │   │   ├── game-state.ts\n        │   │   ├── state-manager.ts\n        │   │   └── history.ts\n        │   ├── relationships/\n        │   │   ├── connection.ts\n        │   │   ├── containment.ts\n        │   │   └── visibility.ts\n        │   ├── types/\n        │   │   ├── enums.ts\n        │   │   ├── interfaces.ts\n        │   │   └── index.ts\n        │   └── index.ts\n        ├── parser/\n        ├── execution/\n        ├── grammar/\n        └── extensions/\n            └── mirrors/ (for Reflections)\n```\n\n### Core World Model Implementation\n\nLet's start implementing the base types for the world model:\n\n#### 1. Base Entity Interface\n\n```typescript\n// packages/core/src/world-model/types/interfaces.ts\n\nexport interface Entity {\n  id: string;\n  name: string;\n  description: string;\n  qualities: Record<string, any>;\n  // Additional base properties\n}\n\nexport interface GameState {\n  entities: Record<string, Entity>;\n  relationships: Relationship[];\n  currentLocation: string;\n  currentPlayer: string;\n  // Additional state properties\n}\n\nexport interface Relationship {\n  type: RelationshipType;\n  source: string;\n  target: string;\n  qualities: Record<string, any>;\n}\n\n// For Reflections-specific portal functionality\nexport interface MirrorConnection {\n  sourceId: string;\n  targetId: string;\n  isActive: boolean;\n  isDirected: boolean;\n}\n```\n\n#### 2. Enums\n\n```typescript\n// packages/core/src/world-model/types/enums.ts\n\nexport enum RelationshipType {\n  CONTAINS = 'contains',\n  SUPPORTS = 'supports',\n  CONNECTS_TO = 'connects_to',\n  DIRECTS_TO = 'directs_to', // For mirrors\n  WORN_BY = 'worn_by',\n  // Add others as needed\n}\n\nexport enum BloodType {\n  SILVER = 'silver',\n  MOON = 'moon',\n  EARTH = 'earth',\n  LIGHT = 'light',\n  NONE = 'none'\n}\n\nexport enum MirrorSize {\n  SMALL = 'small',\n  MEDIUM = 'medium',\n  LARGE = 'large'\n}\n```\n\n#### 3. Base State Manager\n\n```typescript\n// packages/core/src/world-model/state/state-manager.ts\n\nimport { GameState, Entity, Relationship } from '../types/interfaces';\nimport { RelationshipType } from '../types/enums';\n\nexport class StateManager {\n  private currentState: GameState;\n  private history: GameState[] = [];\n  \n  constructor(initialState: GameState) {\n    this.currentState = {...initialState};\n  }\n  \n  getState(): GameState {\n    return {...this.currentState};\n  }\n  \n  updateState(newState: GameState): void {\n    this.history.push({...this.currentState});\n    this.currentState = {...newState};\n  }\n  \n  addEntity(entity: Entity): void {\n    const newState = {...this.currentState};\n    newState.entities[entity.id] = entity;\n    this.updateState(newState);\n  }\n  \n  addRelationship(relationship: Relationship): void {\n    const newState = {...this.currentState};\n    newState.relationships.push(relationship);\n    this.updateState(newState);\n  }\n  \n  // Methods for state queries and updates\n  getEntity(id: string): Entity | undefined {\n    return this.currentState.entities[id];\n  }\n  \n  getRelationships(entityId: string, type?: RelationshipType): Relationship[] {\n    return this.currentState.relationships.filter(r => \n      (r.source === entityId || r.target === entityId) && \n      (!type || r.type === type)\n    );\n  }\n  \n  // For Reflections - Mirror functionality\n  getMirrorConnections(mirrorId: string): string[] {\n    return this.currentState.relationships\n      .filter(r => r.source === mirrorId && r.type === RelationshipType.CONNECTS_TO)\n      .map(r => r.target);\n  }\n  \n  getMirrorDirection(mirrorId: string): string | undefined {\n    const relationship = this.currentState.relationships\n      .find(r => r.source === mirrorId && r.type === RelationshipType.DIRECTS_TO);\n    return relationship?.target;\n  }\n  \n  // Undo functionality\n  undo(): boolean {\n    if (this.history.length === 0) return false;\n    this.currentState = this.history.pop()!;\n    return true;\n  }\n}\n```\n\n#### 4. Mirror Entity (for Reflections)\n\n```typescript\n// packages/core/src/world-model/entities/mirror.ts\n\nimport { Entity } from '../types/interfaces';\nimport { BloodType, MirrorSize } from '../types/enums';\n\nexport interface Mirror extends Entity {\n  size: MirrorSize;\n  isBroken: boolean;\n  isReachable: boolean;\n  isProvidesLight: boolean;\n  knownConnections: string[]; // IDs of connected mirrors\n  bloodSensitivity: number; // For detection mechanics\n}\n\nexport function createMirror(\n  id: string,\n  name: string,\n  description: string,\n  size: MirrorSize = MirrorSize.LARGE,\n  options?: Partial<Omit<Mirror, 'id' | 'name' | 'description' | 'size'>>\n): Mirror {\n  return {\n    id,\n    name,\n    description,\n    size,\n    isBroken: false,\n    isReachable: true,\n    isProvidesLight: true,\n    knownConnections: [],\n    bloodSensitivity: 0,\n    qualities: {},\n    ...options\n  };\n}\n```\n\n### Unit Tests for the World Model\n\nLet's also outline some unit tests for these core components:\n\n```typescript\n// packages/core/tests/world-model/state-manager.test.ts\n\nimport { StateManager } from '../../src/world-model/state/state-manager';\nimport { Entity, Relationship } from '../../src/world-model/types/interfaces';\nimport { RelationshipType } from '../../src/world-model/types/enums';\n\ndescribe('StateManager', () => {\n  let stateManager: StateManager;\n  \n  beforeEach(() => {\n    stateManager = new StateManager({\n      entities: {},\n      relationships: [],\n      currentLocation: 'starting_room',\n      currentPlayer: 'the_thief'\n    });\n  });\n  \n  test('should add entities to state', () => {\n    const entity: Entity = {\n      id: 'test_entity',\n      name: 'Test Entity',\n      description: 'A test entity',\n      qualities: {}\n    };\n    \n    stateManager.addEntity(entity);\n    expect(stateManager.getEntity('test_entity')).toEqual(entity);\n  });\n  \n  test('should add relationships to state', () => {\n    const relationship: Relationship = {\n      type: RelationshipType.CONTAINS,\n      source: 'container',\n      target: 'item',\n      qualities: {}\n    };\n    \n    stateManager.addRelationship(relationship);\n    const relationships = stateManager.getRelationships('container');\n    expect(relationships).toHaveLength(1);\n    expect(relationships[0]).toEqual(relationship);\n  });\n  \n  test('should support undo functionality', () => {\n    const entity: Entity = {\n      id: 'test_entity',\n      name: 'Test Entity',\n      description: 'A test entity',\n      qualities: {}\n    };\n    \n    stateManager.addEntity(entity);\n    expect(stateManager.getEntity('test_entity')).toEqual(entity);\n    \n    // Undo the addition\n    stateManager.undo();\n    expect(stateManager.getEntity('test_entity')).toBeUndefined();\n  });\n  \n  // Add more tests for mirror-specific functionality\n});\n```\n\n### Integration with Reflections Story\n\nTo make these components work with your \"Reflections\" story, you'll need to:\n\n1. Define the specific mirror mechanics detailed in your design documents\n2. Create character types that support the Blood abilities\n3. Implement the special travel/detection rules for",
      "content": [
        {
          "start_timestamp": "2025-03-27T21:40:56.079944Z",
          "stop_timestamp": "2025-03-27T21:41:26.625222Z",
          "type": "text",
          "text": " I'll help you outline a parser-based interactive fiction story based on the design documents and screenplay you've provided. Let's start with developing the foundational structure for Sharpee, focusing on the world model as you suggested.\n\n## Starting with the World-Model Core Component\n\nThe world model is foundational to your interactive fiction engine. It needs to represent the game state, objects, relationships, and support the mirror-based mechanics that are central to your \"Reflections\" story.\n\n### Directory Structure for Core World Model\n\nLet's establish a logical TypeScript directory structure for the `packages/core/src/world-model`:\n\n```\npackages/\n└── core/\n    └── src/\n        ├── world-model/\n        │   ├── entities/\n        │   │   ├── base-entity.ts\n        │   │   ├── character.ts\n        │   │   ├── container.ts\n        │   │   ├── location.ts\n        │   │   ├── mirror.ts (specific to Reflections)\n        │   │   ├── object.ts\n        │   │   └── supporter.ts\n        │   ├── state/\n        │   │   ├── game-state.ts\n        │   │   ├── state-manager.ts\n        │   │   └── history.ts\n        │   ├── relationships/\n        │   │   ├── connection.ts\n        │   │   ├── containment.ts\n        │   │   └── visibility.ts\n        │   ├── types/\n        │   │   ├── enums.ts\n        │   │   ├── interfaces.ts\n        │   │   └── index.ts\n        │   └── index.ts\n        ├── parser/\n        ├── execution/\n        ├── grammar/\n        └── extensions/\n            └── mirrors/ (for Reflections)\n```\n\n### Core World Model Implementation\n\nLet's start implementing the base types for the world model:\n\n#### 1. Base Entity Interface\n\n```typescript\n// packages/core/src/world-model/types/interfaces.ts\n\nexport interface Entity {\n  id: string;\n  name: string;\n  description: string;\n  qualities: Record<string, any>;\n  // Additional base properties\n}\n\nexport interface GameState {\n  entities: Record<string, Entity>;\n  relationships: Relationship[];\n  currentLocation: string;\n  currentPlayer: string;\n  // Additional state properties\n}\n\nexport interface Relationship {\n  type: RelationshipType;\n  source: string;\n  target: string;\n  qualities: Record<string, any>;\n}\n\n// For Reflections-specific portal functionality\nexport interface MirrorConnection {\n  sourceId: string;\n  targetId: string;\n  isActive: boolean;\n  isDirected: boolean;\n}\n```\n\n#### 2. Enums\n\n```typescript\n// packages/core/src/world-model/types/enums.ts\n\nexport enum RelationshipType {\n  CONTAINS = 'contains',\n  SUPPORTS = 'supports',\n  CONNECTS_TO = 'connects_to',\n  DIRECTS_TO = 'directs_to', // For mirrors\n  WORN_BY = 'worn_by',\n  // Add others as needed\n}\n\nexport enum BloodType {\n  SILVER = 'silver',\n  MOON = 'moon',\n  EARTH = 'earth',\n  LIGHT = 'light',\n  NONE = 'none'\n}\n\nexport enum MirrorSize {\n  SMALL = 'small',\n  MEDIUM = 'medium',\n  LARGE = 'large'\n}\n```\n\n#### 3. Base State Manager\n\n```typescript\n// packages/core/src/world-model/state/state-manager.ts\n\nimport { GameState, Entity, Relationship } from '../types/interfaces';\nimport { RelationshipType } from '../types/enums';\n\nexport class StateManager {\n  private currentState: GameState;\n  private history: GameState[] = [];\n  \n  constructor(initialState: GameState) {\n    this.currentState = {...initialState};\n  }\n  \n  getState(): GameState {\n    return {...this.currentState};\n  }\n  \n  updateState(newState: GameState): void {\n    this.history.push({...this.currentState});\n    this.currentState = {...newState};\n  }\n  \n  addEntity(entity: Entity): void {\n    const newState = {...this.currentState};\n    newState.entities[entity.id] = entity;\n    this.updateState(newState);\n  }\n  \n  addRelationship(relationship: Relationship): void {\n    const newState = {...this.currentState};\n    newState.relationships.push(relationship);\n    this.updateState(newState);\n  }\n  \n  // Methods for state queries and updates\n  getEntity(id: string): Entity | undefined {\n    return this.currentState.entities[id];\n  }\n  \n  getRelationships(entityId: string, type?: RelationshipType): Relationship[] {\n    return this.currentState.relationships.filter(r => \n      (r.source === entityId || r.target === entityId) && \n      (!type || r.type === type)\n    );\n  }\n  \n  // For Reflections - Mirror functionality\n  getMirrorConnections(mirrorId: string): string[] {\n    return this.currentState.relationships\n      .filter(r => r.source === mirrorId && r.type === RelationshipType.CONNECTS_TO)\n      .map(r => r.target);\n  }\n  \n  getMirrorDirection(mirrorId: string): string | undefined {\n    const relationship = this.currentState.relationships\n      .find(r => r.source === mirrorId && r.type === RelationshipType.DIRECTS_TO);\n    return relationship?.target;\n  }\n  \n  // Undo functionality\n  undo(): boolean {\n    if (this.history.length === 0) return false;\n    this.currentState = this.history.pop()!;\n    return true;\n  }\n}\n```\n\n#### 4. Mirror Entity (for Reflections)\n\n```typescript\n// packages/core/src/world-model/entities/mirror.ts\n\nimport { Entity } from '../types/interfaces';\nimport { BloodType, MirrorSize } from '../types/enums';\n\nexport interface Mirror extends Entity {\n  size: MirrorSize;\n  isBroken: boolean;\n  isReachable: boolean;\n  isProvidesLight: boolean;\n  knownConnections: string[]; // IDs of connected mirrors\n  bloodSensitivity: number; // For detection mechanics\n}\n\nexport function createMirror(\n  id: string,\n  name: string,\n  description: string,\n  size: MirrorSize = MirrorSize.LARGE,\n  options?: Partial<Omit<Mirror, 'id' | 'name' | 'description' | 'size'>>\n): Mirror {\n  return {\n    id,\n    name,\n    description,\n    size,\n    isBroken: false,\n    isReachable: true,\n    isProvidesLight: true,\n    knownConnections: [],\n    bloodSensitivity: 0,\n    qualities: {},\n    ...options\n  };\n}\n```\n\n### Unit Tests for the World Model\n\nLet's also outline some unit tests for these core components:\n\n```typescript\n// packages/core/tests/world-model/state-manager.test.ts\n\nimport { StateManager } from '../../src/world-model/state/state-manager';\nimport { Entity, Relationship } from '../../src/world-model/types/interfaces';\nimport { RelationshipType } from '../../src/world-model/types/enums';\n\ndescribe('StateManager', () => {\n  let stateManager: StateManager;\n  \n  beforeEach(() => {\n    stateManager = new StateManager({\n      entities: {},\n      relationships: [],\n      currentLocation: 'starting_room',\n      currentPlayer: 'the_thief'\n    });\n  });\n  \n  test('should add entities to state', () => {\n    const entity: Entity = {\n      id: 'test_entity',\n      name: 'Test Entity',\n      description: 'A test entity',\n      qualities: {}\n    };\n    \n    stateManager.addEntity(entity);\n    expect(stateManager.getEntity('test_entity')).toEqual(entity);\n  });\n  \n  test('should add relationships to state', () => {\n    const relationship: Relationship = {\n      type: RelationshipType.CONTAINS,\n      source: 'container',\n      target: 'item',\n      qualities: {}\n    };\n    \n    stateManager.addRelationship(relationship);\n    const relationships = stateManager.getRelationships('container');\n    expect(relationships).toHaveLength(1);\n    expect(relationships[0]).toEqual(relationship);\n  });\n  \n  test('should support undo functionality', () => {\n    const entity: Entity = {\n      id: 'test_entity',\n      name: 'Test Entity',\n      description: 'A test entity',\n      qualities: {}\n    };\n    \n    stateManager.addEntity(entity);\n    expect(stateManager.getEntity('test_entity')).toEqual(entity);\n    \n    // Undo the addition\n    stateManager.undo();\n    expect(stateManager.getEntity('test_entity')).toBeUndefined();\n  });\n  \n  // Add more tests for mirror-specific functionality\n});\n```\n\n### Integration with Reflections Story\n\nTo make these components work with your \"Reflections\" story, you'll need to:\n\n1. Define the specific mirror mechanics detailed in your design documents\n2. Create character types that support the Blood abilities\n3. Implement the special travel/detection rules for",
          "citations": []
        }
      ],
      "sender": "assistant",
      "created_at": "2025-03-27T21:41:26.635260Z",
      "updated_at": "2025-03-27T21:41:26.635260Z",
      "attachments": [],
      "files": []
    },
    {
      "uuid": "7c94999e-729e-4ca6-8e51-8980b3b89cf4",
      "text": "okay - we have some instructions, some design docs, an existing project. note the structure.txt file.\n\nI believe we should start at the bottom. this would be:\n\npackages\\core\\src\\world-model\n\nthe world-model will not have IF concepts. it's strictly a technical layer we will build IF things on top of.\n\nSo we might want to have a base world model and an IF world model",
      "content": [
        {
          "start_timestamp": "2025-03-27T21:17:15.564555Z",
          "stop_timestamp": "2025-03-27T21:17:15.564555Z",
          "type": "text",
          "text": "okay - we have some instructions, some design docs, an existing project. note the structure.txt file.\n\nI believe we should start at the bottom. this would be:\n\npackages\\core\\src\\world-model\n\nthe world-model will not have IF concepts. it's strictly a technical layer we will build IF things on top of.\n\nSo we might want to have a base world model and an IF world model",
          "citations": []
        }
      ],
      "sender": "human",
      "created_at": "2025-03-27T21:45:05.246779Z",
      "updated_at": "2025-03-27T21:45:05.246779Z",
      "attachments": [],
      "files": []
    },
    {
      "uuid": "9347a759-90bd-424d-bbfc-c27878f99fc3",
      "text": " I'll help you organize and outline the development of Sharpee, focusing first on the core world-model structure. Based on your documents and instructions, let's start with the foundational architecture that will support your Reflections story and future IF projects.\n\n## Starting with the World Model \n\nLet's begin by outlining the base world-model structure in `packages/core/src/world-model`. This will be our foundation that remains IF-agnostic.\n\n### Core World Model Structure\n\n```\npackages/\n  core/\n    src/\n      world-model/\n        types/\n          entity.ts            // Base entity interface\n          relationship.ts      // Define how entities relate to each other\n          attribute.ts         // Entity attributes/properties\n          state-tree.ts        // Immutable state tree definition\n        implementations/\n          immutable-state.ts   // Implementation of immutable state pattern\n          entity-manager.ts    // CRUD operations for entities\n          relationship-manager.ts // Manage connections between entities\n          event-emitter.ts     // Event system for state changes\n        utils/\n          id-generator.ts      // Unique ID creation\n          serialization.ts     // State serialization/deserialization\n          type-guards.ts       // TypeScript type narrowing helpers\n        index.ts               // Main exports\n```\n\n### Base Entity System\n\nLet's define the fundamental entity system that will underpin everything:\n\n```typescript\n// types/entity.ts\n\nexport interface Entity {\n  id: string;\n  type: string;\n  attributes: Record<string, any>;\n  relationships: Record<string, string[]>; // Maps relationship type to related entity IDs\n}\n\n// A minimal, generic world state\nexport interface WorldState {\n  entities: Record<string, Entity>;\n  // Meta information about the state (version, timestamp, etc.)\n  meta: {\n    version: string;\n    timestamp: number;\n    turnNumber: number;\n  };\n}\n```\n\n### Building on Top - IF Layer\n\nOnce we have the base world-model, we'll need to build the IF-specific layer on top:\n\n```\npackages/\n  if-core/\n    src/\n      types/\n        room.ts               // Room-specific entities\n        object.ts             // Physical objects in the IF world\n        character.ts          // Player and NPCs\n        container.ts          // Things that can contain other things\n        door.ts               // Connections between rooms\n      actions/\n        movement.ts           // Go, enter, exit\n        manipulation.ts       // Take, drop, open, close\n        examination.ts        // Look, examine, search\n      systems/\n        containment.ts        // How objects contain other objects\n        visibility.ts         // What can be seen from where\n        accessibility.ts      // What can be reached\n      factories/\n        room-factory.ts       // Create standardized rooms\n        object-factory.ts     // Create standard objects\n      utils/\n        description-generator.ts // Generate text descriptions\n```\n\n## Implementation Plan\n\nHere's a step-by-step approach to building the foundation:\n\n1. **Start with the Core Immutable State System**\n   - Implement the basic entity and state tree with TypeScript interfaces\n   - Create functions for immutable state updates\n   - Build serialization/deserialization utilities\n\n2. **Add Basic Relationship Tracking**\n   - Implement entity relationships (contains, connects-to, etc.)\n   - Create utility functions for relationship queries\n\n3. **Build Event System**\n   - Implement an event emitter for state changes\n   - Create hooks for extensions to listen to events\n\n4. **Create IF-Specific Types**\n   - Define room, object, character interfaces that extend base entities\n   - Implement IF-specific relationship types\n\n5. **Develop Core IF Actions**\n   - Build action creators and handlers for basic IF verbs\n   - Implement validation logic for actions\n\n## First Implementation: Entity and State Management\n\nLet's sketch the implementation of the core immutable state system:\n\n```typescript\n// implementations/immutable-state.ts\n\nimport { Entity, WorldState } from '../types/entity';\n\n// Create a new, empty world state\nexport function createInitialState(): WorldState {\n  return {\n    entities: {},\n    meta: {\n      version: '1.0.0',\n      timestamp: Date.now(),\n      turnNumber: 0\n    }\n  };\n}\n\n// Add a new entity to the world state\nexport function addEntity(state: WorldState, entity: Entity): WorldState {\n  return {\n    ...state,\n    entities: {\n      ...state.entities,\n      [entity.id]: entity\n    }\n  };\n}\n\n// Update an existing entity\nexport function updateEntity(state: WorldState, entityId: string, updates: Partial<Entity>): WorldState {\n  const existingEntity = state.entities[entityId];\n  if (!existingEntity) return state;\n  \n  return {\n    ...state,\n    entities: {\n      ...state.entities,\n      [entityId]: {\n        ...existingEntity,\n        ...updates,\n        attributes: {\n          ...existingEntity.attributes,\n          ...(updates.attributes || {})\n        },\n        relationships: {\n          ...existingEntity.relationships,\n          ...(updates.relationships || {})\n        }\n      }\n    }\n  };\n}\n\n// Create a relationship between entities\nexport function createRelationship(\n  state: WorldState, \n  sourceId: string, \n  relationshipType: string, \n  targetId: string\n): WorldState {\n  const source = state.entities[sourceId];\n  if (!source) return state;\n  \n  const existingRelationships = source.relationships[relationshipType] || [];\n  \n  // If relationship already exists, don't duplicate\n  if (existingRelationships.includes(targetId)) return state;\n  \n  return updateEntity(state, sourceId, {\n    relationships: {\n      ...source.relationships,\n      [relationshipType]: [...existingRelationships, targetId]\n    }\n  });\n}\n```\n\n## Next Steps\n\nAfter implementing the core structures above:\n\n1. Create unit tests for the base functionality\n2. Implement the entity and relationship managers\n3. Start building the IF-specific layer on top of the core\n4. Design the action processing pipeline\n5. Implement the parser interface that will connect user input to actions\n\nWould you like me to focus on any specific part of this architecture in more detail? Or shall we proceed with implementing one of these foundational components?",
      "content": [
        {
          "start_timestamp": "2025-03-27T21:45:06.603813Z",
          "stop_timestamp": "2025-03-27T21:45:23.902986Z",
          "type": "text",
          "text": " I'll help you organize and outline the development of Sharpee, focusing first on the core world-model structure. Based on your documents and instructions, let's start with the foundational architecture that will support your Reflections story and future IF projects.\n\n## Starting with the World Model \n\nLet's begin by outlining the base world-model structure in `packages/core/src/world-model`. This will be our foundation that remains IF-agnostic.\n\n### Core World Model Structure\n\n```\npackages/\n  core/\n    src/\n      world-model/\n        types/\n          entity.ts            // Base entity interface\n          relationship.ts      // Define how entities relate to each other\n          attribute.ts         // Entity attributes/properties\n          state-tree.ts        // Immutable state tree definition\n        implementations/\n          immutable-state.ts   // Implementation of immutable state pattern\n          entity-manager.ts    // CRUD operations for entities\n          relationship-manager.ts // Manage connections between entities\n          event-emitter.ts     // Event system for state changes\n        utils/\n          id-generator.ts      // Unique ID creation\n          serialization.ts     // State serialization/deserialization\n          type-guards.ts       // TypeScript type narrowing helpers\n        index.ts               // Main exports\n```\n\n### Base Entity System\n\nLet's define the fundamental entity system that will underpin everything:\n\n```typescript\n// types/entity.ts\n\nexport interface Entity {\n  id: string;\n  type: string;\n  attributes: Record<string, any>;\n  relationships: Record<string, string[]>; // Maps relationship type to related entity IDs\n}\n\n// A minimal, generic world state\nexport interface WorldState {\n  entities: Record<string, Entity>;\n  // Meta information about the state (version, timestamp, etc.)\n  meta: {\n    version: string;\n    timestamp: number;\n    turnNumber: number;\n  };\n}\n```\n\n### Building on Top - IF Layer\n\nOnce we have the base world-model, we'll need to build the IF-specific layer on top:\n\n```\npackages/\n  if-core/\n    src/\n      types/\n        room.ts               // Room-specific entities\n        object.ts             // Physical objects in the IF world\n        character.ts          // Player and NPCs\n        container.ts          // Things that can contain other things\n        door.ts               // Connections between rooms\n      actions/\n        movement.ts           // Go, enter, exit\n        manipulation.ts       // Take, drop, open, close\n        examination.ts        // Look, examine, search\n      systems/\n        containment.ts        // How objects contain other objects\n        visibility.ts         // What can be seen from where\n        accessibility.ts      // What can be reached\n      factories/\n        room-factory.ts       // Create standardized rooms\n        object-factory.ts     // Create standard objects\n      utils/\n        description-generator.ts // Generate text descriptions\n```\n\n## Implementation Plan\n\nHere's a step-by-step approach to building the foundation:\n\n1. **Start with the Core Immutable State System**\n   - Implement the basic entity and state tree with TypeScript interfaces\n   - Create functions for immutable state updates\n   - Build serialization/deserialization utilities\n\n2. **Add Basic Relationship Tracking**\n   - Implement entity relationships (contains, connects-to, etc.)\n   - Create utility functions for relationship queries\n\n3. **Build Event System**\n   - Implement an event emitter for state changes\n   - Create hooks for extensions to listen to events\n\n4. **Create IF-Specific Types**\n   - Define room, object, character interfaces that extend base entities\n   - Implement IF-specific relationship types\n\n5. **Develop Core IF Actions**\n   - Build action creators and handlers for basic IF verbs\n   - Implement validation logic for actions\n\n## First Implementation: Entity and State Management\n\nLet's sketch the implementation of the core immutable state system:\n\n```typescript\n// implementations/immutable-state.ts\n\nimport { Entity, WorldState } from '../types/entity';\n\n// Create a new, empty world state\nexport function createInitialState(): WorldState {\n  return {\n    entities: {},\n    meta: {\n      version: '1.0.0',\n      timestamp: Date.now(),\n      turnNumber: 0\n    }\n  };\n}\n\n// Add a new entity to the world state\nexport function addEntity(state: WorldState, entity: Entity): WorldState {\n  return {\n    ...state,\n    entities: {\n      ...state.entities,\n      [entity.id]: entity\n    }\n  };\n}\n\n// Update an existing entity\nexport function updateEntity(state: WorldState, entityId: string, updates: Partial<Entity>): WorldState {\n  const existingEntity = state.entities[entityId];\n  if (!existingEntity) return state;\n  \n  return {\n    ...state,\n    entities: {\n      ...state.entities,\n      [entityId]: {\n        ...existingEntity,\n        ...updates,\n        attributes: {\n          ...existingEntity.attributes,\n          ...(updates.attributes || {})\n        },\n        relationships: {\n          ...existingEntity.relationships,\n          ...(updates.relationships || {})\n        }\n      }\n    }\n  };\n}\n\n// Create a relationship between entities\nexport function createRelationship(\n  state: WorldState, \n  sourceId: string, \n  relationshipType: string, \n  targetId: string\n): WorldState {\n  const source = state.entities[sourceId];\n  if (!source) return state;\n  \n  const existingRelationships = source.relationships[relationshipType] || [];\n  \n  // If relationship already exists, don't duplicate\n  if (existingRelationships.includes(targetId)) return state;\n  \n  return updateEntity(state, sourceId, {\n    relationships: {\n      ...source.relationships,\n      [relationshipType]: [...existingRelationships, targetId]\n    }\n  });\n}\n```\n\n## Next Steps\n\nAfter implementing the core structures above:\n\n1. Create unit tests for the base functionality\n2. Implement the entity and relationship managers\n3. Start building the IF-specific layer on top of the core\n4. Design the action processing pipeline\n5. Implement the parser interface that will connect user input to actions\n\nWould you like me to focus on any specific part of this architecture in more detail? Or shall we proceed with implementing one of these foundational components?",
          "citations": []
        }
      ],
      "sender": "assistant",
      "created_at": "2025-03-27T21:45:29.694455Z",
      "updated_at": "2025-03-27T21:45:29.694455Z",
      "attachments": [],
      "files": []
    },
    {
      "uuid": "d9f2569c-b32a-499e-80fb-6c6b6ecb475c",
      "text": "continue with world-model\\types",
      "content": [
        {
          "start_timestamp": "2025-03-27T21:16:16.263775Z",
          "stop_timestamp": "2025-03-27T21:16:16.263775Z",
          "type": "text",
          "text": "continue with world-model\\types",
          "citations": []
        }
      ],
      "sender": "human",
      "created_at": "2025-03-27T21:50:27.435764Z",
      "updated_at": "2025-03-27T21:50:27.435764Z",
      "attachments": [],
      "files": []
    },
    {
      "uuid": "4530186d-b982-4e5e-8ae7-d2abff31dc6a",
      "text": " Let's continue by implementing the core types for the world model. I'll expand on the entity.ts file and create the other necessary type definitions for the world-model foundation.\n\n## World Model Types\n\nLet's flesh out the types directory with comprehensive type definitions:\n\n### entity.ts\n\n```typescript\n// packages/core/src/world-model/types/entity.ts\n\n/**\n * Unique identifier for entities in the world\n */\nexport type EntityId = string;\n\n/**\n * The base Entity interface representing any object in the world model\n */\nexport interface Entity {\n  /**\n   * Unique identifier for this entity\n   */\n  id: EntityId;\n  \n  /**\n   * The entity type, used for categorization and type checking\n   */\n  type: string;\n  \n  /**\n   * Arbitrary attributes/properties of the entity\n   */\n  attributes: Record<string, unknown>;\n  \n  /**\n   * Relationships to other entities, organized by relationship type\n   */\n  relationships: Record<string, EntityId[]>;\n}\n\n/**\n * Minimal information needed to create a new entity\n */\nexport interface EntityCreationParams {\n  type: string;\n  attributes?: Record<string, unknown>;\n  relationships?: Record<string, EntityId[]>;\n}\n\n/**\n * Configuration for how entity operations should be performed\n */\nexport interface EntityOperationOptions {\n  /**\n   * Whether to merge arrays in relationships instead of replacing them\n   */\n  mergeRelationships?: boolean;\n  \n  /**\n   * Whether to validate relationship target existence\n   */\n  validateRelationships?: boolean;\n}\n```\n\n### relationship.ts\n\n```typescript\n// packages/core/src/world-model/types/relationship.ts\n\nimport { EntityId } from './entity';\n\n/**\n * Defines the types of relationships that can exist between entities\n */\nexport enum RelationshipType {\n  CONTAINS = 'contains',\n  CONTAINED_BY = 'containedBy',\n  CONNECTS_TO = 'connectsTo',\n  CONNECTED_FROM = 'connectedFrom',\n  SUPPORTS = 'supports',\n  SUPPORTED_BY = 'supportedBy',\n  ADJACENT_TO = 'adjacentTo',\n  BELONGS_TO = 'belongsTo',\n  RELATED_TO = 'relatedTo'\n}\n\n/**\n * A relationship between two entities\n */\nexport interface Relationship {\n  /**\n   * The source entity of the relationship\n   */\n  sourceId: EntityId;\n  \n  /**\n   * The type of relationship\n   */\n  type: RelationshipType | string;\n  \n  /**\n   * The target entity of the relationship\n   */\n  targetId: EntityId;\n  \n  /**\n   * Optional metadata for the relationship\n   */\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Configuration for creating a relationship\n */\nexport interface RelationshipConfig {\n  /**\n   * Whether this relationship creates an inverse relationship automatically\n   */\n  bidirectional?: boolean;\n  \n  /**\n   * If bidirectional, the name of the inverse relationship\n   */\n  inverseType?: RelationshipType | string;\n  \n  /**\n   * Whether this relationship is exclusive (replaces previous relationships of same type)\n   */\n  exclusive?: boolean;\n}\n\n/**\n * Map of relationship type configurations\n */\nexport type RelationshipConfigMap = Record<string, RelationshipConfig>;\n\n/**\n * Standard relationship configurations with their inverse mappings\n */\nexport const STANDARD_RELATIONSHIP_CONFIGS: RelationshipConfigMap = {\n  [RelationshipType.CONTAINS]: {\n    bidirectional: true,\n    inverseType: RelationshipType.CONTAINED_BY,\n    exclusive: false\n  },\n  [RelationshipType.CONNECTS_TO]: {\n    bidirectional: true,\n    inverseType: RelationshipType.CONNECTED_FROM,\n    exclusive: false\n  },\n  [RelationshipType.SUPPORTS]: {\n    bidirectional: true,\n    inverseType: RelationshipType.SUPPORTED_BY,\n    exclusive: false\n  },\n  [RelationshipType.ADJACENT_TO]: {\n    bidirectional: true,\n    inverseType: RelationshipType.ADJACENT_TO,\n    exclusive: false\n  }\n};\n```\n\n### attribute.ts\n\n```typescript\n// packages/core/src/world-model/types/attribute.ts\n\n/**\n * Possible types for attribute values\n */\nexport type AttributeValue = \n  | string \n  | number \n  | boolean \n  | null \n  | AttributeObject \n  | AttributeArray;\n\n/**\n * An object containing attribute values\n */\nexport interface AttributeObject {\n  [key: string]: AttributeValue;\n}\n\n/**\n * An array of attribute values\n */\nexport type AttributeArray = AttributeValue[];\n\n/**\n * Standard attribute keys used across the system\n */\nexport enum StandardAttribute {\n  NAME = 'name',\n  DESCRIPTION = 'description',\n  VISIBLE = 'visible',\n  ACCESSIBLE = 'accessible',\n  WEIGHT = 'weight',\n  SIZE = 'size',\n  POSITION = 'position',\n  STATE = 'state',\n}\n\n/**\n * Configuration for an attribute\n */\nexport interface AttributeConfig {\n  /**\n   * Type validation for this attribute\n   */\n  type?: 'string' | 'number' | 'boolean' | 'object' | 'array';\n  \n  /**\n   * Whether this attribute is required for the entity\n   */\n  required?: boolean;\n  \n  /**\n   * Default value if none is provided\n   */\n  default?: AttributeValue;\n  \n  /**\n   * Custom validation function\n   */\n  validate?: (value: AttributeValue) => boolean;\n}\n\n/**\n * A map of attribute configurations\n */\nexport type AttributeConfigMap = Record<string, AttributeConfig>;\n```\n\n### state-tree.ts\n\n```typescript\n// packages/core/src/world-model/types/state-tree.ts\n\nimport { Entity, EntityId } from './entity';\n\n/**\n * Represents the entire world state as an immutable tree\n */\nexport interface WorldState {\n  /**\n   * All entities indexed by their ID\n   */\n  entities: Record<EntityId, Entity>;\n  \n  /**\n   * Metadata about the current state\n   */\n  meta: WorldStateMeta;\n  \n  /**\n   * Optional system-specific state extensions\n   */\n  extensions?: Record<string, unknown>;\n}\n\n/**\n * Metadata about the world state\n */\nexport interface WorldStateMeta {\n  /**\n   * Version of the world model\n   */\n  version: string;\n  \n  /**\n   * Timestamp when this state was created\n   */\n  timestamp: number;\n  \n  /**\n   * Current turn or tick number\n   */\n  turnNumber: number;\n  \n  /**\n   * ID of the current active entity (e.g., player character)\n   */\n  activeEntityId?: EntityId;\n  \n  /**\n   * ID of the current focal point (e.g., current room)\n   */\n  focusEntityId?: EntityId;\n}\n\n/**\n * A function that transforms a world state into a new world state\n */\nexport type StateTransformer = (state: WorldState) => WorldState;\n\n/**\n * History entry for tracking state changes\n */\nexport interface StateHistoryEntry {\n  /**\n   * The world state at this point in history\n   */\n  state: WorldState;\n  \n  /**\n   * Optional description of what caused this state change\n   */\n  description?: string;\n  \n  /**\n   * Optional command that led to this state\n   */\n  command?: string;\n}\n\n/**\n * Configuration for the state manager\n */\nexport interface StateManagerConfig {\n  /**\n   * Maximum number of history entries to keep\n   */\n  maxHistorySize?: number;\n  \n  /**\n   * Whether to enable undo functionality\n   */\n  enableUndo?: boolean;\n  \n  /**\n   * Whether to track all state changes or just command-driven ones\n   */\n  trackAllChanges?: boolean;\n}\n```\n\n### query.ts\n\n```typescript\n// packages/core/src/world-model/types/query.ts\n\nimport { Entity, EntityId } from './entity';\nimport { AttributeValue } from './attribute';\n\n/**\n * A predicate function that tests if an entity matches certain criteria\n */\nexport type EntityPredicate = (entity: Entity) => boolean;\n\n/**\n * Represents a query to find entities in the world state\n */\nexport interface EntityQuery {\n  /**\n   * Match entities of these types\n   */\n  types?: string[];\n  \n  /**\n   * Match entities with these attribute values\n   */\n  attributes?: Record<string, AttributeValue>;\n  \n  /**\n   * Match entities with these relationship types\n   */\n  relationships?: Record<string, EntityId[]>;\n  \n  /**\n   * Custom predicate function for complex matching\n   */\n  predicate?: EntityPredicate;\n  \n  /**\n   * Match any of the conditions instead of all (OR instead of AND)\n   */\n  matchAny?: boolean;\n}\n\n/**\n * Result of an entity query\n */\nexport interface QueryResult {\n  /**\n   * IDs of entities that matched the query\n   */\n  ids: EntityId[];\n  \n  /**\n   * The actual entity objects that matched\n   */\n  entities: Entity[];\n}\n\n/**\n * Options for entity queries\n */\nexport interface QueryOptions {\n  /**\n   * Maximum number of results to return\n   */\n  limit?: number;\n  \n  /**\n   * Sort results by this attribute\n   */\n  sortBy?: string;\n  \n  /**\n   * Sort direction\n   */\n  sortDirection?: 'asc' | 'desc';\n}\n```\n\n### extension.ts\n\n```typescript\n// packages/core/src/world-model/types/extension.ts\n\nimport { WorldState } from './state-tree';\n\n/**\n * Represents an extension to the world model\n */\nexport interface WorldModelExtension {\n  /**\n   * Unique identifier for this extension\n   */\n  id: string;\n  \n  /**\n   * Human-readable name of the extension\n   */\n  name: string;\n  \n  /**\n   * Initialize extension state\n   */\n  initialize: (state: WorldState) => WorldState;\n  \n  /**\n   * Clean up extension state\n   */\n  cleanup?: (state: WorldState) => WorldState;\n  \n  /**\n   * Process state changes \n   */\n  processStateChange?: (prevState: WorldState, nextState: WorldState) => WorldState;\n}\n\n/**\n * Registry of active extensions\n */\nexport interface ExtensionRegistry {\n  /**\n   * Map of extension IDs to extension instances\n   */\n  extensions: Record<string, WorldModelExtension>;\n  \n  /**\n   * Order in which extensions should be processed\n   */\n  processingOrder: string[];\n}\n```\n\n### index.ts\n\nFinally, let's create an index.ts file to export all these types:\n\n```typescript\n// packages/core/src/world-model/types/index.ts\n\n// Export all types\nexport * from './entity';\nexport * from './relationship';\nexport * from './attribute';\nexport * from './state-tree';\nexport * from './query';\nexport * from './extension';\n```\n\n## Next Steps\n\nWith these comprehensive type definitions, we've built a solid foundation for the world model. These types provide the building blocks for a flexible entity-relationship system with immutable state management.\n\nNext, we should implement:\n\n1. The immutable state manager implementation that uses these types\n2. Entity and relationship managers to provide CRUD operations\n3. Query functionality to efficiently find entities\n4. Event emission system for state changes\n\nWould you like me to proceed with any of these implementations next?",
      "content": [
        {
          "start_timestamp": "2025-03-27T21:50:28.352331Z",
          "stop_timestamp": "2025-03-27T21:50:56.377278Z",
          "type": "text",
          "text": " Let's continue by implementing the core types for the world model. I'll expand on the entity.ts file and create the other necessary type definitions for the world-model foundation.\n\n## World Model Types\n\nLet's flesh out the types directory with comprehensive type definitions:\n\n### entity.ts\n\n```typescript\n// packages/core/src/world-model/types/entity.ts\n\n/**\n * Unique identifier for entities in the world\n */\nexport type EntityId = string;\n\n/**\n * The base Entity interface representing any object in the world model\n */\nexport interface Entity {\n  /**\n   * Unique identifier for this entity\n   */\n  id: EntityId;\n  \n  /**\n   * The entity type, used for categorization and type checking\n   */\n  type: string;\n  \n  /**\n   * Arbitrary attributes/properties of the entity\n   */\n  attributes: Record<string, unknown>;\n  \n  /**\n   * Relationships to other entities, organized by relationship type\n   */\n  relationships: Record<string, EntityId[]>;\n}\n\n/**\n * Minimal information needed to create a new entity\n */\nexport interface EntityCreationParams {\n  type: string;\n  attributes?: Record<string, unknown>;\n  relationships?: Record<string, EntityId[]>;\n}\n\n/**\n * Configuration for how entity operations should be performed\n */\nexport interface EntityOperationOptions {\n  /**\n   * Whether to merge arrays in relationships instead of replacing them\n   */\n  mergeRelationships?: boolean;\n  \n  /**\n   * Whether to validate relationship target existence\n   */\n  validateRelationships?: boolean;\n}\n```\n\n### relationship.ts\n\n```typescript\n// packages/core/src/world-model/types/relationship.ts\n\nimport { EntityId } from './entity';\n\n/**\n * Defines the types of relationships that can exist between entities\n */\nexport enum RelationshipType {\n  CONTAINS = 'contains',\n  CONTAINED_BY = 'containedBy',\n  CONNECTS_TO = 'connectsTo',\n  CONNECTED_FROM = 'connectedFrom',\n  SUPPORTS = 'supports',\n  SUPPORTED_BY = 'supportedBy',\n  ADJACENT_TO = 'adjacentTo',\n  BELONGS_TO = 'belongsTo',\n  RELATED_TO = 'relatedTo'\n}\n\n/**\n * A relationship between two entities\n */\nexport interface Relationship {\n  /**\n   * The source entity of the relationship\n   */\n  sourceId: EntityId;\n  \n  /**\n   * The type of relationship\n   */\n  type: RelationshipType | string;\n  \n  /**\n   * The target entity of the relationship\n   */\n  targetId: EntityId;\n  \n  /**\n   * Optional metadata for the relationship\n   */\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Configuration for creating a relationship\n */\nexport interface RelationshipConfig {\n  /**\n   * Whether this relationship creates an inverse relationship automatically\n   */\n  bidirectional?: boolean;\n  \n  /**\n   * If bidirectional, the name of the inverse relationship\n   */\n  inverseType?: RelationshipType | string;\n  \n  /**\n   * Whether this relationship is exclusive (replaces previous relationships of same type)\n   */\n  exclusive?: boolean;\n}\n\n/**\n * Map of relationship type configurations\n */\nexport type RelationshipConfigMap = Record<string, RelationshipConfig>;\n\n/**\n * Standard relationship configurations with their inverse mappings\n */\nexport const STANDARD_RELATIONSHIP_CONFIGS: RelationshipConfigMap = {\n  [RelationshipType.CONTAINS]: {\n    bidirectional: true,\n    inverseType: RelationshipType.CONTAINED_BY,\n    exclusive: false\n  },\n  [RelationshipType.CONNECTS_TO]: {\n    bidirectional: true,\n    inverseType: RelationshipType.CONNECTED_FROM,\n    exclusive: false\n  },\n  [RelationshipType.SUPPORTS]: {\n    bidirectional: true,\n    inverseType: RelationshipType.SUPPORTED_BY,\n    exclusive: false\n  },\n  [RelationshipType.ADJACENT_TO]: {\n    bidirectional: true,\n    inverseType: RelationshipType.ADJACENT_TO,\n    exclusive: false\n  }\n};\n```\n\n### attribute.ts\n\n```typescript\n// packages/core/src/world-model/types/attribute.ts\n\n/**\n * Possible types for attribute values\n */\nexport type AttributeValue = \n  | string \n  | number \n  | boolean \n  | null \n  | AttributeObject \n  | AttributeArray;\n\n/**\n * An object containing attribute values\n */\nexport interface AttributeObject {\n  [key: string]: AttributeValue;\n}\n\n/**\n * An array of attribute values\n */\nexport type AttributeArray = AttributeValue[];\n\n/**\n * Standard attribute keys used across the system\n */\nexport enum StandardAttribute {\n  NAME = 'name',\n  DESCRIPTION = 'description',\n  VISIBLE = 'visible',\n  ACCESSIBLE = 'accessible',\n  WEIGHT = 'weight',\n  SIZE = 'size',\n  POSITION = 'position',\n  STATE = 'state',\n}\n\n/**\n * Configuration for an attribute\n */\nexport interface AttributeConfig {\n  /**\n   * Type validation for this attribute\n   */\n  type?: 'string' | 'number' | 'boolean' | 'object' | 'array';\n  \n  /**\n   * Whether this attribute is required for the entity\n   */\n  required?: boolean;\n  \n  /**\n   * Default value if none is provided\n   */\n  default?: AttributeValue;\n  \n  /**\n   * Custom validation function\n   */\n  validate?: (value: AttributeValue) => boolean;\n}\n\n/**\n * A map of attribute configurations\n */\nexport type AttributeConfigMap = Record<string, AttributeConfig>;\n```\n\n### state-tree.ts\n\n```typescript\n// packages/core/src/world-model/types/state-tree.ts\n\nimport { Entity, EntityId } from './entity';\n\n/**\n * Represents the entire world state as an immutable tree\n */\nexport interface WorldState {\n  /**\n   * All entities indexed by their ID\n   */\n  entities: Record<EntityId, Entity>;\n  \n  /**\n   * Metadata about the current state\n   */\n  meta: WorldStateMeta;\n  \n  /**\n   * Optional system-specific state extensions\n   */\n  extensions?: Record<string, unknown>;\n}\n\n/**\n * Metadata about the world state\n */\nexport interface WorldStateMeta {\n  /**\n   * Version of the world model\n   */\n  version: string;\n  \n  /**\n   * Timestamp when this state was created\n   */\n  timestamp: number;\n  \n  /**\n   * Current turn or tick number\n   */\n  turnNumber: number;\n  \n  /**\n   * ID of the current active entity (e.g., player character)\n   */\n  activeEntityId?: EntityId;\n  \n  /**\n   * ID of the current focal point (e.g., current room)\n   */\n  focusEntityId?: EntityId;\n}\n\n/**\n * A function that transforms a world state into a new world state\n */\nexport type StateTransformer = (state: WorldState) => WorldState;\n\n/**\n * History entry for tracking state changes\n */\nexport interface StateHistoryEntry {\n  /**\n   * The world state at this point in history\n   */\n  state: WorldState;\n  \n  /**\n   * Optional description of what caused this state change\n   */\n  description?: string;\n  \n  /**\n   * Optional command that led to this state\n   */\n  command?: string;\n}\n\n/**\n * Configuration for the state manager\n */\nexport interface StateManagerConfig {\n  /**\n   * Maximum number of history entries to keep\n   */\n  maxHistorySize?: number;\n  \n  /**\n   * Whether to enable undo functionality\n   */\n  enableUndo?: boolean;\n  \n  /**\n   * Whether to track all state changes or just command-driven ones\n   */\n  trackAllChanges?: boolean;\n}\n```\n\n### query.ts\n\n```typescript\n// packages/core/src/world-model/types/query.ts\n\nimport { Entity, EntityId } from './entity';\nimport { AttributeValue } from './attribute';\n\n/**\n * A predicate function that tests if an entity matches certain criteria\n */\nexport type EntityPredicate = (entity: Entity) => boolean;\n\n/**\n * Represents a query to find entities in the world state\n */\nexport interface EntityQuery {\n  /**\n   * Match entities of these types\n   */\n  types?: string[];\n  \n  /**\n   * Match entities with these attribute values\n   */\n  attributes?: Record<string, AttributeValue>;\n  \n  /**\n   * Match entities with these relationship types\n   */\n  relationships?: Record<string, EntityId[]>;\n  \n  /**\n   * Custom predicate function for complex matching\n   */\n  predicate?: EntityPredicate;\n  \n  /**\n   * Match any of the conditions instead of all (OR instead of AND)\n   */\n  matchAny?: boolean;\n}\n\n/**\n * Result of an entity query\n */\nexport interface QueryResult {\n  /**\n   * IDs of entities that matched the query\n   */\n  ids: EntityId[];\n  \n  /**\n   * The actual entity objects that matched\n   */\n  entities: Entity[];\n}\n\n/**\n * Options for entity queries\n */\nexport interface QueryOptions {\n  /**\n   * Maximum number of results to return\n   */\n  limit?: number;\n  \n  /**\n   * Sort results by this attribute\n   */\n  sortBy?: string;\n  \n  /**\n   * Sort direction\n   */\n  sortDirection?: 'asc' | 'desc';\n}\n```\n\n### extension.ts\n\n```typescript\n// packages/core/src/world-model/types/extension.ts\n\nimport { WorldState } from './state-tree';\n\n/**\n * Represents an extension to the world model\n */\nexport interface WorldModelExtension {\n  /**\n   * Unique identifier for this extension\n   */\n  id: string;\n  \n  /**\n   * Human-readable name of the extension\n   */\n  name: string;\n  \n  /**\n   * Initialize extension state\n   */\n  initialize: (state: WorldState) => WorldState;\n  \n  /**\n   * Clean up extension state\n   */\n  cleanup?: (state: WorldState) => WorldState;\n  \n  /**\n   * Process state changes \n   */\n  processStateChange?: (prevState: WorldState, nextState: WorldState) => WorldState;\n}\n\n/**\n * Registry of active extensions\n */\nexport interface ExtensionRegistry {\n  /**\n   * Map of extension IDs to extension instances\n   */\n  extensions: Record<string, WorldModelExtension>;\n  \n  /**\n   * Order in which extensions should be processed\n   */\n  processingOrder: string[];\n}\n```\n\n### index.ts\n\nFinally, let's create an index.ts file to export all these types:\n\n```typescript\n// packages/core/src/world-model/types/index.ts\n\n// Export all types\nexport * from './entity';\nexport * from './relationship';\nexport * from './attribute';\nexport * from './state-tree';\nexport * from './query';\nexport * from './extension';\n```\n\n## Next Steps\n\nWith these comprehensive type definitions, we've built a solid foundation for the world model. These types provide the building blocks for a flexible entity-relationship system with immutable state management.\n\nNext, we should implement:\n\n1. The immutable state manager implementation that uses these types\n2. Entity and relationship managers to provide CRUD operations\n3. Query functionality to efficiently find entities\n4. Event emission system for state changes\n\nWould you like me to proceed with any of these implementations next?",
          "citations": []
        }
      ],
      "sender": "assistant",
      "created_at": "2025-03-27T21:51:05.293634Z",
      "updated_at": "2025-03-27T21:51:05.293634Z",
      "attachments": [],
      "files": []
    },
    {
      "uuid": "2034bebe-7e11-42ae-b57f-774e092e04c1",
      "text": "let's implement the immutate state manager",
      "content": [
        {
          "start_timestamp": "2025-03-27T21:13:30.736859Z",
          "stop_timestamp": "2025-03-27T21:13:30.736859Z",
          "type": "text",
          "text": "let's implement the immutate state manager",
          "citations": []
        }
      ],
      "sender": "human",
      "created_at": "2025-03-27T21:53:58.736511Z",
      "updated_at": "2025-03-27T21:53:58.736511Z",
      "attachments": [],
      "files": []
    },
    {
      "uuid": "7ad4d758-2dff-4117-8e75-4c2a91b2bd33",
      "text": " Let's implement the immutable state manager that will serve as the core of our world model. This will handle state transitions, history tracking, and provide a clean interface for modifying the world state.\n\nI'll create the implementation in `packages/core/src/world-model/implementations/immutable-state.ts`:\n\n```typescript\n// packages/core/src/world-model/implementations/immutable-state.ts\n\nimport {\n  WorldState,\n  WorldStateMeta,\n  StateHistoryEntry,\n  StateManagerConfig,\n  StateTransformer,\n  Entity,\n  EntityId,\n  EntityCreationParams,\n  EntityOperationOptions\n} from '../types';\n\n/**\n * Default configuration for the state manager\n */\nconst DEFAULT_CONFIG: StateManagerConfig = {\n  maxHistorySize: 100,\n  enableUndo: true,\n  trackAllChanges: false\n};\n\n/**\n * Manages the immutable state of the world and its history\n */\nexport class StateManager {\n  private currentState: WorldState;\n  private history: StateHistoryEntry[] = [];\n  private config: StateManagerConfig;\n  private undoStack: StateHistoryEntry[] = [];\n  private redoStack: StateHistoryEntry[] = [];\n\n  /**\n   * Creates a new StateManager\n   * @param initialState Initial world state or undefined to create default\n   * @param config Configuration options\n   */\n  constructor(initialState?: WorldState, config: Partial<StateManagerConfig> = {}) {\n    this.config = { ...DEFAULT_CONFIG, ...config };\n    this.currentState = initialState || this.createInitialState();\n    this.addToHistory(this.currentState, 'Initial state');\n  }\n\n  /**\n   * Creates a default initial state\n   */\n  private createInitialState(): WorldState {\n    const meta: WorldStateMeta = {\n      version: '1.0.0',\n      timestamp: Date.now(),\n      turnNumber: 0\n    };\n\n    return {\n      entities: {},\n      meta\n    };\n  }\n\n  /**\n   * Gets the current world state\n   */\n  public getState(): WorldState {\n    return this.currentState;\n  }\n\n  /**\n   * Gets an entity by ID from the current state\n   * @param id Entity ID\n   */\n  public getEntity(id: EntityId): Entity | undefined {\n    return this.currentState.entities[id];\n  }\n\n  /**\n   * Updates the world state using a transformer function\n   * @param transformer Function that transforms the state\n   * @param description Description of the update for history\n   */\n  public updateState(transformer: StateTransformer, description?: string): WorldState {\n    const nextState = transformer(this.currentState);\n    \n    // Only update if something changed\n    if (nextState !== this.currentState) {\n      // Update metadata\n      const updatedState = {\n        ...nextState,\n        meta: {\n          ...nextState.meta,\n          timestamp: Date.now(),\n          turnNumber: this.currentState.meta.turnNumber + 1\n        }\n      };\n\n      this.currentState = updatedState;\n      \n      // Add to history if tracking all changes or if description provided\n      if (this.config.trackAllChanges || description) {\n        this.addToHistory(updatedState, description);\n      }\n      \n      // Clear redo stack since we've made a new change\n      this.redoStack = [];\n    }\n    \n    return this.currentState;\n  }\n\n  /**\n   * Adds a state to the history\n   * @param state State to add\n   * @param description Description of what caused this state\n   * @param command Command that led to this state\n   */\n  private addToHistory(state: WorldState, description?: string, command?: string): void {\n    const entry: StateHistoryEntry = {\n      state,\n      description,\n      command\n    };\n\n    this.history.push(entry);\n    \n    // Limit history size\n    if (this.config.maxHistorySize && this.history.length > this.config.maxHistorySize) {\n      this.history.shift();\n    }\n    \n    // Add to undo stack if undo is enabled\n    if (this.config.enableUndo) {\n      this.undoStack.push(entry);\n    }\n  }\n\n  /**\n   * Gets the history of state changes\n   */\n  public getHistory(): StateHistoryEntry[] {\n    return [...this.history];\n  }\n\n  /**\n   * Undoes the last state change\n   * @returns The previous state or undefined if no previous state\n   */\n  public undo(): WorldState | undefined {\n    if (!this.config.enableUndo || this.undoStack.length <= 1) {\n      return undefined;\n    }\n\n    // Pop the current state off the undo stack\n    const current = this.undoStack.pop()!;\n    \n    // Add to redo stack\n    this.redoStack.push(current);\n    \n    // Get the previous state\n    const previous = this.undoStack[this.undoStack.length - 1];\n    \n    // Set as current state\n    this.currentState = previous.state;\n    \n    return this.currentState;\n  }\n\n  /**\n   * Redoes the last undone state change\n   * @returns The redone state or undefined if no state to redo\n   */\n  public redo(): WorldState | undefined {\n    if (!this.config.enableUndo || this.redoStack.length === 0) {\n      return undefined;\n    }\n\n    // Pop the most recent state off the redo stack\n    const next = this.redoStack.pop()!;\n    \n    // Add to undo stack\n    this.undoStack.push(next);\n    \n    // Set as current state\n    this.currentState = next.state;\n    \n    return this.currentState;\n  }\n\n  /**\n   * Creates and adds a new entity to the world state\n   * @param params Entity creation parameters\n   * @param description Description for history\n   */\n  public createEntity(params: EntityCreationParams, description?: string): Entity {\n    const id = this.generateId();\n    \n    const entity: Entity = {\n      id,\n      type: params.type,\n      attributes: params.attributes || {},\n      relationships: params.relationships || {}\n    };\n\n    this.updateState(state => ({\n      ...state,\n      entities: {\n        ...state.entities,\n        [id]: entity\n      }\n    }), description || `Created entity: ${entity.type} (${id})`);\n\n    return entity;\n  }\n\n  /**\n   * Updates an existing entity\n   * @param id Entity ID to update\n   * @param updates Partial entity updates\n   * @param options Update options\n   * @param description Description for history\n   */\n  public updateEntity(\n    id: EntityId, \n    updates: Partial<Entity>, \n    options: EntityOperationOptions = {},\n    description?: string\n  ): Entity | undefined {\n    const existingEntity = this.getEntity(id);\n    if (!existingEntity) return undefined;\n\n    this.updateState(state => {\n      const updatedEntity = this.mergeEntity(existingEntity, updates, options);\n      \n      return {\n        ...state,\n        entities: {\n          ...state.entities,\n          [id]: updatedEntity\n        }\n      };\n    }, description || `Updated entity: ${existingEntity.type} (${id})`);\n\n    return this.getEntity(id);\n  }\n\n  /**\n   * Removes an entity from the world state\n   * @param id Entity ID to remove\n   * @param description Description for history\n   */\n  public removeEntity(id: EntityId, description?: string): boolean {\n    const existingEntity = this.getEntity(id);\n    if (!existingEntity) return false;\n\n    this.updateState(state => {\n      const { [id]: _, ...remainingEntities } = state.entities;\n      \n      return {\n        ...state,\n        entities: remainingEntities\n      };\n    }, description || `Removed entity: ${existingEntity.type} (${id})`);\n\n    return true;\n  }\n\n  /**\n   * Creates a relationship between two entities\n   * @param sourceId Source entity ID\n   * @param type Relationship type\n   * @param targetId Target entity ID\n   * @param description Description for history\n   */\n  public createRelationship(\n    sourceId: EntityId,\n    type: string,\n    targetId: EntityId,\n    description?: string\n  ): boolean {\n    const source = this.getEntity(sourceId);\n    const target = this.getEntity(targetId);\n    \n    if (!source || !target) return false;\n\n    this.updateState(state => {\n      const existingRelationships = source.relationships[type] || [];\n      \n      // Skip if relationship already exists\n      if (existingRelationships.includes(targetId)) {\n        return state;\n      }\n      \n      return {\n        ...state,\n        entities: {\n          ...state.entities,\n          [sourceId]: {\n            ...source,\n            relationships: {\n              ...source.relationships,\n              [type]: [...existingRelationships, targetId]\n            }\n          }\n        }\n      };\n    }, description || `Created relationship: ${sourceId} -[${type}]-> ${targetId}`);\n\n    return true;\n  }\n\n  /**\n   * Removes a relationship between two entities\n   * @param sourceId Source entity ID\n   * @param type Relationship type\n   * @param targetId Target entity ID\n   * @param description Description for history\n   */\n  public removeRelationship(\n    sourceId: EntityId,\n    type: string,\n    targetId: EntityId,\n    description?: string\n  ): boolean {\n    const source = this.getEntity(sourceId);\n    \n    if (!source) return false;\n    \n    const existingRelationships = source.relationships[type] || [];\n    \n    // Skip if relationship doesn't exist\n    if (!existingRelationships.includes(targetId)) {\n      return false;\n    }\n\n    this.updateState(state => {\n      return {\n        ...state,\n        entities: {\n          ...state.entities,\n          [sourceId]: {\n            ...source,\n            relationships: {\n              ...source.relationships,\n              [type]: existingRelationships.filter(id => id !== targetId)\n            }\n          }\n        }\n      };\n    }, description || `Removed relationship: ${sourceId} -[${type}]-> ${targetId}`);\n\n    return true;\n  }\n\n  /**\n   * Helper method to merge entity updates\n   */\n  private mergeEntity(\n    entity: Entity, \n    updates: Partial<Entity>,\n    options: EntityOperationOptions\n  ): Entity {\n    // Handle basic properties\n    const result: Entity = {\n      ...entity,\n      ...updates,\n      // Always preserve ID\n      id: entity.id,\n      // Always preserve type if not explicitly changed\n      type: updates.type || entity.type,\n    };\n    \n    // Handle attributes merge\n    if (updates.attributes) {\n      result.attributes = {\n        ...entity.attributes,\n        ...updates.attributes\n      };\n    }\n    \n    // Handle relationships merge\n    if (updates.relationships) {\n      if (options.mergeRelationships) {\n        // Merge relationship arrays instead of replacing\n        result.relationships = { ...entity.relationships };\n        \n        for (const [type, targets] of Object.entries(updates.relationships)) {\n          const existing = entity.relationships[type] || [];\n          // Deduplicate targets\n          const uniqueTargets = [...new Set([...existing, ...targets])];\n          result.relationships[type] = uniqueTargets;\n        }\n      } else {\n        // Replace relationships\n        result.relationships = {\n          ...entity.relationships,\n          ...updates.relationships\n        };\n      }\n    }\n    \n    return result;\n  }\n\n  /**\n   * Generate a unique entity ID\n   */\n  private generateId(): string {\n    return `entity_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`;\n  }\n}\n\n/**\n * Creates a new state manager with default initial state\n * @param config Configuration options\n */\nexport function createStateManager(config?: Partial<StateManagerConfig>): StateManager {\n  return new StateManager(undefined, config);\n}\n```\n\nThis implementation provides:\n\n1. **Immutable State Management**: All state updates create a new state object, preserving the old one\n2. **History Tracking**: State changes are recorded with descriptions\n3. **Undo/Redo Functionality**: Time travel through state changes\n4. **Entity Management**: Create, update, and remove entities\n5. **Relationship Management**: Create and remove relationships between entities\n\nNow let's create a simple index.ts file to export this functionality:\n\n```typescript\n// packages/core/src/world-model/implementations/index.ts\n\nexport * from './immutable-state';\n// We'll add other implementations here as we create them\n```\n\nAnd update the main index file to include our implementations:\n\n```typescript\n// packages/core/src/world-model/index.ts\n\nexport * from './types';\nexport * from './implementations';\n```\n\nFor the next steps, we should:\n\n1. Create the EntityManager implementation with more sophisticated entity operations\n2. Implement the RelationshipManager with bidirectional relationship support\n3. Build the EventEmitter system for state change notifications\n4. Create a QueryEngine for finding entities by criteria\n\nWould you like me to continue with any of these components next?",
      "content": [
        {
          "start_timestamp": "2025-03-27T21:54:00.245962Z",
          "stop_timestamp": "2025-03-27T21:54:30.651288Z",
          "type": "text",
          "text": " Let's implement the immutable state manager that will serve as the core of our world model. This will handle state transitions, history tracking, and provide a clean interface for modifying the world state.\n\nI'll create the implementation in `packages/core/src/world-model/implementations/immutable-state.ts`:\n\n```typescript\n// packages/core/src/world-model/implementations/immutable-state.ts\n\nimport {\n  WorldState,\n  WorldStateMeta,\n  StateHistoryEntry,\n  StateManagerConfig,\n  StateTransformer,\n  Entity,\n  EntityId,\n  EntityCreationParams,\n  EntityOperationOptions\n} from '../types';\n\n/**\n * Default configuration for the state manager\n */\nconst DEFAULT_CONFIG: StateManagerConfig = {\n  maxHistorySize: 100,\n  enableUndo: true,\n  trackAllChanges: false\n};\n\n/**\n * Manages the immutable state of the world and its history\n */\nexport class StateManager {\n  private currentState: WorldState;\n  private history: StateHistoryEntry[] = [];\n  private config: StateManagerConfig;\n  private undoStack: StateHistoryEntry[] = [];\n  private redoStack: StateHistoryEntry[] = [];\n\n  /**\n   * Creates a new StateManager\n   * @param initialState Initial world state or undefined to create default\n   * @param config Configuration options\n   */\n  constructor(initialState?: WorldState, config: Partial<StateManagerConfig> = {}) {\n    this.config = { ...DEFAULT_CONFIG, ...config };\n    this.currentState = initialState || this.createInitialState();\n    this.addToHistory(this.currentState, 'Initial state');\n  }\n\n  /**\n   * Creates a default initial state\n   */\n  private createInitialState(): WorldState {\n    const meta: WorldStateMeta = {\n      version: '1.0.0',\n      timestamp: Date.now(),\n      turnNumber: 0\n    };\n\n    return {\n      entities: {},\n      meta\n    };\n  }\n\n  /**\n   * Gets the current world state\n   */\n  public getState(): WorldState {\n    return this.currentState;\n  }\n\n  /**\n   * Gets an entity by ID from the current state\n   * @param id Entity ID\n   */\n  public getEntity(id: EntityId): Entity | undefined {\n    return this.currentState.entities[id];\n  }\n\n  /**\n   * Updates the world state using a transformer function\n   * @param transformer Function that transforms the state\n   * @param description Description of the update for history\n   */\n  public updateState(transformer: StateTransformer, description?: string): WorldState {\n    const nextState = transformer(this.currentState);\n    \n    // Only update if something changed\n    if (nextState !== this.currentState) {\n      // Update metadata\n      const updatedState = {\n        ...nextState,\n        meta: {\n          ...nextState.meta,\n          timestamp: Date.now(),\n          turnNumber: this.currentState.meta.turnNumber + 1\n        }\n      };\n\n      this.currentState = updatedState;\n      \n      // Add to history if tracking all changes or if description provided\n      if (this.config.trackAllChanges || description) {\n        this.addToHistory(updatedState, description);\n      }\n      \n      // Clear redo stack since we've made a new change\n      this.redoStack = [];\n    }\n    \n    return this.currentState;\n  }\n\n  /**\n   * Adds a state to the history\n   * @param state State to add\n   * @param description Description of what caused this state\n   * @param command Command that led to this state\n   */\n  private addToHistory(state: WorldState, description?: string, command?: string): void {\n    const entry: StateHistoryEntry = {\n      state,\n      description,\n      command\n    };\n\n    this.history.push(entry);\n    \n    // Limit history size\n    if (this.config.maxHistorySize && this.history.length > this.config.maxHistorySize) {\n      this.history.shift();\n    }\n    \n    // Add to undo stack if undo is enabled\n    if (this.config.enableUndo) {\n      this.undoStack.push(entry);\n    }\n  }\n\n  /**\n   * Gets the history of state changes\n   */\n  public getHistory(): StateHistoryEntry[] {\n    return [...this.history];\n  }\n\n  /**\n   * Undoes the last state change\n   * @returns The previous state or undefined if no previous state\n   */\n  public undo(): WorldState | undefined {\n    if (!this.config.enableUndo || this.undoStack.length <= 1) {\n      return undefined;\n    }\n\n    // Pop the current state off the undo stack\n    const current = this.undoStack.pop()!;\n    \n    // Add to redo stack\n    this.redoStack.push(current);\n    \n    // Get the previous state\n    const previous = this.undoStack[this.undoStack.length - 1];\n    \n    // Set as current state\n    this.currentState = previous.state;\n    \n    return this.currentState;\n  }\n\n  /**\n   * Redoes the last undone state change\n   * @returns The redone state or undefined if no state to redo\n   */\n  public redo(): WorldState | undefined {\n    if (!this.config.enableUndo || this.redoStack.length === 0) {\n      return undefined;\n    }\n\n    // Pop the most recent state off the redo stack\n    const next = this.redoStack.pop()!;\n    \n    // Add to undo stack\n    this.undoStack.push(next);\n    \n    // Set as current state\n    this.currentState = next.state;\n    \n    return this.currentState;\n  }\n\n  /**\n   * Creates and adds a new entity to the world state\n   * @param params Entity creation parameters\n   * @param description Description for history\n   */\n  public createEntity(params: EntityCreationParams, description?: string): Entity {\n    const id = this.generateId();\n    \n    const entity: Entity = {\n      id,\n      type: params.type,\n      attributes: params.attributes || {},\n      relationships: params.relationships || {}\n    };\n\n    this.updateState(state => ({\n      ...state,\n      entities: {\n        ...state.entities,\n        [id]: entity\n      }\n    }), description || `Created entity: ${entity.type} (${id})`);\n\n    return entity;\n  }\n\n  /**\n   * Updates an existing entity\n   * @param id Entity ID to update\n   * @param updates Partial entity updates\n   * @param options Update options\n   * @param description Description for history\n   */\n  public updateEntity(\n    id: EntityId, \n    updates: Partial<Entity>, \n    options: EntityOperationOptions = {},\n    description?: string\n  ): Entity | undefined {\n    const existingEntity = this.getEntity(id);\n    if (!existingEntity) return undefined;\n\n    this.updateState(state => {\n      const updatedEntity = this.mergeEntity(existingEntity, updates, options);\n      \n      return {\n        ...state,\n        entities: {\n          ...state.entities,\n          [id]: updatedEntity\n        }\n      };\n    }, description || `Updated entity: ${existingEntity.type} (${id})`);\n\n    return this.getEntity(id);\n  }\n\n  /**\n   * Removes an entity from the world state\n   * @param id Entity ID to remove\n   * @param description Description for history\n   */\n  public removeEntity(id: EntityId, description?: string): boolean {\n    const existingEntity = this.getEntity(id);\n    if (!existingEntity) return false;\n\n    this.updateState(state => {\n      const { [id]: _, ...remainingEntities } = state.entities;\n      \n      return {\n        ...state,\n        entities: remainingEntities\n      };\n    }, description || `Removed entity: ${existingEntity.type} (${id})`);\n\n    return true;\n  }\n\n  /**\n   * Creates a relationship between two entities\n   * @param sourceId Source entity ID\n   * @param type Relationship type\n   * @param targetId Target entity ID\n   * @param description Description for history\n   */\n  public createRelationship(\n    sourceId: EntityId,\n    type: string,\n    targetId: EntityId,\n    description?: string\n  ): boolean {\n    const source = this.getEntity(sourceId);\n    const target = this.getEntity(targetId);\n    \n    if (!source || !target) return false;\n\n    this.updateState(state => {\n      const existingRelationships = source.relationships[type] || [];\n      \n      // Skip if relationship already exists\n      if (existingRelationships.includes(targetId)) {\n        return state;\n      }\n      \n      return {\n        ...state,\n        entities: {\n          ...state.entities,\n          [sourceId]: {\n            ...source,\n            relationships: {\n              ...source.relationships,\n              [type]: [...existingRelationships, targetId]\n            }\n          }\n        }\n      };\n    }, description || `Created relationship: ${sourceId} -[${type}]-> ${targetId}`);\n\n    return true;\n  }\n\n  /**\n   * Removes a relationship between two entities\n   * @param sourceId Source entity ID\n   * @param type Relationship type\n   * @param targetId Target entity ID\n   * @param description Description for history\n   */\n  public removeRelationship(\n    sourceId: EntityId,\n    type: string,\n    targetId: EntityId,\n    description?: string\n  ): boolean {\n    const source = this.getEntity(sourceId);\n    \n    if (!source) return false;\n    \n    const existingRelationships = source.relationships[type] || [];\n    \n    // Skip if relationship doesn't exist\n    if (!existingRelationships.includes(targetId)) {\n      return false;\n    }\n\n    this.updateState(state => {\n      return {\n        ...state,\n        entities: {\n          ...state.entities,\n          [sourceId]: {\n            ...source,\n            relationships: {\n              ...source.relationships,\n              [type]: existingRelationships.filter(id => id !== targetId)\n            }\n          }\n        }\n      };\n    }, description || `Removed relationship: ${sourceId} -[${type}]-> ${targetId}`);\n\n    return true;\n  }\n\n  /**\n   * Helper method to merge entity updates\n   */\n  private mergeEntity(\n    entity: Entity, \n    updates: Partial<Entity>,\n    options: EntityOperationOptions\n  ): Entity {\n    // Handle basic properties\n    const result: Entity = {\n      ...entity,\n      ...updates,\n      // Always preserve ID\n      id: entity.id,\n      // Always preserve type if not explicitly changed\n      type: updates.type || entity.type,\n    };\n    \n    // Handle attributes merge\n    if (updates.attributes) {\n      result.attributes = {\n        ...entity.attributes,\n        ...updates.attributes\n      };\n    }\n    \n    // Handle relationships merge\n    if (updates.relationships) {\n      if (options.mergeRelationships) {\n        // Merge relationship arrays instead of replacing\n        result.relationships = { ...entity.relationships };\n        \n        for (const [type, targets] of Object.entries(updates.relationships)) {\n          const existing = entity.relationships[type] || [];\n          // Deduplicate targets\n          const uniqueTargets = [...new Set([...existing, ...targets])];\n          result.relationships[type] = uniqueTargets;\n        }\n      } else {\n        // Replace relationships\n        result.relationships = {\n          ...entity.relationships,\n          ...updates.relationships\n        };\n      }\n    }\n    \n    return result;\n  }\n\n  /**\n   * Generate a unique entity ID\n   */\n  private generateId(): string {\n    return `entity_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`;\n  }\n}\n\n/**\n * Creates a new state manager with default initial state\n * @param config Configuration options\n */\nexport function createStateManager(config?: Partial<StateManagerConfig>): StateManager {\n  return new StateManager(undefined, config);\n}\n```\n\nThis implementation provides:\n\n1. **Immutable State Management**: All state updates create a new state object, preserving the old one\n2. **History Tracking**: State changes are recorded with descriptions\n3. **Undo/Redo Functionality**: Time travel through state changes\n4. **Entity Management**: Create, update, and remove entities\n5. **Relationship Management**: Create and remove relationships between entities\n\nNow let's create a simple index.ts file to export this functionality:\n\n```typescript\n// packages/core/src/world-model/implementations/index.ts\n\nexport * from './immutable-state';\n// We'll add other implementations here as we create them\n```\n\nAnd update the main index file to include our implementations:\n\n```typescript\n// packages/core/src/world-model/index.ts\n\nexport * from './types';\nexport * from './implementations';\n```\n\nFor the next steps, we should:\n\n1. Create the EntityManager implementation with more sophisticated entity operations\n2. Implement the RelationshipManager with bidirectional relationship support\n3. Build the EventEmitter system for state change notifications\n4. Create a QueryEngine for finding entities by criteria\n\nWould you like me to continue with any of these components next?",
          "citations": []
        }
      ],
      "sender": "assistant",
      "created_at": "2025-03-27T21:54:40.493804Z",
      "updated_at": "2025-03-27T21:54:40.493804Z",
      "attachments": [],
      "files": []
    },
    {
      "uuid": "3a390663-9798-477e-b7a7-17c242e5922b",
      "text": "let's create EntityManager",
      "content": [
        {
          "start_timestamp": "2025-03-27T21:16:11.858032Z",
          "stop_timestamp": "2025-03-27T21:16:11.858032Z",
          "type": "text",
          "text": "let's create EntityManager",
          "citations": []
        }
      ],
      "sender": "human",
      "created_at": "2025-03-27T21:57:44.412136Z",
      "updated_at": "2025-03-27T21:57:44.412136Z",
      "attachments": [],
      "files": []
    },
    {
      "uuid": "ba283c3b-f4bc-4a83-a443-5fa81e249d26",
      "text": " Let's implement the EntityManager class to provide more sophisticated entity operations on top of our StateManager.\n\nThe EntityManager will enhance our entity management capabilities with features like entity templates, validation, and more efficient relationship handling. Here's the implementation:\n\n```typescript\n// packages/core/src/world-model/implementations/entity-manager.ts\n\nimport {\n  Entity,\n  EntityId,\n  EntityCreationParams,\n  EntityOperationOptions,\n  AttributeConfigMap,\n  AttributeValue,\n  RelationshipConfigMap,\n  RelationshipType,\n  WorldState\n} from '../types';\nimport { StateManager } from './immutable-state';\n\n/**\n * Configuration options for the EntityManager\n */\nexport interface EntityManagerConfig {\n  /**\n   * Map of entity types to attribute configurations\n   */\n  attributeConfigs?: Record<string, AttributeConfigMap>;\n  \n  /**\n   * Map of relationship types to relationship configurations\n   */\n  relationshipConfigs?: RelationshipConfigMap;\n  \n  /**\n   * Whether to validate entities on creation and update\n   */\n  validateEntities?: boolean;\n}\n\n/**\n * Default configuration for EntityManager\n */\nconst DEFAULT_CONFIG: EntityManagerConfig = {\n  attributeConfigs: {},\n  relationshipConfigs: {},\n  validateEntities: true\n};\n\n/**\n * Provides higher-level entity operations on top of the StateManager\n */\nexport class EntityManager {\n  private stateManager: StateManager;\n  private config: EntityManagerConfig;\n  \n  /**\n   * Creates a new EntityManager\n   * @param stateManager The state manager to use\n   * @param config Configuration options\n   */\n  constructor(stateManager: StateManager, config: Partial<EntityManagerConfig> = {}) {\n    this.stateManager = stateManager;\n    this.config = { ...DEFAULT_CONFIG, ...config };\n  }\n  \n  /**\n   * Gets the current world state\n   */\n  public getState(): WorldState {\n    return this.stateManager.getState();\n  }\n  \n  /**\n   * Gets an entity by ID\n   * @param id Entity ID\n   */\n  public getEntity(id: EntityId): Entity | undefined {\n    return this.stateManager.getEntity(id);\n  }\n  \n  /**\n   * Creates a new entity\n   * @param params Entity creation parameters\n   * @param options Optional creation options\n   */\n  public createEntity(\n    params: EntityCreationParams,\n    options: EntityOperationOptions = {}\n  ): Entity {\n    // Validate attributes if validation is enabled\n    if (this.config.validateEntities) {\n      this.validateAttributes(params.type, params.attributes || {});\n    }\n    \n    // Create the entity\n    const entity = this.stateManager.createEntity(params);\n    \n    // Create bidirectional relationships if configured\n    if (params.relationships) {\n      this.createBidirectionalRelationships(entity.id, params.relationships);\n    }\n    \n    return entity;\n  }\n  \n  /**\n   * Updates an existing entity\n   * @param id Entity ID\n   * @param updates Entity updates\n   * @param options Update options\n   */\n  public updateEntity(\n    id: EntityId,\n    updates: Partial<Entity>,\n    options: EntityOperationOptions = {}\n  ): Entity | undefined {\n    const existingEntity = this.getEntity(id);\n    if (!existingEntity) return undefined;\n    \n    // Validate attributes if validation is enabled\n    if (this.config.validateEntities && updates.attributes) {\n      this.validateAttributes(\n        updates.type || existingEntity.type,\n        updates.attributes\n      );\n    }\n    \n    // Update the entity\n    const updatedEntity = this.stateManager.updateEntity(id, updates, options);\n    \n    // Update bidirectional relationships if needed\n    if (updatedEntity && updates.relationships) {\n      this.updateBidirectionalRelationships(\n        id, \n        existingEntity.relationships, \n        updatedEntity.relationships\n      );\n    }\n    \n    return updatedEntity;\n  }\n  \n  /**\n   * Removes an entity\n   * @param id Entity ID\n   */\n  public removeEntity(id: EntityId): boolean {\n    const entity = this.getEntity(id);\n    if (!entity) return false;\n    \n    // Clean up all bidirectional relationships before deleting\n    this.cleanupEntityRelationships(entity);\n    \n    return this.stateManager.removeEntity(id);\n  }\n  \n  /**\n   * Creates a relationship between entities\n   * @param sourceId Source entity ID\n   * @param type Relationship type\n   * @param targetId Target entity ID\n   */\n  public createRelationship(\n    sourceId: EntityId,\n    type: string,\n    targetId: EntityId\n  ): boolean {\n    // Check if entities exist\n    const source = this.getEntity(sourceId);\n    const target = this.getEntity(targetId);\n    if (!source || !target) return false;\n    \n    // Create the relationship\n    const success = this.stateManager.createRelationship(sourceId, type, targetId);\n    \n    // If successful and relationship is bidirectional, create the inverse\n    if (success) {\n      const config = this.config.relationshipConfigs?.[type];\n      if (config?.bidirectional && config.inverseType) {\n        this.stateManager.createRelationship(targetId, config.inverseType, sourceId);\n      }\n    }\n    \n    return success;\n  }\n  \n  /**\n   * Removes a relationship between entities\n   * @param sourceId Source entity ID\n   * @param type Relationship type\n   * @param targetId Target entity ID\n   */\n  public removeRelationship(\n    sourceId: EntityId,\n    type: string,\n    targetId: EntityId\n  ): boolean {\n    // Remove the relationship\n    const success = this.stateManager.removeRelationship(sourceId, type, targetId);\n    \n    // If successful and relationship is bidirectional, remove the inverse\n    if (success) {\n      const config = this.config.relationshipConfigs?.[type];\n      if (config?.bidirectional && config.inverseType) {\n        this.stateManager.removeRelationship(targetId, config.inverseType, sourceId);\n      }\n    }\n    \n    return success;\n  }\n  \n  /**\n   * Gets all entities of a specific type\n   * @param type Entity type\n   */\n  public getEntitiesByType(type: string): Entity[] {\n    const state = this.getState();\n    return Object.values(state.entities).filter(entity => entity.type === type);\n  }\n  \n  /**\n   * Gets entities related to a specific entity\n   * @param id Entity ID\n   * @param type Optional relationship type to filter by\n   */\n  public getRelatedEntities(id: EntityId, type?: string): Entity[] {\n    const entity = this.getEntity(id);\n    if (!entity) return [];\n    \n    const relatedIds: EntityId[] = [];\n    \n    if (type) {\n      // Get entities for a specific relationship type\n      const relationships = entity.relationships[type] || [];\n      relatedIds.push(...relationships);\n    } else {\n      // Get all related entities\n      Object.values(entity.relationships).forEach(ids => {\n        relatedIds.push(...ids);\n      });\n    }\n    \n    // Get the actual entity objects\n    return relatedIds\n      .map(relatedId => this.getEntity(relatedId))\n      .filter((e): e is Entity => e !== undefined);\n  }\n  \n  /**\n   * Validates attributes against attribute configurations\n   * @param type Entity type\n   * @param attributes Attributes to validate\n   */\n  private validateAttributes(type: string, attributes: Record<string, unknown>): void {\n    const configs = this.config.attributeConfigs?.[type];\n    if (!configs) return;\n    \n    // Check for required attributes\n    for (const [key, config] of Object.entries(configs)) {\n      if (config.required && !(key in attributes)) {\n        throw new Error(`Required attribute \"${key}\" missing for entity type \"${type}\"`);\n      }\n      \n      // Skip validation if attribute is not present\n      if (!(key in attributes)) continue;\n      \n      const value = attributes[key];\n      \n      // Type validation\n      if (config.type) {\n        const valueType = value === null ? 'null' : typeof value;\n        if (\n          (config.type === 'array' && !Array.isArray(value)) ||\n          (config.type !== 'array' && config.type !== valueType)\n        ) {\n          throw new Error(\n            `Attribute \"${key}\" for entity type \"${type}\" must be of type \"${config.type}\"`\n          );\n        }\n      }\n      \n      // Custom validation\n      if (config.validate && !config.validate(value as AttributeValue)) {\n        throw new Error(\n          `Attribute \"${key}\" for entity type \"${type}\" failed custom validation`\n        );\n      }\n    }\n  }\n  \n  /**\n   * Creates bidirectional relationships for a new entity\n   * @param entityId Entity ID\n   * @param relationships Relationships to create\n   */\n  private createBidirectionalRelationships(\n    entityId: EntityId,\n    relationships: Record<string, EntityId[]>\n  ): void {\n    for (const [type, targetIds] of Object.entries(relationships)) {\n      const config = this.config.relationshipConfigs?.[type];\n      \n      if (config?.bidirectional && config.inverseType) {\n        for (const targetId of targetIds) {\n          // Create inverse relationship\n          this.stateManager.createRelationship(\n            targetId,\n            config.inverseType,\n            entityId\n          );\n        }\n      }\n    }\n  }\n  \n  /**\n   * Updates bidirectional relationships when an entity is updated\n   * @param entityId Entity ID\n   * @param oldRelationships Old relationships\n   * @param newRelationships New relationships\n   */\n  private updateBidirectionalRelationships(\n    entityId: EntityId,\n    oldRelationships: Record<string, EntityId[]>,\n    newRelationships: Record<string, EntityId[]>\n  ): void {\n    // Process each relationship type\n    for (const [type, config] of Object.entries(this.config.relationshipConfigs || {})) {\n      if (!config.bidirectional || !config.inverseType) continue;\n      \n      const oldTargets = oldRelationships[type] || [];\n      const newTargets = newRelationships[type] || [];\n      \n      // Find targets to add and remove\n      const targetsToAdd = newTargets.filter(id => !oldTargets.includes(id));\n      const targetsToRemove = oldTargets.filter(id => !newTargets.includes(id));\n      \n      // Create new inverse relationships\n      for (const targetId of targetsToAdd) {\n        this.stateManager.createRelationship(\n          targetId,\n          config.inverseType,\n          entityId\n        );\n      }\n      \n      // Remove old inverse relationships\n      for (const targetId of targetsToRemove) {\n        this.stateManager.removeRelationship(\n          targetId,\n          config.inverseType,\n          entityId\n        );\n      }\n    }\n  }\n  \n  /**\n   * Cleans up an entity's relationships before removal\n   * @param entity Entity to clean up\n   */\n  private cleanupEntityRelationships(entity: Entity): void {\n    // For each relationship type\n    for (const [type, targetIds] of Object.entries(entity.relationships)) {\n      const config = this.config.relationshipConfigs?.[type];\n      \n      // If bidirectional, remove inverse relationships\n      if (config?.bidirectional && config.inverseType) {\n        for (const targetId of targetIds) {\n          this.stateManager.removeRelationship(\n            targetId,\n            config.inverseType,\n            entity.id\n          );\n        }\n      }\n    }\n  }\n  \n  /**\n   * Creates an entity with preset attributes\n   * @param templateName Template name\n   * @param overrides Optional attribute overrides\n   */\n  public createEntityFromTemplate(\n    templateName: string,\n    overrides: Partial<EntityCreationParams> = {}\n  ): Entity | undefined {\n    // This would be implemented to handle entity templates\n    // We could define common entity types (room, item, character) with preset attributes\n    \n    // For now, just return undefined as this is a placeholder\n    return undefined;\n  }\n}\n\n/**\n * Creates a new entity manager with the given state manager\n * @param stateManager State manager to use\n * @param config Configuration options\n */\nexport function createEntityManager(\n  stateManager: StateManager,\n  config?: Partial<EntityManagerConfig>\n): EntityManager {\n  return new EntityManager(stateManager, config);\n}\n```\n\nThis implementation enhances our entity management capabilities with:\n\n1. **Attribute Validation**: Ensures entity attributes conform to type and custom validations\n2. **Bidirectional Relationships**: Automatically maintains inverse relationships\n3. **Cleanup on Delete**: Removes all relationships when entities are deleted\n4. **Type-Based Queries**: Easily find entities by type\n5. **Related Entity Queries**: Get all entities related to a specific entity\n\nIt also provides a foundation for future extensions like:\n\n- Template-based entity creation\n- Complex entity queries\n- Hierarchical entity types\n- Entity events and hooks\n\nNow let's export this from the implementations index:\n\n```typescript\n// packages/core/src/world-model/implementations/index.ts\n\nexport * from './immutable-state';\nexport * from './entity-manager';\n```\n\nNext steps could include:\n\n1. Implementing a QueryEngine for more sophisticated entity searches\n2. Creating an EventEmitter for state change notifications\n3. Building a relationship manager with graph traversal capabilities\n4. Developing a serialization system for saving/loading world states\n\nWould you like to proceed with any of these components next?",
      "content": [
        {
          "start_timestamp": "2025-03-27T21:57:46.710579Z",
          "stop_timestamp": "2025-03-27T21:58:17.399142Z",
          "type": "text",
          "text": " Let's implement the EntityManager class to provide more sophisticated entity operations on top of our StateManager.\n\nThe EntityManager will enhance our entity management capabilities with features like entity templates, validation, and more efficient relationship handling. Here's the implementation:\n\n```typescript\n// packages/core/src/world-model/implementations/entity-manager.ts\n\nimport {\n  Entity,\n  EntityId,\n  EntityCreationParams,\n  EntityOperationOptions,\n  AttributeConfigMap,\n  AttributeValue,\n  RelationshipConfigMap,\n  RelationshipType,\n  WorldState\n} from '../types';\nimport { StateManager } from './immutable-state';\n\n/**\n * Configuration options for the EntityManager\n */\nexport interface EntityManagerConfig {\n  /**\n   * Map of entity types to attribute configurations\n   */\n  attributeConfigs?: Record<string, AttributeConfigMap>;\n  \n  /**\n   * Map of relationship types to relationship configurations\n   */\n  relationshipConfigs?: RelationshipConfigMap;\n  \n  /**\n   * Whether to validate entities on creation and update\n   */\n  validateEntities?: boolean;\n}\n\n/**\n * Default configuration for EntityManager\n */\nconst DEFAULT_CONFIG: EntityManagerConfig = {\n  attributeConfigs: {},\n  relationshipConfigs: {},\n  validateEntities: true\n};\n\n/**\n * Provides higher-level entity operations on top of the StateManager\n */\nexport class EntityManager {\n  private stateManager: StateManager;\n  private config: EntityManagerConfig;\n  \n  /**\n   * Creates a new EntityManager\n   * @param stateManager The state manager to use\n   * @param config Configuration options\n   */\n  constructor(stateManager: StateManager, config: Partial<EntityManagerConfig> = {}) {\n    this.stateManager = stateManager;\n    this.config = { ...DEFAULT_CONFIG, ...config };\n  }\n  \n  /**\n   * Gets the current world state\n   */\n  public getState(): WorldState {\n    return this.stateManager.getState();\n  }\n  \n  /**\n   * Gets an entity by ID\n   * @param id Entity ID\n   */\n  public getEntity(id: EntityId): Entity | undefined {\n    return this.stateManager.getEntity(id);\n  }\n  \n  /**\n   * Creates a new entity\n   * @param params Entity creation parameters\n   * @param options Optional creation options\n   */\n  public createEntity(\n    params: EntityCreationParams,\n    options: EntityOperationOptions = {}\n  ): Entity {\n    // Validate attributes if validation is enabled\n    if (this.config.validateEntities) {\n      this.validateAttributes(params.type, params.attributes || {});\n    }\n    \n    // Create the entity\n    const entity = this.stateManager.createEntity(params);\n    \n    // Create bidirectional relationships if configured\n    if (params.relationships) {\n      this.createBidirectionalRelationships(entity.id, params.relationships);\n    }\n    \n    return entity;\n  }\n  \n  /**\n   * Updates an existing entity\n   * @param id Entity ID\n   * @param updates Entity updates\n   * @param options Update options\n   */\n  public updateEntity(\n    id: EntityId,\n    updates: Partial<Entity>,\n    options: EntityOperationOptions = {}\n  ): Entity | undefined {\n    const existingEntity = this.getEntity(id);\n    if (!existingEntity) return undefined;\n    \n    // Validate attributes if validation is enabled\n    if (this.config.validateEntities && updates.attributes) {\n      this.validateAttributes(\n        updates.type || existingEntity.type,\n        updates.attributes\n      );\n    }\n    \n    // Update the entity\n    const updatedEntity = this.stateManager.updateEntity(id, updates, options);\n    \n    // Update bidirectional relationships if needed\n    if (updatedEntity && updates.relationships) {\n      this.updateBidirectionalRelationships(\n        id, \n        existingEntity.relationships, \n        updatedEntity.relationships\n      );\n    }\n    \n    return updatedEntity;\n  }\n  \n  /**\n   * Removes an entity\n   * @param id Entity ID\n   */\n  public removeEntity(id: EntityId): boolean {\n    const entity = this.getEntity(id);\n    if (!entity) return false;\n    \n    // Clean up all bidirectional relationships before deleting\n    this.cleanupEntityRelationships(entity);\n    \n    return this.stateManager.removeEntity(id);\n  }\n  \n  /**\n   * Creates a relationship between entities\n   * @param sourceId Source entity ID\n   * @param type Relationship type\n   * @param targetId Target entity ID\n   */\n  public createRelationship(\n    sourceId: EntityId,\n    type: string,\n    targetId: EntityId\n  ): boolean {\n    // Check if entities exist\n    const source = this.getEntity(sourceId);\n    const target = this.getEntity(targetId);\n    if (!source || !target) return false;\n    \n    // Create the relationship\n    const success = this.stateManager.createRelationship(sourceId, type, targetId);\n    \n    // If successful and relationship is bidirectional, create the inverse\n    if (success) {\n      const config = this.config.relationshipConfigs?.[type];\n      if (config?.bidirectional && config.inverseType) {\n        this.stateManager.createRelationship(targetId, config.inverseType, sourceId);\n      }\n    }\n    \n    return success;\n  }\n  \n  /**\n   * Removes a relationship between entities\n   * @param sourceId Source entity ID\n   * @param type Relationship type\n   * @param targetId Target entity ID\n   */\n  public removeRelationship(\n    sourceId: EntityId,\n    type: string,\n    targetId: EntityId\n  ): boolean {\n    // Remove the relationship\n    const success = this.stateManager.removeRelationship(sourceId, type, targetId);\n    \n    // If successful and relationship is bidirectional, remove the inverse\n    if (success) {\n      const config = this.config.relationshipConfigs?.[type];\n      if (config?.bidirectional && config.inverseType) {\n        this.stateManager.removeRelationship(targetId, config.inverseType, sourceId);\n      }\n    }\n    \n    return success;\n  }\n  \n  /**\n   * Gets all entities of a specific type\n   * @param type Entity type\n   */\n  public getEntitiesByType(type: string): Entity[] {\n    const state = this.getState();\n    return Object.values(state.entities).filter(entity => entity.type === type);\n  }\n  \n  /**\n   * Gets entities related to a specific entity\n   * @param id Entity ID\n   * @param type Optional relationship type to filter by\n   */\n  public getRelatedEntities(id: EntityId, type?: string): Entity[] {\n    const entity = this.getEntity(id);\n    if (!entity) return [];\n    \n    const relatedIds: EntityId[] = [];\n    \n    if (type) {\n      // Get entities for a specific relationship type\n      const relationships = entity.relationships[type] || [];\n      relatedIds.push(...relationships);\n    } else {\n      // Get all related entities\n      Object.values(entity.relationships).forEach(ids => {\n        relatedIds.push(...ids);\n      });\n    }\n    \n    // Get the actual entity objects\n    return relatedIds\n      .map(relatedId => this.getEntity(relatedId))\n      .filter((e): e is Entity => e !== undefined);\n  }\n  \n  /**\n   * Validates attributes against attribute configurations\n   * @param type Entity type\n   * @param attributes Attributes to validate\n   */\n  private validateAttributes(type: string, attributes: Record<string, unknown>): void {\n    const configs = this.config.attributeConfigs?.[type];\n    if (!configs) return;\n    \n    // Check for required attributes\n    for (const [key, config] of Object.entries(configs)) {\n      if (config.required && !(key in attributes)) {\n        throw new Error(`Required attribute \"${key}\" missing for entity type \"${type}\"`);\n      }\n      \n      // Skip validation if attribute is not present\n      if (!(key in attributes)) continue;\n      \n      const value = attributes[key];\n      \n      // Type validation\n      if (config.type) {\n        const valueType = value === null ? 'null' : typeof value;\n        if (\n          (config.type === 'array' && !Array.isArray(value)) ||\n          (config.type !== 'array' && config.type !== valueType)\n        ) {\n          throw new Error(\n            `Attribute \"${key}\" for entity type \"${type}\" must be of type \"${config.type}\"`\n          );\n        }\n      }\n      \n      // Custom validation\n      if (config.validate && !config.validate(value as AttributeValue)) {\n        throw new Error(\n          `Attribute \"${key}\" for entity type \"${type}\" failed custom validation`\n        );\n      }\n    }\n  }\n  \n  /**\n   * Creates bidirectional relationships for a new entity\n   * @param entityId Entity ID\n   * @param relationships Relationships to create\n   */\n  private createBidirectionalRelationships(\n    entityId: EntityId,\n    relationships: Record<string, EntityId[]>\n  ): void {\n    for (const [type, targetIds] of Object.entries(relationships)) {\n      const config = this.config.relationshipConfigs?.[type];\n      \n      if (config?.bidirectional && config.inverseType) {\n        for (const targetId of targetIds) {\n          // Create inverse relationship\n          this.stateManager.createRelationship(\n            targetId,\n            config.inverseType,\n            entityId\n          );\n        }\n      }\n    }\n  }\n  \n  /**\n   * Updates bidirectional relationships when an entity is updated\n   * @param entityId Entity ID\n   * @param oldRelationships Old relationships\n   * @param newRelationships New relationships\n   */\n  private updateBidirectionalRelationships(\n    entityId: EntityId,\n    oldRelationships: Record<string, EntityId[]>,\n    newRelationships: Record<string, EntityId[]>\n  ): void {\n    // Process each relationship type\n    for (const [type, config] of Object.entries(this.config.relationshipConfigs || {})) {\n      if (!config.bidirectional || !config.inverseType) continue;\n      \n      const oldTargets = oldRelationships[type] || [];\n      const newTargets = newRelationships[type] || [];\n      \n      // Find targets to add and remove\n      const targetsToAdd = newTargets.filter(id => !oldTargets.includes(id));\n      const targetsToRemove = oldTargets.filter(id => !newTargets.includes(id));\n      \n      // Create new inverse relationships\n      for (const targetId of targetsToAdd) {\n        this.stateManager.createRelationship(\n          targetId,\n          config.inverseType,\n          entityId\n        );\n      }\n      \n      // Remove old inverse relationships\n      for (const targetId of targetsToRemove) {\n        this.stateManager.removeRelationship(\n          targetId,\n          config.inverseType,\n          entityId\n        );\n      }\n    }\n  }\n  \n  /**\n   * Cleans up an entity's relationships before removal\n   * @param entity Entity to clean up\n   */\n  private cleanupEntityRelationships(entity: Entity): void {\n    // For each relationship type\n    for (const [type, targetIds] of Object.entries(entity.relationships)) {\n      const config = this.config.relationshipConfigs?.[type];\n      \n      // If bidirectional, remove inverse relationships\n      if (config?.bidirectional && config.inverseType) {\n        for (const targetId of targetIds) {\n          this.stateManager.removeRelationship(\n            targetId,\n            config.inverseType,\n            entity.id\n          );\n        }\n      }\n    }\n  }\n  \n  /**\n   * Creates an entity with preset attributes\n   * @param templateName Template name\n   * @param overrides Optional attribute overrides\n   */\n  public createEntityFromTemplate(\n    templateName: string,\n    overrides: Partial<EntityCreationParams> = {}\n  ): Entity | undefined {\n    // This would be implemented to handle entity templates\n    // We could define common entity types (room, item, character) with preset attributes\n    \n    // For now, just return undefined as this is a placeholder\n    return undefined;\n  }\n}\n\n/**\n * Creates a new entity manager with the given state manager\n * @param stateManager State manager to use\n * @param config Configuration options\n */\nexport function createEntityManager(\n  stateManager: StateManager,\n  config?: Partial<EntityManagerConfig>\n): EntityManager {\n  return new EntityManager(stateManager, config);\n}\n```\n\nThis implementation enhances our entity management capabilities with:\n\n1. **Attribute Validation**: Ensures entity attributes conform to type and custom validations\n2. **Bidirectional Relationships**: Automatically maintains inverse relationships\n3. **Cleanup on Delete**: Removes all relationships when entities are deleted\n4. **Type-Based Queries**: Easily find entities by type\n5. **Related Entity Queries**: Get all entities related to a specific entity\n\nIt also provides a foundation for future extensions like:\n\n- Template-based entity creation\n- Complex entity queries\n- Hierarchical entity types\n- Entity events and hooks\n\nNow let's export this from the implementations index:\n\n```typescript\n// packages/core/src/world-model/implementations/index.ts\n\nexport * from './immutable-state';\nexport * from './entity-manager';\n```\n\nNext steps could include:\n\n1. Implementing a QueryEngine for more sophisticated entity searches\n2. Creating an EventEmitter for state change notifications\n3. Building a relationship manager with graph traversal capabilities\n4. Developing a serialization system for saving/loading world states\n\nWould you like to proceed with any of these components next?",
          "citations": []
        }
      ],
      "sender": "assistant",
      "created_at": "2025-03-27T21:58:27.959840Z",
      "updated_at": "2025-03-27T21:58:27.959840Z",
      "attachments": [],
      "files": []
    },
    {
      "uuid": "4300f700-a4c6-4617-b804-882f97eb00d0",
      "text": "let's do QueryEngine now",
      "content": [
        {
          "start_timestamp": "2025-03-27T21:13:25.707822Z",
          "stop_timestamp": "2025-03-27T21:13:25.707822Z",
          "type": "text",
          "text": "let's do QueryEngine now",
          "citations": []
        }
      ],
      "sender": "human",
      "created_at": "2025-03-27T22:19:34.467845Z",
      "updated_at": "2025-03-27T22:19:34.467845Z",
      "attachments": [],
      "files": []
    },
    {
      "uuid": "6d215bf9-bfc3-4ab5-beec-554ed4d3da20",
      "text": " Let's implement the QueryEngine which will provide powerful and flexible ways to search for entities in our world state. This will be essential for efficiently finding objects, characters, locations, or any other entities based on various criteria.\n\n```typescript\n// packages/core/src/world-model/implementations/query-engine.ts\n\nimport {\n  Entity,\n  EntityId,\n  EntityQuery,\n  QueryOptions,\n  QueryResult,\n  AttributeValue,\n  WorldState\n} from '../types';\nimport { StateManager } from './immutable-state';\n\n/**\n * Provides advanced querying capabilities for entities in the world state\n */\nexport class QueryEngine {\n  private stateManager: StateManager;\n  \n  /**\n   * Creates a new QueryEngine\n   * @param stateManager The state manager to use\n   */\n  constructor(stateManager: StateManager) {\n    this.stateManager = stateManager;\n  }\n  \n  /**\n   * Finds entities matching the given query\n   * @param query Query criteria\n   * @param options Query options\n   */\n  public findEntities(query: EntityQuery, options: QueryOptions = {}): QueryResult {\n    const state = this.stateManager.getState();\n    const matchingEntities = this.executeQuery(query, state);\n    \n    // Apply sorting if requested\n    let sortedEntities = matchingEntities;\n    if (options.sortBy) {\n      sortedEntities = this.sortEntities(matchingEntities, options.sortBy, options.sortDirection);\n    }\n    \n    // Apply limit if requested\n    const limitedEntities = options.limit\n      ? sortedEntities.slice(0, options.limit)\n      : sortedEntities;\n    \n    return {\n      ids: limitedEntities.map(entity => entity.id),\n      entities: limitedEntities\n    };\n  }\n  \n  /**\n   * Finds a single entity matching the query\n   * @param query Query criteria\n   */\n  public findEntity(query: EntityQuery): Entity | undefined {\n    const result = this.findEntities(query, { limit: 1 });\n    return result.entities[0];\n  }\n  \n  /**\n   * Finds entities by their type\n   * @param type Entity type\n   * @param options Query options\n   */\n  public findByType(type: string, options: QueryOptions = {}): QueryResult {\n    return this.findEntities({ types: [type] }, options);\n  }\n  \n  /**\n   * Finds entities by attribute value\n   * @param attributeName Attribute name\n   * @param value Attribute value\n   * @param options Query options\n   */\n  public findByAttribute(\n    attributeName: string,\n    value: AttributeValue,\n    options: QueryOptions = {}\n  ): QueryResult {\n    return this.findEntities(\n      { attributes: { [attributeName]: value } },\n      options\n    );\n  }\n  \n  /**\n   * Finds entities related to a specific entity\n   * @param entityId Entity ID\n   * @param relationshipType Optional relationship type\n   * @param options Query options\n   */\n  public findRelatedEntities(\n    entityId: EntityId,\n    relationshipType?: string,\n    options: QueryOptions = {}\n  ): QueryResult {\n    const entity = this.stateManager.getEntity(entityId);\n    if (!entity) return { ids: [], entities: [] };\n    \n    let relatedIds: EntityId[] = [];\n    \n    if (relationshipType) {\n      // Get entities for a specific relationship type\n      relatedIds = entity.relationships[relationshipType] || [];\n    } else {\n      // Get all related entities\n      Object.values(entity.relationships).forEach(ids => {\n        relatedIds.push(...ids);\n      });\n      \n      // Remove duplicates\n      relatedIds = [...new Set(relatedIds)];\n    }\n    \n    // Get the actual entity objects\n    const entities = relatedIds\n      .map(id => this.stateManager.getEntity(id))\n      .filter((e): e is Entity => e !== undefined);\n    \n    // Apply sorting if requested\n    let sortedEntities = entities;\n    if (options.sortBy) {\n      sortedEntities = this.sortEntities(entities, options.sortBy, options.sortDirection);\n    }\n    \n    // Apply limit if requested\n    const limitedEntities = options.limit\n      ? sortedEntities.slice(0, options.limit)\n      : sortedEntities;\n    \n    return {\n      ids: limitedEntities.map(entity => entity.id),\n      entities: limitedEntities\n    };\n  }\n  \n  /**\n   * Finds entities that have a relationship with a specific entity\n   * @param entityId Target entity ID\n   * @param relationshipType Optional relationship type\n   * @param options Query options\n   */\n  public findEntitiesRelatingTo(\n    entityId: EntityId,\n    relationshipType?: string,\n    options: QueryOptions = {}\n  ): QueryResult {\n    const state = this.stateManager.getState();\n    \n    const matchingEntities = Object.values(state.entities).filter(entity => {\n      if (relationshipType) {\n        // Check specific relationship type\n        const relatedIds = entity.relationships[relationshipType] || [];\n        return relatedIds.includes(entityId);\n      } else {\n        // Check all relationship types\n        return Object.values(entity.relationships).some(relatedIds => \n          relatedIds.includes(entityId)\n        );\n      }\n    });\n    \n    // Apply sorting if requested\n    let sortedEntities = matchingEntities;\n    if (options.sortBy) {\n      sortedEntities = this.sortEntities(matchingEntities, options.sortBy, options.sortDirection);\n    }\n    \n    // Apply limit if requested\n    const limitedEntities = options.limit\n      ? sortedEntities.slice(0, options.limit)\n      : sortedEntities;\n    \n    return {\n      ids: limitedEntities.map(entity => entity.id),\n      entities: limitedEntities\n    };\n  }\n  \n  /**\n   * Executes a query against the world state\n   * @param query Query criteria\n   * @param state World state\n   */\n  private executeQuery(query: EntityQuery, state: WorldState): Entity[] {\n    const entities = Object.values(state.entities);\n    \n    return entities.filter(entity => {\n      // Use provided predicate if available\n      if (query.predicate) {\n        return query.predicate(entity);\n      }\n      \n      const typeMatch = this.matchType(entity, query.types);\n      const attributeMatch = this.matchAttributes(entity, query.attributes);\n      const relationshipMatch = this.matchRelationships(entity, query.relationships);\n      \n      // If matchAny is true, we need at least one match\n      if (query.matchAny) {\n        return (\n          (query.types !== undefined && typeMatch) ||\n          (query.attributes !== undefined && attributeMatch) ||\n          (query.relationships !== undefined && relationshipMatch)\n        );\n      }\n      \n      // Otherwise, all specified criteria must match\n      return (\n        (query.types === undefined || typeMatch) &&\n        (query.attributes === undefined || attributeMatch) &&\n        (query.relationships === undefined || relationshipMatch)\n      );\n    });\n  }\n  \n  /**\n   * Checks if an entity's type matches any in the provided list\n   */\n  private matchType(entity: Entity, types?: string[]): boolean {\n    if (!types || types.length === 0) return true;\n    return types.includes(entity.type);\n  }\n  \n  /**\n   * Checks if an entity's attributes match the query attributes\n   */\n  private matchAttributes(entity: Entity, attributes?: Record<string, AttributeValue>): boolean {\n    if (!attributes) return true;\n    \n    return Object.entries(attributes).every(([key, value]) => {\n      // Check if the attribute exists and matches the value\n      return (\n        key in entity.attributes &&\n        this.areValuesEqual(entity.attributes[key], value)\n      );\n    });\n  }\n  \n  /**\n   * Checks if an entity's relationships match the query relationships\n   */\n  private matchRelationships(\n    entity: Entity,\n    relationships?: Record<string, EntityId[]>\n  ): boolean {\n    if (!relationships) return true;\n    \n    return Object.entries(relationships).every(([type, targetIds]) => {\n      // Check if the relationship type exists\n      const entityRelationships = entity.relationships[type] || [];\n      \n      // Check if all target IDs are present\n      return targetIds.every(id => entityRelationships.includes(id));\n    });\n  }\n  \n  /**\n   * Compares two values for equality\n   */\n  private areValuesEqual(a: unknown, b: unknown): boolean {\n    // If we're dealing with arrays, check if they have the same values\n    if (Array.isArray(a) && Array.isArray(b)) {\n      return (\n        a.length === b.length &&\n        a.every((val, i) => this.areValuesEqual(val, b[i]))\n      );\n    }\n    \n    // If we're dealing with objects, check if they have the same keys/values\n    if (\n      typeof a === 'object' && a !== null &&\n      typeof b === 'object' && b !== null\n    ) {\n      const keysA = Object.keys(a);\n      const keysB = Object.keys(b);\n      \n      return (\n        keysA.length === keysB.length &&\n        keysA.every(key => \n          keysB.includes(key) && \n          this.areValuesEqual((a as Record<string, unknown>)[key], (b as Record<string, unknown>)[key])\n        )\n      );\n    }\n    \n    // Otherwise, do a strict equality check\n    return a === b;\n  }\n  \n  /**\n   * Sorts entities by an attribute\n   */\n  private sortEntities(\n    entities: Entity[],\n    attributeName: string,\n    direction: 'asc' | 'desc' = 'asc'\n  ): Entity[] {\n    return [...entities].sort((a, b) => {\n      const valueA = this.getNestedAttributeValue(a, attributeName);\n      const valueB = this.getNestedAttributeValue(b, attributeName);\n      \n      // Handle different types\n      if (typeof valueA === 'number' && typeof valueB === 'number') {\n        return direction === 'asc' ? valueA - valueB : valueB - valueA;\n      }\n      \n      if (typeof valueA === 'string' && typeof valueB === 'string') {\n        return direction === 'asc'\n          ? valueA.localeCompare(valueB)\n          : valueB.localeCompare(valueA);\n      }\n      \n      if (typeof valueA === 'boolean' && typeof valueB === 'boolean') {\n        const numA = valueA ? 1 : 0;\n        const numB = valueB ? 1 : 0;\n        return direction === 'asc' ? numA - numB : numB - numA;\n      }\n      \n      // If values aren't comparable, preserve original order\n      return 0;\n    });\n  }\n  \n  /**\n   * Gets a nested attribute value using dot notation\n   * e.g., getNestedAttributeValue(entity, 'stats.strength')\n   */\n  private getNestedAttributeValue(entity: Entity, path: string): unknown {\n    // Special handling for built-in entity properties\n    if (path === 'id') return entity.id;\n    if (path === 'type') return entity.type;\n    \n    // Handle nested attributes with dot notation\n    const parts = path.split('.');\n    let value: unknown = entity.attributes;\n    \n    for (const part of parts) {\n      if (value === null || value === undefined) return undefined;\n      \n      if (typeof value === 'object') {\n        value = (value as Record<string, unknown>)[part];\n      } else {\n        return undefined;\n      }\n    }\n    \n    return value;\n  }\n  \n  /**\n   * Finds entities with a spatial relationship to the given entity\n   * @param entityId Central entity ID\n   * @param relationshipType Spatial relationship type (e.g., 'contains', 'adjacentTo')\n   * @param maxDistance Maximum traversal distance\n   */\n  public findNearbyEntities(\n    entityId: EntityId,\n    relationshipType: string,\n    maxDistance: number = 1\n  ): Map<EntityId, number> {\n    const entity = this.stateManager.getEntity(entityId);\n    if (!entity) return new Map();\n    \n    // Map of entity IDs to their distance from the source\n    const distances = new Map<EntityId, number>();\n    distances.set(entityId, 0);\n    \n    // Queue for breadth-first search\n    const queue: Array<[EntityId, number]> = [[entityId, 0]];\n    \n    while (queue.length > 0) {\n      const [currentId, distance] = queue.shift()!;\n      \n      // Stop if we've reached the maximum distance\n      if (distance >= maxDistance) continue;\n      \n      const currentEntity = this.stateManager.getEntity(currentId);\n      if (!currentEntity) continue;\n      \n      // Get related entities of the specified relationship type\n      const relatedIds = currentEntity.relationships[relationshipType] || [];\n      \n      for (const relatedId of relatedIds) {\n        // Skip if we've already visited this entity at a shorter or equal distance\n        if (distances.has(relatedId) && distances.get(relatedId)! <= distance + 1) {\n          continue;\n        }\n        \n        // Record the distance\n        distances.set(relatedId, distance + 1);\n        \n        // Add to queue for further exploration\n        queue.push([relatedId, distance + 1]);\n      }\n    }\n    \n    // Remove the source entity from the results\n    distances.delete(entityId);\n    \n    return distances;\n  }\n  \n  /**\n   * Performs a graph traversal to find a path between entities\n   * @param startId Starting entity ID\n   * @param endId Ending entity ID\n   * @param relationshipType Relationship type to follow\n   */\n  public findPath(\n    startId: EntityId,\n    endId: EntityId,\n    relationshipType: string\n  ): EntityId[] {\n    const start = this.stateManager.getEntity(startId);\n    const end = this.stateManager.getEntity(endId);\n    if (!start || !end) return [];\n    \n    // Map to track which entity we came from\n    const cameFrom = new Map<EntityId, EntityId>();\n    \n    // Queue for breadth-first search\n    const queue: EntityId[] = [startId];\n    \n    // Continue until we find the end or exhaust all possibilities\n    while (queue.length > 0) {\n      const currentId = queue.shift()!;\n      \n      // If we've reached the end, reconstruct and return the path\n      if (currentId === endId) {\n        return this.reconstructPath(cameFrom, startId, endId);\n      }\n      \n      const currentEntity = this.stateManager.getEntity(currentId);\n      if (!currentEntity) continue;\n      \n      // Get related entities of the specified relationship type\n      const relatedIds = currentEntity.relationships[relationshipType] || [];\n      \n      for (const relatedId of relatedIds) {\n        // Skip if we've already visited this entity\n        if (cameFrom.has(relatedId)) continue;\n        \n        // Record where we came from\n        cameFrom.set(relatedId, currentId);\n        \n        // Add to queue for further exploration\n        queue.push(relatedId);\n      }\n    }\n    \n    // No path found\n    return [];\n  }\n  \n  /**\n   * Reconstructs a path from the cameFrom map\n   */\n  private reconstructPath(\n    cameFrom: Map<EntityId, EntityId>,\n    startId: EntityId,\n    endId: EntityId\n  ): EntityId[] {\n    const path: EntityId[] = [endId];\n    let current = endId;\n    \n    while (current !== startId) {\n      const previous = cameFrom.get(current);\n      if (!previous) break; // No path exists\n      \n      path.unshift(previous);\n      current = previous;\n    }\n    \n    return path;\n  }\n}\n\n/**\n * Creates a new query engine with the given state manager\n * @param stateManager State manager to use\n */\nexport function createQueryEngine(stateManager: StateManager): QueryEngine {\n  return new QueryEngine(stateManager);\n}\n```\n\nNow let's update the implementations index to include our new QueryEngine:\n\n```typescript\n// packages/core/src/world-model/implementations/index.ts\n\nexport * from './immutable-state';\nexport * from './entity-manager';\nexport * from './query-engine';\n```\n\nThis QueryEngine implementation provides powerful capabilities for finding entities:\n\n1. **Flexible Query API**: Search by type, attributes, relationships, or custom predicates\n2. **Relationship Traversal**: Find entities related to others by specific relationship types\n3. **Path Finding**: Calculate paths between entities through relationship networks\n4. **Spatial Queries**: Find nearby entities within a certain distance\n5. **Sorting & Limiting**: Control the order and number of results\n\nThese capabilities will be essential for implementing IF-specific features such as:\n\n- Finding all items in a location\n- Determining which exits are available from a room\n- Resolving ambiguous references like \"take key\" when multiple keys exist\n- Calculating paths for character movement\n- Determining line-of-sight and visibility\n\nNext steps could include:\n\n1. Creating an EventEmitter for state change notifications\n2. Developing a serialization system for saving/loading world states\n3. Building the parser layer that will interpret natural language commands\n4. Starting the IF-specific layer with Room, Item, and Character implementations\n\nWould you like to proceed with any of these components next?",
      "content": [
        {
          "start_timestamp": "2025-03-27T22:19:36.159143Z",
          "stop_timestamp": "2025-03-27T22:20:17.061950Z",
          "type": "text",
          "text": " Let's implement the QueryEngine which will provide powerful and flexible ways to search for entities in our world state. This will be essential for efficiently finding objects, characters, locations, or any other entities based on various criteria.\n\n```typescript\n// packages/core/src/world-model/implementations/query-engine.ts\n\nimport {\n  Entity,\n  EntityId,\n  EntityQuery,\n  QueryOptions,\n  QueryResult,\n  AttributeValue,\n  WorldState\n} from '../types';\nimport { StateManager } from './immutable-state';\n\n/**\n * Provides advanced querying capabilities for entities in the world state\n */\nexport class QueryEngine {\n  private stateManager: StateManager;\n  \n  /**\n   * Creates a new QueryEngine\n   * @param stateManager The state manager to use\n   */\n  constructor(stateManager: StateManager) {\n    this.stateManager = stateManager;\n  }\n  \n  /**\n   * Finds entities matching the given query\n   * @param query Query criteria\n   * @param options Query options\n   */\n  public findEntities(query: EntityQuery, options: QueryOptions = {}): QueryResult {\n    const state = this.stateManager.getState();\n    const matchingEntities = this.executeQuery(query, state);\n    \n    // Apply sorting if requested\n    let sortedEntities = matchingEntities;\n    if (options.sortBy) {\n      sortedEntities = this.sortEntities(matchingEntities, options.sortBy, options.sortDirection);\n    }\n    \n    // Apply limit if requested\n    const limitedEntities = options.limit\n      ? sortedEntities.slice(0, options.limit)\n      : sortedEntities;\n    \n    return {\n      ids: limitedEntities.map(entity => entity.id),\n      entities: limitedEntities\n    };\n  }\n  \n  /**\n   * Finds a single entity matching the query\n   * @param query Query criteria\n   */\n  public findEntity(query: EntityQuery): Entity | undefined {\n    const result = this.findEntities(query, { limit: 1 });\n    return result.entities[0];\n  }\n  \n  /**\n   * Finds entities by their type\n   * @param type Entity type\n   * @param options Query options\n   */\n  public findByType(type: string, options: QueryOptions = {}): QueryResult {\n    return this.findEntities({ types: [type] }, options);\n  }\n  \n  /**\n   * Finds entities by attribute value\n   * @param attributeName Attribute name\n   * @param value Attribute value\n   * @param options Query options\n   */\n  public findByAttribute(\n    attributeName: string,\n    value: AttributeValue,\n    options: QueryOptions = {}\n  ): QueryResult {\n    return this.findEntities(\n      { attributes: { [attributeName]: value } },\n      options\n    );\n  }\n  \n  /**\n   * Finds entities related to a specific entity\n   * @param entityId Entity ID\n   * @param relationshipType Optional relationship type\n   * @param options Query options\n   */\n  public findRelatedEntities(\n    entityId: EntityId,\n    relationshipType?: string,\n    options: QueryOptions = {}\n  ): QueryResult {\n    const entity = this.stateManager.getEntity(entityId);\n    if (!entity) return { ids: [], entities: [] };\n    \n    let relatedIds: EntityId[] = [];\n    \n    if (relationshipType) {\n      // Get entities for a specific relationship type\n      relatedIds = entity.relationships[relationshipType] || [];\n    } else {\n      // Get all related entities\n      Object.values(entity.relationships).forEach(ids => {\n        relatedIds.push(...ids);\n      });\n      \n      // Remove duplicates\n      relatedIds = [...new Set(relatedIds)];\n    }\n    \n    // Get the actual entity objects\n    const entities = relatedIds\n      .map(id => this.stateManager.getEntity(id))\n      .filter((e): e is Entity => e !== undefined);\n    \n    // Apply sorting if requested\n    let sortedEntities = entities;\n    if (options.sortBy) {\n      sortedEntities = this.sortEntities(entities, options.sortBy, options.sortDirection);\n    }\n    \n    // Apply limit if requested\n    const limitedEntities = options.limit\n      ? sortedEntities.slice(0, options.limit)\n      : sortedEntities;\n    \n    return {\n      ids: limitedEntities.map(entity => entity.id),\n      entities: limitedEntities\n    };\n  }\n  \n  /**\n   * Finds entities that have a relationship with a specific entity\n   * @param entityId Target entity ID\n   * @param relationshipType Optional relationship type\n   * @param options Query options\n   */\n  public findEntitiesRelatingTo(\n    entityId: EntityId,\n    relationshipType?: string,\n    options: QueryOptions = {}\n  ): QueryResult {\n    const state = this.stateManager.getState();\n    \n    const matchingEntities = Object.values(state.entities).filter(entity => {\n      if (relationshipType) {\n        // Check specific relationship type\n        const relatedIds = entity.relationships[relationshipType] || [];\n        return relatedIds.includes(entityId);\n      } else {\n        // Check all relationship types\n        return Object.values(entity.relationships).some(relatedIds => \n          relatedIds.includes(entityId)\n        );\n      }\n    });\n    \n    // Apply sorting if requested\n    let sortedEntities = matchingEntities;\n    if (options.sortBy) {\n      sortedEntities = this.sortEntities(matchingEntities, options.sortBy, options.sortDirection);\n    }\n    \n    // Apply limit if requested\n    const limitedEntities = options.limit\n      ? sortedEntities.slice(0, options.limit)\n      : sortedEntities;\n    \n    return {\n      ids: limitedEntities.map(entity => entity.id),\n      entities: limitedEntities\n    };\n  }\n  \n  /**\n   * Executes a query against the world state\n   * @param query Query criteria\n   * @param state World state\n   */\n  private executeQuery(query: EntityQuery, state: WorldState): Entity[] {\n    const entities = Object.values(state.entities);\n    \n    return entities.filter(entity => {\n      // Use provided predicate if available\n      if (query.predicate) {\n        return query.predicate(entity);\n      }\n      \n      const typeMatch = this.matchType(entity, query.types);\n      const attributeMatch = this.matchAttributes(entity, query.attributes);\n      const relationshipMatch = this.matchRelationships(entity, query.relationships);\n      \n      // If matchAny is true, we need at least one match\n      if (query.matchAny) {\n        return (\n          (query.types !== undefined && typeMatch) ||\n          (query.attributes !== undefined && attributeMatch) ||\n          (query.relationships !== undefined && relationshipMatch)\n        );\n      }\n      \n      // Otherwise, all specified criteria must match\n      return (\n        (query.types === undefined || typeMatch) &&\n        (query.attributes === undefined || attributeMatch) &&\n        (query.relationships === undefined || relationshipMatch)\n      );\n    });\n  }\n  \n  /**\n   * Checks if an entity's type matches any in the provided list\n   */\n  private matchType(entity: Entity, types?: string[]): boolean {\n    if (!types || types.length === 0) return true;\n    return types.includes(entity.type);\n  }\n  \n  /**\n   * Checks if an entity's attributes match the query attributes\n   */\n  private matchAttributes(entity: Entity, attributes?: Record<string, AttributeValue>): boolean {\n    if (!attributes) return true;\n    \n    return Object.entries(attributes).every(([key, value]) => {\n      // Check if the attribute exists and matches the value\n      return (\n        key in entity.attributes &&\n        this.areValuesEqual(entity.attributes[key], value)\n      );\n    });\n  }\n  \n  /**\n   * Checks if an entity's relationships match the query relationships\n   */\n  private matchRelationships(\n    entity: Entity,\n    relationships?: Record<string, EntityId[]>\n  ): boolean {\n    if (!relationships) return true;\n    \n    return Object.entries(relationships).every(([type, targetIds]) => {\n      // Check if the relationship type exists\n      const entityRelationships = entity.relationships[type] || [];\n      \n      // Check if all target IDs are present\n      return targetIds.every(id => entityRelationships.includes(id));\n    });\n  }\n  \n  /**\n   * Compares two values for equality\n   */\n  private areValuesEqual(a: unknown, b: unknown): boolean {\n    // If we're dealing with arrays, check if they have the same values\n    if (Array.isArray(a) && Array.isArray(b)) {\n      return (\n        a.length === b.length &&\n        a.every((val, i) => this.areValuesEqual(val, b[i]))\n      );\n    }\n    \n    // If we're dealing with objects, check if they have the same keys/values\n    if (\n      typeof a === 'object' && a !== null &&\n      typeof b === 'object' && b !== null\n    ) {\n      const keysA = Object.keys(a);\n      const keysB = Object.keys(b);\n      \n      return (\n        keysA.length === keysB.length &&\n        keysA.every(key => \n          keysB.includes(key) && \n          this.areValuesEqual((a as Record<string, unknown>)[key], (b as Record<string, unknown>)[key])\n        )\n      );\n    }\n    \n    // Otherwise, do a strict equality check\n    return a === b;\n  }\n  \n  /**\n   * Sorts entities by an attribute\n   */\n  private sortEntities(\n    entities: Entity[],\n    attributeName: string,\n    direction: 'asc' | 'desc' = 'asc'\n  ): Entity[] {\n    return [...entities].sort((a, b) => {\n      const valueA = this.getNestedAttributeValue(a, attributeName);\n      const valueB = this.getNestedAttributeValue(b, attributeName);\n      \n      // Handle different types\n      if (typeof valueA === 'number' && typeof valueB === 'number') {\n        return direction === 'asc' ? valueA - valueB : valueB - valueA;\n      }\n      \n      if (typeof valueA === 'string' && typeof valueB === 'string') {\n        return direction === 'asc'\n          ? valueA.localeCompare(valueB)\n          : valueB.localeCompare(valueA);\n      }\n      \n      if (typeof valueA === 'boolean' && typeof valueB === 'boolean') {\n        const numA = valueA ? 1 : 0;\n        const numB = valueB ? 1 : 0;\n        return direction === 'asc' ? numA - numB : numB - numA;\n      }\n      \n      // If values aren't comparable, preserve original order\n      return 0;\n    });\n  }\n  \n  /**\n   * Gets a nested attribute value using dot notation\n   * e.g., getNestedAttributeValue(entity, 'stats.strength')\n   */\n  private getNestedAttributeValue(entity: Entity, path: string): unknown {\n    // Special handling for built-in entity properties\n    if (path === 'id') return entity.id;\n    if (path === 'type') return entity.type;\n    \n    // Handle nested attributes with dot notation\n    const parts = path.split('.');\n    let value: unknown = entity.attributes;\n    \n    for (const part of parts) {\n      if (value === null || value === undefined) return undefined;\n      \n      if (typeof value === 'object') {\n        value = (value as Record<string, unknown>)[part];\n      } else {\n        return undefined;\n      }\n    }\n    \n    return value;\n  }\n  \n  /**\n   * Finds entities with a spatial relationship to the given entity\n   * @param entityId Central entity ID\n   * @param relationshipType Spatial relationship type (e.g., 'contains', 'adjacentTo')\n   * @param maxDistance Maximum traversal distance\n   */\n  public findNearbyEntities(\n    entityId: EntityId,\n    relationshipType: string,\n    maxDistance: number = 1\n  ): Map<EntityId, number> {\n    const entity = this.stateManager.getEntity(entityId);\n    if (!entity) return new Map();\n    \n    // Map of entity IDs to their distance from the source\n    const distances = new Map<EntityId, number>();\n    distances.set(entityId, 0);\n    \n    // Queue for breadth-first search\n    const queue: Array<[EntityId, number]> = [[entityId, 0]];\n    \n    while (queue.length > 0) {\n      const [currentId, distance] = queue.shift()!;\n      \n      // Stop if we've reached the maximum distance\n      if (distance >= maxDistance) continue;\n      \n      const currentEntity = this.stateManager.getEntity(currentId);\n      if (!currentEntity) continue;\n      \n      // Get related entities of the specified relationship type\n      const relatedIds = currentEntity.relationships[relationshipType] || [];\n      \n      for (const relatedId of relatedIds) {\n        // Skip if we've already visited this entity at a shorter or equal distance\n        if (distances.has(relatedId) && distances.get(relatedId)! <= distance + 1) {\n          continue;\n        }\n        \n        // Record the distance\n        distances.set(relatedId, distance + 1);\n        \n        // Add to queue for further exploration\n        queue.push([relatedId, distance + 1]);\n      }\n    }\n    \n    // Remove the source entity from the results\n    distances.delete(entityId);\n    \n    return distances;\n  }\n  \n  /**\n   * Performs a graph traversal to find a path between entities\n   * @param startId Starting entity ID\n   * @param endId Ending entity ID\n   * @param relationshipType Relationship type to follow\n   */\n  public findPath(\n    startId: EntityId,\n    endId: EntityId,\n    relationshipType: string\n  ): EntityId[] {\n    const start = this.stateManager.getEntity(startId);\n    const end = this.stateManager.getEntity(endId);\n    if (!start || !end) return [];\n    \n    // Map to track which entity we came from\n    const cameFrom = new Map<EntityId, EntityId>();\n    \n    // Queue for breadth-first search\n    const queue: EntityId[] = [startId];\n    \n    // Continue until we find the end or exhaust all possibilities\n    while (queue.length > 0) {\n      const currentId = queue.shift()!;\n      \n      // If we've reached the end, reconstruct and return the path\n      if (currentId === endId) {\n        return this.reconstructPath(cameFrom, startId, endId);\n      }\n      \n      const currentEntity = this.stateManager.getEntity(currentId);\n      if (!currentEntity) continue;\n      \n      // Get related entities of the specified relationship type\n      const relatedIds = currentEntity.relationships[relationshipType] || [];\n      \n      for (const relatedId of relatedIds) {\n        // Skip if we've already visited this entity\n        if (cameFrom.has(relatedId)) continue;\n        \n        // Record where we came from\n        cameFrom.set(relatedId, currentId);\n        \n        // Add to queue for further exploration\n        queue.push(relatedId);\n      }\n    }\n    \n    // No path found\n    return [];\n  }\n  \n  /**\n   * Reconstructs a path from the cameFrom map\n   */\n  private reconstructPath(\n    cameFrom: Map<EntityId, EntityId>,\n    startId: EntityId,\n    endId: EntityId\n  ): EntityId[] {\n    const path: EntityId[] = [endId];\n    let current = endId;\n    \n    while (current !== startId) {\n      const previous = cameFrom.get(current);\n      if (!previous) break; // No path exists\n      \n      path.unshift(previous);\n      current = previous;\n    }\n    \n    return path;\n  }\n}\n\n/**\n * Creates a new query engine with the given state manager\n * @param stateManager State manager to use\n */\nexport function createQueryEngine(stateManager: StateManager): QueryEngine {\n  return new QueryEngine(stateManager);\n}\n```\n\nNow let's update the implementations index to include our new QueryEngine:\n\n```typescript\n// packages/core/src/world-model/implementations/index.ts\n\nexport * from './immutable-state';\nexport * from './entity-manager';\nexport * from './query-engine';\n```\n\nThis QueryEngine implementation provides powerful capabilities for finding entities:\n\n1. **Flexible Query API**: Search by type, attributes, relationships, or custom predicates\n2. **Relationship Traversal**: Find entities related to others by specific relationship types\n3. **Path Finding**: Calculate paths between entities through relationship networks\n4. **Spatial Queries**: Find nearby entities within a certain distance\n5. **Sorting & Limiting**: Control the order and number of results\n\nThese capabilities will be essential for implementing IF-specific features such as:\n\n- Finding all items in a location\n- Determining which exits are available from a room\n- Resolving ambiguous references like \"take key\" when multiple keys exist\n- Calculating paths for character movement\n- Determining line-of-sight and visibility\n\nNext steps could include:\n\n1. Creating an EventEmitter for state change notifications\n2. Developing a serialization system for saving/loading world states\n3. Building the parser layer that will interpret natural language commands\n4. Starting the IF-specific layer with Room, Item, and Character implementations\n\nWould you like to proceed with any of these components next?",
          "citations": []
        }
      ],
      "sender": "assistant",
      "created_at": "2025-03-27T22:20:34.766602Z",
      "updated_at": "2025-03-27T22:20:34.766602Z",
      "attachments": [],
      "files": []
    },
    {
      "uuid": "167141ef-91ab-4472-b586-a4c726d39757",
      "text": "now let's do EventEmitter",
      "content": [
        {
          "start_timestamp": "2025-03-27T21:14:12.234867Z",
          "stop_timestamp": "2025-03-27T21:14:12.234867Z",
          "type": "text",
          "text": "now let's do EventEmitter",
          "citations": []
        }
      ],
      "sender": "human",
      "created_at": "2025-03-27T22:21:27.062122Z",
      "updated_at": "2025-03-27T22:21:27.062122Z",
      "attachments": [],
      "files": []
    },
    {
      "uuid": "765aa76a-20d0-4508-82c8-e19f6d4d37ad",
      "text": " Let's implement the EventEmitter to provide a flexible notification system for state changes and other important events in our world model. This will allow different parts of the system to react to changes without tight coupling.\n\n```typescript\n// packages/core/src/world-model/implementations/event-emitter.ts\n\n/**\n * Event type for type safety in event handling\n */\nexport type EventType = string;\n\n/**\n * Base event interface\n */\nexport interface Event {\n  /**\n   * Type of the event\n   */\n  type: EventType;\n  \n  /**\n   * Timestamp when the event was created\n   */\n  timestamp: number;\n  \n  /**\n   * Optional additional data\n   */\n  payload?: unknown;\n}\n\n/**\n * Event listener function signature\n */\nexport type EventListener<T = unknown> = (event: Event & { payload?: T }) => void;\n\n/**\n * Configuration options for listener registration\n */\nexport interface ListenerOptions {\n  /**\n   * Whether to only call the listener once\n   */\n  once?: boolean;\n  \n  /**\n   * Priority of the listener (higher numbers execute first)\n   */\n  priority?: number;\n}\n\n/**\n * Internal representation of a listener registration\n */\ninterface ListenerRegistration {\n  /**\n   * The event listener function\n   */\n  listener: EventListener;\n  \n  /**\n   * Whether this is a one-time listener\n   */\n  once: boolean;\n  \n  /**\n   * Execution priority (higher executes first)\n   */\n  priority: number;\n}\n\n/**\n * Default standard events that the system emits\n */\nexport enum StandardEvents {\n  STATE_UPDATED = 'state:updated',\n  ENTITY_CREATED = 'entity:created',\n  ENTITY_UPDATED = 'entity:updated',\n  ENTITY_REMOVED = 'entity:removed',\n  RELATIONSHIP_CREATED = 'relationship:created',\n  RELATIONSHIP_REMOVED = 'relationship:removed',\n  ERROR = 'system:error',\n}\n\n/**\n * Standard event payloads\n */\nexport interface StandardEventPayloads {\n  [StandardEvents.STATE_UPDATED]: {\n    previousState: unknown;\n    currentState: unknown;\n    description?: string;\n  };\n  [StandardEvents.ENTITY_CREATED]: {\n    entityId: string;\n    entityType: string;\n  };\n  [StandardEvents.ENTITY_UPDATED]: {\n    entityId: string;\n    entityType: string;\n    changes: unknown;\n  };\n  [StandardEvents.ENTITY_REMOVED]: {\n    entityId: string;\n    entityType: string;\n  };\n  [StandardEvents.RELATIONSHIP_CREATED]: {\n    sourceId: string;\n    type: string;\n    targetId: string;\n  };\n  [StandardEvents.RELATIONSHIP_REMOVED]: {\n    sourceId: string;\n    type: string;\n    targetId: string;\n  };\n  [StandardEvents.ERROR]: {\n    message: string;\n    code?: string;\n    details?: unknown;\n  };\n}\n\n/**\n * Typed event creation helper\n */\nexport function createEvent<T extends EventType>(\n  type: T,\n  payload?: T extends keyof StandardEventPayloads ? StandardEventPayloads[T] : unknown\n): Event {\n  return {\n    type,\n    timestamp: Date.now(),\n    payload\n  };\n}\n\n/**\n * Manages event listeners and dispatches events\n */\nexport class EventEmitter {\n  /**\n   * Map of event types to listener registrations\n   */\n  private listeners: Map<EventType, ListenerRegistration[]> = new Map();\n  \n  /**\n   * Wildcard listeners that receive all events\n   */\n  private wildcardListeners: ListenerRegistration[] = [];\n  \n  /**\n   * Registers an event listener\n   * @param type Event type to listen for, or '*' for all events\n   * @param listener Function to call when the event occurs\n   * @param options Listener options\n   */\n  public on<T extends EventType>(\n    type: T | '*',\n    listener: EventListener<T extends keyof StandardEventPayloads ? StandardEventPayloads[T] : unknown>,\n    options: ListenerOptions = {}\n  ): () => void {\n    const registration: ListenerRegistration = {\n      listener: listener as EventListener,\n      once: options.once || false,\n      priority: options.priority || 0\n    };\n    \n    if (type === '*') {\n      this.wildcardListeners.push(registration);\n      // Sort by priority (highest first)\n      this.wildcardListeners.sort((a, b) => b.priority - a.priority);\n    } else {\n      if (!this.listeners.has(type)) {\n        this.listeners.set(type, []);\n      }\n      \n      this.listeners.get(type)!.push(registration);\n      // Sort by priority (highest first)\n      this.listeners.get(type)!.sort((a, b) => b.priority - a.priority);\n    }\n    \n    // Return a function to remove this listener\n    return () => {\n      this.off(type, listener);\n    };\n  }\n  \n  /**\n   * Registers a one-time event listener\n   * @param type Event type to listen for, or '*' for all events\n   * @param listener Function to call when the event occurs\n   * @param priority Listener priority\n   */\n  public once<T extends EventType>(\n    type: T | '*',\n    listener: EventListener<T extends keyof StandardEventPayloads ? StandardEventPayloads[T] : unknown>,\n    priority: number = 0\n  ): () => void {\n    return this.on(type, listener, { once: true, priority });\n  }\n  \n  /**\n   * Removes an event listener\n   * @param type Event type the listener was registered for\n   * @param listener The listener function to remove\n   */\n  public off<T = unknown>(type: EventType | '*', listener: EventListener<T>): void {\n    if (type === '*') {\n      this.wildcardListeners = this.wildcardListeners.filter(\n        reg => reg.listener !== listener\n      );\n    } else if (this.listeners.has(type)) {\n      this.listeners.set(\n        type,\n        this.listeners.get(type)!.filter(reg => reg.listener !== listener)\n      );\n    }\n  }\n  \n  /**\n   * Emits an event to all registered listeners\n   * @param event The event to emit\n   */\n  public emit(event: Event): void {\n    // Make a copy of the event to prevent modification\n    const eventCopy = { ...event, timestamp: event.timestamp || Date.now() };\n    \n    // Call type-specific listeners\n    if (this.listeners.has(event.type)) {\n      const typeListeners = [...this.listeners.get(event.type)!];\n      \n      for (const registration of typeListeners) {\n        try {\n          registration.listener(eventCopy);\n        } catch (error) {\n          console.error(`Error in event listener for ${event.type}:`, error);\n        }\n        \n        // Remove one-time listeners\n        if (registration.once) {\n          this.off(event.type, registration.listener);\n        }\n      }\n    }\n    \n    // Call wildcard listeners\n    const wildcardListenersCopy = [...this.wildcardListeners];\n    \n    for (const registration of wildcardListenersCopy) {\n      try {\n        registration.listener(eventCopy);\n      } catch (error) {\n        console.error(`Error in wildcard event listener for ${event.type}:`, error);\n      }\n      \n      // Remove one-time listeners\n      if (registration.once) {\n        this.off('*', registration.listener);\n      }\n    }\n  }\n  \n  /**\n   * Helper method to emit a typed event\n   * @param type Event type\n   * @param payload Event payload\n   */\n  public emitTyped<T extends EventType>(\n    type: T,\n    payload?: T extends keyof StandardEventPayloads ? StandardEventPayloads[T] : unknown\n  ): void {\n    this.emit(createEvent(type, payload));\n  }\n  \n  /**\n   * Removes all listeners for a specific event type\n   * @param type Event type to clear listeners for, or undefined for all events\n   */\n  public removeAllListeners(type?: EventType): void {\n    if (type) {\n      if (type === '*') {\n        this.wildcardListeners = [];\n      } else {\n        this.listeners.delete(type);\n      }\n    } else {\n      this.listeners.clear();\n      this.wildcardListeners = [];\n    }\n  }\n  \n  /**\n   * Gets the number of listeners for a specific event type\n   * @param type Event type to count listeners for, or '*' for wildcard listeners\n   */\n  public listenerCount(type: EventType | '*'): number {\n    if (type === '*') {\n      return this.wildcardListeners.length;\n    }\n    \n    return this.listeners.has(type) ? this.listeners.get(type)!.length : 0;\n  }\n}\n\n/**\n * Creates a new EventEmitter\n */\nexport function createEventEmitter(): EventEmitter {\n  return new EventEmitter();\n}\n```\n\nNext, let's integrate the EventEmitter with the StateManager so it emits events on state changes:\n\n```typescript\n// Let's modify the immutable-state.ts file to include event emission\n\n// At the top of the file, add the import:\nimport { EventEmitter, StandardEvents, createEventEmitter } from './event-emitter';\n\n// Then in the StateManager class, add event emission capabilities:\n\nexport class StateManager {\n  private currentState: WorldState;\n  private history: StateHistoryEntry[] = [];\n  private config: StateManagerConfig;\n  private undoStack: StateHistoryEntry[] = [];\n  private redoStack: StateHistoryEntry[] = [];\n  private eventEmitter: EventEmitter;\n\n  constructor(initialState?: WorldState, config: Partial<StateManagerConfig> = {}) {\n    this.config = { ...DEFAULT_CONFIG, ...config };\n    this.currentState = initialState || this.createInitialState();\n    this.eventEmitter = createEventEmitter();\n    this.addToHistory(this.currentState, 'Initial state');\n  }\n  \n  // Add method to get the event emitter\n  public getEventEmitter(): EventEmitter {\n    return this.eventEmitter;\n  }\n  \n  // Then modify updateState to emit events:\n  public updateState(transformer: StateTransformer, description?: string): WorldState {\n    const previousState = this.currentState;\n    const nextState = transformer(this.currentState);\n    \n    // Only update if something changed\n    if (nextState !== this.currentState) {\n      // Update metadata\n      const updatedState = {\n        ...nextState,\n        meta: {\n          ...nextState.meta,\n          timestamp: Date.now(),\n          turnNumber: this.currentState.meta.turnNumber + 1\n        }\n      };\n\n      this.currentState = updatedState;\n      \n      // Add to history if tracking all changes or if description provided\n      if (this.config.trackAllChanges || description) {\n        this.addToHistory(updatedState, description);\n      }\n      \n      // Clear redo stack since we've made a new change\n      this.redoStack = [];\n      \n      // Emit state updated event\n      this.eventEmitter.emitTyped(StandardEvents.STATE_UPDATED, {\n        previousState,\n        currentState: this.currentState,\n        description\n      });\n    }\n    \n    return this.currentState;\n  }\n  \n  // Similarly, modify createEntity to emit events:\n  public createEntity(params: EntityCreationParams, description?: string): Entity {\n    const id = this.generateId();\n    \n    const entity: Entity = {\n      id,\n      type: params.type,\n      attributes: params.attributes || {},\n      relationships: params.relationships || {}\n    };\n\n    this.updateState(state => ({\n      ...state,\n      entities: {\n        ...state.entities,\n        [id]: entity\n      }\n    }), description || `Created entity: ${entity.type} (${id})`);\n    \n    // Emit entity created event\n    this.eventEmitter.emitTyped(StandardEvents.ENTITY_CREATED, {\n      entityId: id,\n      entityType: entity.type\n    });\n\n    return entity;\n  }\n  \n  // And update the other entity operations (updateEntity, removeEntity, etc.) to emit appropriate events\n}\n```\n\nNow let's update the implementations index to include our EventEmitter:\n\n```typescript\n// packages/core/src/world-model/implementations/index.ts\n\nexport * from './immutable-state';\nexport * from './entity-manager';\nexport * from './query-engine';\nexport * from './event-emitter';\n```\n\nThis EventEmitter implementation provides:\n\n1. **Type-Safe Events**: Strongly typed event payloads using TypeScript generics\n2. **Priority-Based Execution**: Control the order in which listeners execute\n3. **Wildcard Listeners**: Listen to all events with a single handler\n4. **One-Time Listeners**: Automatically removed after first execution\n5. **Error Handling**: Prevents one bad listener from breaking the entire system\n\nThese capabilities enable important features like:\n\n- Decoupled system components that react to state changes\n- Extensions that can hook into the system without modifying core code\n- Logging and debugging tools that monitor all state changes\n- UI components that automatically update when relevant entities change\n- Game rules that trigger on specific world state conditions\n\nNext steps could include:\n\n1. Implementing a serialization system for saving/loading world states\n2. Building the parser layer for natural language input\n3. Creating the IF-specific entity types (Room, Item, Character, etc.)\n4. Developing command handlers for standard IF actions\n\nWould you like to proceed with any of these components next?",
      "content": [
        {
          "start_timestamp": "2025-03-27T22:21:27.817211Z",
          "stop_timestamp": "2025-03-27T22:22:00.488921Z",
          "type": "text",
          "text": " Let's implement the EventEmitter to provide a flexible notification system for state changes and other important events in our world model. This will allow different parts of the system to react to changes without tight coupling.\n\n```typescript\n// packages/core/src/world-model/implementations/event-emitter.ts\n\n/**\n * Event type for type safety in event handling\n */\nexport type EventType = string;\n\n/**\n * Base event interface\n */\nexport interface Event {\n  /**\n   * Type of the event\n   */\n  type: EventType;\n  \n  /**\n   * Timestamp when the event was created\n   */\n  timestamp: number;\n  \n  /**\n   * Optional additional data\n   */\n  payload?: unknown;\n}\n\n/**\n * Event listener function signature\n */\nexport type EventListener<T = unknown> = (event: Event & { payload?: T }) => void;\n\n/**\n * Configuration options for listener registration\n */\nexport interface ListenerOptions {\n  /**\n   * Whether to only call the listener once\n   */\n  once?: boolean;\n  \n  /**\n   * Priority of the listener (higher numbers execute first)\n   */\n  priority?: number;\n}\n\n/**\n * Internal representation of a listener registration\n */\ninterface ListenerRegistration {\n  /**\n   * The event listener function\n   */\n  listener: EventListener;\n  \n  /**\n   * Whether this is a one-time listener\n   */\n  once: boolean;\n  \n  /**\n   * Execution priority (higher executes first)\n   */\n  priority: number;\n}\n\n/**\n * Default standard events that the system emits\n */\nexport enum StandardEvents {\n  STATE_UPDATED = 'state:updated',\n  ENTITY_CREATED = 'entity:created',\n  ENTITY_UPDATED = 'entity:updated',\n  ENTITY_REMOVED = 'entity:removed',\n  RELATIONSHIP_CREATED = 'relationship:created',\n  RELATIONSHIP_REMOVED = 'relationship:removed',\n  ERROR = 'system:error',\n}\n\n/**\n * Standard event payloads\n */\nexport interface StandardEventPayloads {\n  [StandardEvents.STATE_UPDATED]: {\n    previousState: unknown;\n    currentState: unknown;\n    description?: string;\n  };\n  [StandardEvents.ENTITY_CREATED]: {\n    entityId: string;\n    entityType: string;\n  };\n  [StandardEvents.ENTITY_UPDATED]: {\n    entityId: string;\n    entityType: string;\n    changes: unknown;\n  };\n  [StandardEvents.ENTITY_REMOVED]: {\n    entityId: string;\n    entityType: string;\n  };\n  [StandardEvents.RELATIONSHIP_CREATED]: {\n    sourceId: string;\n    type: string;\n    targetId: string;\n  };\n  [StandardEvents.RELATIONSHIP_REMOVED]: {\n    sourceId: string;\n    type: string;\n    targetId: string;\n  };\n  [StandardEvents.ERROR]: {\n    message: string;\n    code?: string;\n    details?: unknown;\n  };\n}\n\n/**\n * Typed event creation helper\n */\nexport function createEvent<T extends EventType>(\n  type: T,\n  payload?: T extends keyof StandardEventPayloads ? StandardEventPayloads[T] : unknown\n): Event {\n  return {\n    type,\n    timestamp: Date.now(),\n    payload\n  };\n}\n\n/**\n * Manages event listeners and dispatches events\n */\nexport class EventEmitter {\n  /**\n   * Map of event types to listener registrations\n   */\n  private listeners: Map<EventType, ListenerRegistration[]> = new Map();\n  \n  /**\n   * Wildcard listeners that receive all events\n   */\n  private wildcardListeners: ListenerRegistration[] = [];\n  \n  /**\n   * Registers an event listener\n   * @param type Event type to listen for, or '*' for all events\n   * @param listener Function to call when the event occurs\n   * @param options Listener options\n   */\n  public on<T extends EventType>(\n    type: T | '*',\n    listener: EventListener<T extends keyof StandardEventPayloads ? StandardEventPayloads[T] : unknown>,\n    options: ListenerOptions = {}\n  ): () => void {\n    const registration: ListenerRegistration = {\n      listener: listener as EventListener,\n      once: options.once || false,\n      priority: options.priority || 0\n    };\n    \n    if (type === '*') {\n      this.wildcardListeners.push(registration);\n      // Sort by priority (highest first)\n      this.wildcardListeners.sort((a, b) => b.priority - a.priority);\n    } else {\n      if (!this.listeners.has(type)) {\n        this.listeners.set(type, []);\n      }\n      \n      this.listeners.get(type)!.push(registration);\n      // Sort by priority (highest first)\n      this.listeners.get(type)!.sort((a, b) => b.priority - a.priority);\n    }\n    \n    // Return a function to remove this listener\n    return () => {\n      this.off(type, listener);\n    };\n  }\n  \n  /**\n   * Registers a one-time event listener\n   * @param type Event type to listen for, or '*' for all events\n   * @param listener Function to call when the event occurs\n   * @param priority Listener priority\n   */\n  public once<T extends EventType>(\n    type: T | '*',\n    listener: EventListener<T extends keyof StandardEventPayloads ? StandardEventPayloads[T] : unknown>,\n    priority: number = 0\n  ): () => void {\n    return this.on(type, listener, { once: true, priority });\n  }\n  \n  /**\n   * Removes an event listener\n   * @param type Event type the listener was registered for\n   * @param listener The listener function to remove\n   */\n  public off<T = unknown>(type: EventType | '*', listener: EventListener<T>): void {\n    if (type === '*') {\n      this.wildcardListeners = this.wildcardListeners.filter(\n        reg => reg.listener !== listener\n      );\n    } else if (this.listeners.has(type)) {\n      this.listeners.set(\n        type,\n        this.listeners.get(type)!.filter(reg => reg.listener !== listener)\n      );\n    }\n  }\n  \n  /**\n   * Emits an event to all registered listeners\n   * @param event The event to emit\n   */\n  public emit(event: Event): void {\n    // Make a copy of the event to prevent modification\n    const eventCopy = { ...event, timestamp: event.timestamp || Date.now() };\n    \n    // Call type-specific listeners\n    if (this.listeners.has(event.type)) {\n      const typeListeners = [...this.listeners.get(event.type)!];\n      \n      for (const registration of typeListeners) {\n        try {\n          registration.listener(eventCopy);\n        } catch (error) {\n          console.error(`Error in event listener for ${event.type}:`, error);\n        }\n        \n        // Remove one-time listeners\n        if (registration.once) {\n          this.off(event.type, registration.listener);\n        }\n      }\n    }\n    \n    // Call wildcard listeners\n    const wildcardListenersCopy = [...this.wildcardListeners];\n    \n    for (const registration of wildcardListenersCopy) {\n      try {\n        registration.listener(eventCopy);\n      } catch (error) {\n        console.error(`Error in wildcard event listener for ${event.type}:`, error);\n      }\n      \n      // Remove one-time listeners\n      if (registration.once) {\n        this.off('*', registration.listener);\n      }\n    }\n  }\n  \n  /**\n   * Helper method to emit a typed event\n   * @param type Event type\n   * @param payload Event payload\n   */\n  public emitTyped<T extends EventType>(\n    type: T,\n    payload?: T extends keyof StandardEventPayloads ? StandardEventPayloads[T] : unknown\n  ): void {\n    this.emit(createEvent(type, payload));\n  }\n  \n  /**\n   * Removes all listeners for a specific event type\n   * @param type Event type to clear listeners for, or undefined for all events\n   */\n  public removeAllListeners(type?: EventType): void {\n    if (type) {\n      if (type === '*') {\n        this.wildcardListeners = [];\n      } else {\n        this.listeners.delete(type);\n      }\n    } else {\n      this.listeners.clear();\n      this.wildcardListeners = [];\n    }\n  }\n  \n  /**\n   * Gets the number of listeners for a specific event type\n   * @param type Event type to count listeners for, or '*' for wildcard listeners\n   */\n  public listenerCount(type: EventType | '*'): number {\n    if (type === '*') {\n      return this.wildcardListeners.length;\n    }\n    \n    return this.listeners.has(type) ? this.listeners.get(type)!.length : 0;\n  }\n}\n\n/**\n * Creates a new EventEmitter\n */\nexport function createEventEmitter(): EventEmitter {\n  return new EventEmitter();\n}\n```\n\nNext, let's integrate the EventEmitter with the StateManager so it emits events on state changes:\n\n```typescript\n// Let's modify the immutable-state.ts file to include event emission\n\n// At the top of the file, add the import:\nimport { EventEmitter, StandardEvents, createEventEmitter } from './event-emitter';\n\n// Then in the StateManager class, add event emission capabilities:\n\nexport class StateManager {\n  private currentState: WorldState;\n  private history: StateHistoryEntry[] = [];\n  private config: StateManagerConfig;\n  private undoStack: StateHistoryEntry[] = [];\n  private redoStack: StateHistoryEntry[] = [];\n  private eventEmitter: EventEmitter;\n\n  constructor(initialState?: WorldState, config: Partial<StateManagerConfig> = {}) {\n    this.config = { ...DEFAULT_CONFIG, ...config };\n    this.currentState = initialState || this.createInitialState();\n    this.eventEmitter = createEventEmitter();\n    this.addToHistory(this.currentState, 'Initial state');\n  }\n  \n  // Add method to get the event emitter\n  public getEventEmitter(): EventEmitter {\n    return this.eventEmitter;\n  }\n  \n  // Then modify updateState to emit events:\n  public updateState(transformer: StateTransformer, description?: string): WorldState {\n    const previousState = this.currentState;\n    const nextState = transformer(this.currentState);\n    \n    // Only update if something changed\n    if (nextState !== this.currentState) {\n      // Update metadata\n      const updatedState = {\n        ...nextState,\n        meta: {\n          ...nextState.meta,\n          timestamp: Date.now(),\n          turnNumber: this.currentState.meta.turnNumber + 1\n        }\n      };\n\n      this.currentState = updatedState;\n      \n      // Add to history if tracking all changes or if description provided\n      if (this.config.trackAllChanges || description) {\n        this.addToHistory(updatedState, description);\n      }\n      \n      // Clear redo stack since we've made a new change\n      this.redoStack = [];\n      \n      // Emit state updated event\n      this.eventEmitter.emitTyped(StandardEvents.STATE_UPDATED, {\n        previousState,\n        currentState: this.currentState,\n        description\n      });\n    }\n    \n    return this.currentState;\n  }\n  \n  // Similarly, modify createEntity to emit events:\n  public createEntity(params: EntityCreationParams, description?: string): Entity {\n    const id = this.generateId();\n    \n    const entity: Entity = {\n      id,\n      type: params.type,\n      attributes: params.attributes || {},\n      relationships: params.relationships || {}\n    };\n\n    this.updateState(state => ({\n      ...state,\n      entities: {\n        ...state.entities,\n        [id]: entity\n      }\n    }), description || `Created entity: ${entity.type} (${id})`);\n    \n    // Emit entity created event\n    this.eventEmitter.emitTyped(StandardEvents.ENTITY_CREATED, {\n      entityId: id,\n      entityType: entity.type\n    });\n\n    return entity;\n  }\n  \n  // And update the other entity operations (updateEntity, removeEntity, etc.) to emit appropriate events\n}\n```\n\nNow let's update the implementations index to include our EventEmitter:\n\n```typescript\n// packages/core/src/world-model/implementations/index.ts\n\nexport * from './immutable-state';\nexport * from './entity-manager';\nexport * from './query-engine';\nexport * from './event-emitter';\n```\n\nThis EventEmitter implementation provides:\n\n1. **Type-Safe Events**: Strongly typed event payloads using TypeScript generics\n2. **Priority-Based Execution**: Control the order in which listeners execute\n3. **Wildcard Listeners**: Listen to all events with a single handler\n4. **One-Time Listeners**: Automatically removed after first execution\n5. **Error Handling**: Prevents one bad listener from breaking the entire system\n\nThese capabilities enable important features like:\n\n- Decoupled system components that react to state changes\n- Extensions that can hook into the system without modifying core code\n- Logging and debugging tools that monitor all state changes\n- UI components that automatically update when relevant entities change\n- Game rules that trigger on specific world state conditions\n\nNext steps could include:\n\n1. Implementing a serialization system for saving/loading world states\n2. Building the parser layer for natural language input\n3. Creating the IF-specific entity types (Room, Item, Character, etc.)\n4. Developing command handlers for standard IF actions\n\nWould you like to proceed with any of these components next?",
          "citations": []
        }
      ],
      "sender": "assistant",
      "created_at": "2025-03-27T22:22:12.152990Z",
      "updated_at": "2025-03-27T22:22:12.152990Z",
      "attachments": [],
      "files": []
    },
    {
      "uuid": "ac69678f-8e84-469d-8d22-ec134a250e6d",
      "text": "provide code for: other entity operations (updateEntity, removeEntity, etc.) to emit appropriate events",
      "content": [
        {
          "start_timestamp": "2025-03-27T21:14:07.071555Z",
          "stop_timestamp": "2025-03-27T21:14:07.071555Z",
          "type": "text",
          "text": "provide code for: other entity operations (updateEntity, removeEntity, etc.) to emit appropriate events",
          "citations": []
        }
      ],
      "sender": "human",
      "created_at": "2025-03-27T22:28:10.209616Z",
      "updated_at": "2025-03-27T22:28:10.209616Z",
      "attachments": [],
      "files": []
    },
    {
      "uuid": "8bbc88cc-fb9c-44c4-af65-d684417a2408",
      "text": " Let's update the other entity operations in the StateManager class to emit appropriate events. Here's the code for the modified methods:\n\n```typescript\n// packages/core/src/world-model/implementations/immutable-state.ts\n\n// ... existing code ...\n\n/**\n * Updates an existing entity\n * @param id Entity ID to update\n * @param updates Partial entity updates\n * @param options Update options\n * @param description Description for history\n */\npublic updateEntity(\n  id: EntityId, \n  updates: Partial<Entity>, \n  options: EntityOperationOptions = {},\n  description?: string\n): Entity | undefined {\n  const existingEntity = this.getEntity(id);\n  if (!existingEntity) return undefined;\n\n  this.updateState(state => {\n    const updatedEntity = this.mergeEntity(existingEntity, updates, options);\n    \n    return {\n      ...state,\n      entities: {\n        ...state.entities,\n        [id]: updatedEntity\n      }\n    };\n  }, description || `Updated entity: ${existingEntity.type} (${id})`);\n\n  // Emit entity updated event\n  this.eventEmitter.emitTyped(StandardEvents.ENTITY_UPDATED, {\n    entityId: id,\n    entityType: existingEntity.type,\n    changes: updates\n  });\n\n  return this.getEntity(id);\n}\n\n/**\n * Removes an entity from the world state\n * @param id Entity ID to remove\n * @param description Description for history\n */\npublic removeEntity(id: EntityId, description?: string): boolean {\n  const existingEntity = this.getEntity(id);\n  if (!existingEntity) return false;\n\n  // Store entity type for event emission\n  const entityType = existingEntity.type;\n\n  this.updateState(state => {\n    const { [id]: _, ...remainingEntities } = state.entities;\n    \n    return {\n      ...state,\n      entities: remainingEntities\n    };\n  }, description || `Removed entity: ${existingEntity.type} (${id})`);\n\n  // Emit entity removed event\n  this.eventEmitter.emitTyped(StandardEvents.ENTITY_REMOVED, {\n    entityId: id,\n    entityType: entityType\n  });\n\n  return true;\n}\n\n/**\n * Creates a relationship between two entities\n * @param sourceId Source entity ID\n * @param type Relationship type\n * @param targetId Target entity ID\n * @param description Description for history\n */\npublic createRelationship(\n  sourceId: EntityId,\n  type: string,\n  targetId: EntityId,\n  description?: string\n): boolean {\n  const source = this.getEntity(sourceId);\n  const target = this.getEntity(targetId);\n  \n  if (!source || !target) return false;\n\n  const existingRelationships = source.relationships[type] || [];\n  \n  // Skip if relationship already exists\n  if (existingRelationships.includes(targetId)) {\n    return true; // Already exists, so technically \"successful\"\n  }\n\n  this.updateState(state => {\n    return {\n      ...state,\n      entities: {\n        ...state.entities,\n        [sourceId]: {\n          ...source,\n          relationships: {\n            ...source.relationships,\n            [type]: [...existingRelationships, targetId]\n          }\n        }\n      }\n    };\n  }, description || `Created relationship: ${sourceId} -[${type}]-> ${targetId}`);\n\n  // Emit relationship created event\n  this.eventEmitter.emitTyped(StandardEvents.RELATIONSHIP_CREATED, {\n    sourceId,\n    type,\n    targetId\n  });\n\n  return true;\n}\n\n/**\n * Removes a relationship between two entities\n * @param sourceId Source entity ID\n * @param type Relationship type\n * @param targetId Target entity ID\n * @param description Description for history\n */\npublic removeRelationship(\n  sourceId: EntityId,\n  type: string,\n  targetId: EntityId,\n  description?: string\n): boolean {\n  const source = this.getEntity(sourceId);\n  \n  if (!source) return false;\n  \n  const existingRelationships = source.relationships[type] || [];\n  \n  // Skip if relationship doesn't exist\n  if (!existingRelationships.includes(targetId)) {\n    return false;\n  }\n\n  this.updateState(state => {\n    return {\n      ...state,\n      entities: {\n        ...state.entities,\n        [sourceId]: {\n          ...source,\n          relationships: {\n            ...source.relationships,\n            [type]: existingRelationships.filter(id => id !== targetId)\n          }\n        }\n      }\n    };\n  }, description || `Removed relationship: ${sourceId} -[${type}]-> ${targetId}`);\n\n  // Emit relationship removed event\n  this.eventEmitter.emitTyped(StandardEvents.RELATIONSHIP_REMOVED, {\n    sourceId,\n    type,\n    targetId\n  });\n\n  return true;\n}\n\n/**\n * Updates the world state in response to the undo operation\n * @returns The previous state or undefined if no previous state\n */\npublic undo(): WorldState | undefined {\n  if (!this.config.enableUndo || this.undoStack.length <= 1) {\n    return undefined;\n  }\n\n  // Store current state for event emission\n  const previousState = this.currentState;\n\n  // Pop the current state off the undo stack\n  const current = this.undoStack.pop()!;\n  \n  // Add to redo stack\n  this.redoStack.push(current);\n  \n  // Get the previous state\n  const previous = this.undoStack[this.undoStack.length - 1];\n  \n  // Set as current state\n  this.currentState = previous.state;\n  \n  // Emit state updated event for undo\n  this.eventEmitter.emitTyped(StandardEvents.STATE_UPDATED, {\n    previousState,\n    currentState: this.currentState,\n    description: 'Undo operation'\n  });\n  \n  return this.currentState;\n}\n\n/**\n * Updates the world state in response to the redo operation\n * @returns The redone state or undefined if no state to redo\n */\npublic redo(): WorldState | undefined {\n  if (!this.config.enableUndo || this.redoStack.length === 0) {\n    return undefined;\n  }\n\n  // Store current state for event emission\n  const previousState = this.currentState;\n\n  // Pop the most recent state off the redo stack\n  const next = this.redoStack.pop()!;\n  \n  // Add to undo stack\n  this.undoStack.push(next);\n  \n  // Set as current state\n  this.currentState = next.state;\n  \n  // Emit state updated event for redo\n  this.eventEmitter.emitTyped(StandardEvents.STATE_UPDATED, {\n    previousState,\n    currentState: this.currentState,\n    description: 'Redo operation'\n  });\n  \n  return this.currentState;\n}\n```\n\nThese updates ensure that appropriate events are emitted whenever entity operations occur, allowing other parts of the system to react to these changes. The event payloads include relevant information about what changed, making it easy for listeners to determine if they need to take action.\n\nNow let's also make sure the EntityManager forwards these events when it performs operations. We'll need to modify it to access the EventEmitter from the StateManager:\n\n```typescript\n// packages/core/src/world-model/implementations/entity-manager.ts\n\n// ... existing code ...\n\nexport class EntityManager {\n  private stateManager: StateManager;\n  private config: EntityManagerConfig;\n  private eventEmitter: EventEmitter;\n  \n  constructor(stateManager: StateManager, config: Partial<EntityManagerConfig> = {}) {\n    this.stateManager = stateManager;\n    this.config = { ...DEFAULT_CONFIG, ...config };\n    this.eventEmitter = stateManager.getEventEmitter();\n  }\n  \n  // ... existing methods ...\n  \n  /**\n   * Gets the event emitter for this entity manager\n   */\n  public getEventEmitter(): EventEmitter {\n    return this.eventEmitter;\n  }\n  \n  // No need to modify most methods as they use stateManager methods \n  // which already emit events\n  \n  /**\n   * Cleans up an entity's relationships before removal\n   * This needs special handling to ensure relationship removal events are emitted\n   */\n  private cleanupEntityRelationships(entity: Entity): void {\n    // For each relationship type\n    for (const [type, targetIds] of Object.entries(entity.relationships)) {\n      const config = this.config.relationshipConfigs?.[type];\n      \n      // If bidirectional, remove inverse relationships\n      if (config?.bidirectional && config.inverseType) {\n        for (const targetId of targetIds) {\n          // We use removeRelationship instead of directly accessing stateManager\n          // to ensure events are emitted properly\n          this.removeRelationship(targetId, config.inverseType, entity.id);\n        }\n      }\n    }\n  }\n}\n```\n\nThese changes ensure that our EventEmitter is properly integrated with all entity operations, providing a consistent way for different parts of the system to react to state changes.",
      "content": [
        {
          "start_timestamp": "2025-03-27T22:28:11.052333Z",
          "stop_timestamp": "2025-03-27T22:28:32.530934Z",
          "type": "text",
          "text": " Let's update the other entity operations in the StateManager class to emit appropriate events. Here's the code for the modified methods:\n\n```typescript\n// packages/core/src/world-model/implementations/immutable-state.ts\n\n// ... existing code ...\n\n/**\n * Updates an existing entity\n * @param id Entity ID to update\n * @param updates Partial entity updates\n * @param options Update options\n * @param description Description for history\n */\npublic updateEntity(\n  id: EntityId, \n  updates: Partial<Entity>, \n  options: EntityOperationOptions = {},\n  description?: string\n): Entity | undefined {\n  const existingEntity = this.getEntity(id);\n  if (!existingEntity) return undefined;\n\n  this.updateState(state => {\n    const updatedEntity = this.mergeEntity(existingEntity, updates, options);\n    \n    return {\n      ...state,\n      entities: {\n        ...state.entities,\n        [id]: updatedEntity\n      }\n    };\n  }, description || `Updated entity: ${existingEntity.type} (${id})`);\n\n  // Emit entity updated event\n  this.eventEmitter.emitTyped(StandardEvents.ENTITY_UPDATED, {\n    entityId: id,\n    entityType: existingEntity.type,\n    changes: updates\n  });\n\n  return this.getEntity(id);\n}\n\n/**\n * Removes an entity from the world state\n * @param id Entity ID to remove\n * @param description Description for history\n */\npublic removeEntity(id: EntityId, description?: string): boolean {\n  const existingEntity = this.getEntity(id);\n  if (!existingEntity) return false;\n\n  // Store entity type for event emission\n  const entityType = existingEntity.type;\n\n  this.updateState(state => {\n    const { [id]: _, ...remainingEntities } = state.entities;\n    \n    return {\n      ...state,\n      entities: remainingEntities\n    };\n  }, description || `Removed entity: ${existingEntity.type} (${id})`);\n\n  // Emit entity removed event\n  this.eventEmitter.emitTyped(StandardEvents.ENTITY_REMOVED, {\n    entityId: id,\n    entityType: entityType\n  });\n\n  return true;\n}\n\n/**\n * Creates a relationship between two entities\n * @param sourceId Source entity ID\n * @param type Relationship type\n * @param targetId Target entity ID\n * @param description Description for history\n */\npublic createRelationship(\n  sourceId: EntityId,\n  type: string,\n  targetId: EntityId,\n  description?: string\n): boolean {\n  const source = this.getEntity(sourceId);\n  const target = this.getEntity(targetId);\n  \n  if (!source || !target) return false;\n\n  const existingRelationships = source.relationships[type] || [];\n  \n  // Skip if relationship already exists\n  if (existingRelationships.includes(targetId)) {\n    return true; // Already exists, so technically \"successful\"\n  }\n\n  this.updateState(state => {\n    return {\n      ...state,\n      entities: {\n        ...state.entities,\n        [sourceId]: {\n          ...source,\n          relationships: {\n            ...source.relationships,\n            [type]: [...existingRelationships, targetId]\n          }\n        }\n      }\n    };\n  }, description || `Created relationship: ${sourceId} -[${type}]-> ${targetId}`);\n\n  // Emit relationship created event\n  this.eventEmitter.emitTyped(StandardEvents.RELATIONSHIP_CREATED, {\n    sourceId,\n    type,\n    targetId\n  });\n\n  return true;\n}\n\n/**\n * Removes a relationship between two entities\n * @param sourceId Source entity ID\n * @param type Relationship type\n * @param targetId Target entity ID\n * @param description Description for history\n */\npublic removeRelationship(\n  sourceId: EntityId,\n  type: string,\n  targetId: EntityId,\n  description?: string\n): boolean {\n  const source = this.getEntity(sourceId);\n  \n  if (!source) return false;\n  \n  const existingRelationships = source.relationships[type] || [];\n  \n  // Skip if relationship doesn't exist\n  if (!existingRelationships.includes(targetId)) {\n    return false;\n  }\n\n  this.updateState(state => {\n    return {\n      ...state,\n      entities: {\n        ...state.entities,\n        [sourceId]: {\n          ...source,\n          relationships: {\n            ...source.relationships,\n            [type]: existingRelationships.filter(id => id !== targetId)\n          }\n        }\n      }\n    };\n  }, description || `Removed relationship: ${sourceId} -[${type}]-> ${targetId}`);\n\n  // Emit relationship removed event\n  this.eventEmitter.emitTyped(StandardEvents.RELATIONSHIP_REMOVED, {\n    sourceId,\n    type,\n    targetId\n  });\n\n  return true;\n}\n\n/**\n * Updates the world state in response to the undo operation\n * @returns The previous state or undefined if no previous state\n */\npublic undo(): WorldState | undefined {\n  if (!this.config.enableUndo || this.undoStack.length <= 1) {\n    return undefined;\n  }\n\n  // Store current state for event emission\n  const previousState = this.currentState;\n\n  // Pop the current state off the undo stack\n  const current = this.undoStack.pop()!;\n  \n  // Add to redo stack\n  this.redoStack.push(current);\n  \n  // Get the previous state\n  const previous = this.undoStack[this.undoStack.length - 1];\n  \n  // Set as current state\n  this.currentState = previous.state;\n  \n  // Emit state updated event for undo\n  this.eventEmitter.emitTyped(StandardEvents.STATE_UPDATED, {\n    previousState,\n    currentState: this.currentState,\n    description: 'Undo operation'\n  });\n  \n  return this.currentState;\n}\n\n/**\n * Updates the world state in response to the redo operation\n * @returns The redone state or undefined if no state to redo\n */\npublic redo(): WorldState | undefined {\n  if (!this.config.enableUndo || this.redoStack.length === 0) {\n    return undefined;\n  }\n\n  // Store current state for event emission\n  const previousState = this.currentState;\n\n  // Pop the most recent state off the redo stack\n  const next = this.redoStack.pop()!;\n  \n  // Add to undo stack\n  this.undoStack.push(next);\n  \n  // Set as current state\n  this.currentState = next.state;\n  \n  // Emit state updated event for redo\n  this.eventEmitter.emitTyped(StandardEvents.STATE_UPDATED, {\n    previousState,\n    currentState: this.currentState,\n    description: 'Redo operation'\n  });\n  \n  return this.currentState;\n}\n```\n\nThese updates ensure that appropriate events are emitted whenever entity operations occur, allowing other parts of the system to react to these changes. The event payloads include relevant information about what changed, making it easy for listeners to determine if they need to take action.\n\nNow let's also make sure the EntityManager forwards these events when it performs operations. We'll need to modify it to access the EventEmitter from the StateManager:\n\n```typescript\n// packages/core/src/world-model/implementations/entity-manager.ts\n\n// ... existing code ...\n\nexport class EntityManager {\n  private stateManager: StateManager;\n  private config: EntityManagerConfig;\n  private eventEmitter: EventEmitter;\n  \n  constructor(stateManager: StateManager, config: Partial<EntityManagerConfig> = {}) {\n    this.stateManager = stateManager;\n    this.config = { ...DEFAULT_CONFIG, ...config };\n    this.eventEmitter = stateManager.getEventEmitter();\n  }\n  \n  // ... existing methods ...\n  \n  /**\n   * Gets the event emitter for this entity manager\n   */\n  public getEventEmitter(): EventEmitter {\n    return this.eventEmitter;\n  }\n  \n  // No need to modify most methods as they use stateManager methods \n  // which already emit events\n  \n  /**\n   * Cleans up an entity's relationships before removal\n   * This needs special handling to ensure relationship removal events are emitted\n   */\n  private cleanupEntityRelationships(entity: Entity): void {\n    // For each relationship type\n    for (const [type, targetIds] of Object.entries(entity.relationships)) {\n      const config = this.config.relationshipConfigs?.[type];\n      \n      // If bidirectional, remove inverse relationships\n      if (config?.bidirectional && config.inverseType) {\n        for (const targetId of targetIds) {\n          // We use removeRelationship instead of directly accessing stateManager\n          // to ensure events are emitted properly\n          this.removeRelationship(targetId, config.inverseType, entity.id);\n        }\n      }\n    }\n  }\n}\n```\n\nThese changes ensure that our EventEmitter is properly integrated with all entity operations, providing a consistent way for different parts of the system to react to state changes.",
          "citations": []
        }
      ],
      "sender": "assistant",
      "created_at": "2025-03-27T22:28:39.766914Z",
      "updated_at": "2025-03-27T22:28:39.766914Z",
      "attachments": [],
      "files": []
    },
    {
      "uuid": "e0b5b121-378b-4013-b0e8-5f55ef470d0e",
      "text": "just emit new entity-manager file",
      "content": [
        {
          "start_timestamp": "2025-03-27T21:17:09.823778Z",
          "stop_timestamp": "2025-03-27T21:17:09.823778Z",
          "type": "text",
          "text": "just emit new entity-manager file",
          "citations": []
        }
      ],
      "sender": "human",
      "created_at": "2025-03-27T22:35:25.290219Z",
      "updated_at": "2025-03-27T22:35:25.290219Z",
      "attachments": [],
      "files": []
    },
    {
      "uuid": "9507f835-3994-4238-a342-c77f004e7201",
      "text": " Here's the complete `entity-manager.ts` file with the EventEmitter integration:\n\n```typescript\n// packages/core/src/world-model/implementations/entity-manager.ts\n\nimport {\n  Entity,\n  EntityId,\n  EntityCreationParams,\n  EntityOperationOptions,\n  AttributeConfigMap,\n  AttributeValue,\n  RelationshipConfigMap,\n  RelationshipType,\n  WorldState\n} from '../types';\nimport { StateManager } from './immutable-state';\nimport { EventEmitter, StandardEvents } from './event-emitter';\n\n/**\n * Configuration options for the EntityManager\n */\nexport interface EntityManagerConfig {\n  /**\n   * Map of entity types to attribute configurations\n   */\n  attributeConfigs?: Record<string, AttributeConfigMap>;\n  \n  /**\n   * Map of relationship types to relationship configurations\n   */\n  relationshipConfigs?: RelationshipConfigMap;\n  \n  /**\n   * Whether to validate entities on creation and update\n   */\n  validateEntities?: boolean;\n}\n\n/**\n * Default configuration for EntityManager\n */\nconst DEFAULT_CONFIG: EntityManagerConfig = {\n  attributeConfigs: {},\n  relationshipConfigs: {},\n  validateEntities: true\n};\n\n/**\n * Provides higher-level entity operations on top of the StateManager\n */\nexport class EntityManager {\n  private stateManager: StateManager;\n  private config: EntityManagerConfig;\n  private eventEmitter: EventEmitter;\n  \n  /**\n   * Creates a new EntityManager\n   * @param stateManager The state manager to use\n   * @param config Configuration options\n   */\n  constructor(stateManager: StateManager, config: Partial<EntityManagerConfig> = {}) {\n    this.stateManager = stateManager;\n    this.config = { ...DEFAULT_CONFIG, ...config };\n    this.eventEmitter = stateManager.getEventEmitter();\n  }\n  \n  /**\n   * Gets the current world state\n   */\n  public getState(): WorldState {\n    return this.stateManager.getState();\n  }\n  \n  /**\n   * Gets an entity by ID\n   * @param id Entity ID\n   */\n  public getEntity(id: EntityId): Entity | undefined {\n    return this.stateManager.getEntity(id);\n  }\n  \n  /**\n   * Gets the event emitter for this entity manager\n   */\n  public getEventEmitter(): EventEmitter {\n    return this.eventEmitter;\n  }\n  \n  /**\n   * Creates a new entity\n   * @param params Entity creation parameters\n   * @param options Optional creation options\n   */\n  public createEntity(\n    params: EntityCreationParams,\n    options: EntityOperationOptions = {}\n  ): Entity {\n    // Validate attributes if validation is enabled\n    if (this.config.validateEntities) {\n      this.validateAttributes(params.type, params.attributes || {});\n    }\n    \n    // Create the entity\n    const entity = this.stateManager.createEntity(params);\n    \n    // Create bidirectional relationships if configured\n    if (params.relationships) {\n      this.createBidirectionalRelationships(entity.id, params.relationships);\n    }\n    \n    return entity;\n  }\n  \n  /**\n   * Updates an existing entity\n   * @param id Entity ID\n   * @param updates Entity updates\n   * @param options Update options\n   */\n  public updateEntity(\n    id: EntityId,\n    updates: Partial<Entity>,\n    options: EntityOperationOptions = {}\n  ): Entity | undefined {\n    const existingEntity = this.getEntity(id);\n    if (!existingEntity) return undefined;\n    \n    // Validate attributes if validation is enabled\n    if (this.config.validateEntities && updates.attributes) {\n      this.validateAttributes(\n        updates.type || existingEntity.type,\n        updates.attributes\n      );\n    }\n    \n    // Update the entity\n    const updatedEntity = this.stateManager.updateEntity(id, updates, options);\n    \n    // Update bidirectional relationships if needed\n    if (updatedEntity && updates.relationships) {\n      this.updateBidirectionalRelationships(\n        id, \n        existingEntity.relationships, \n        updatedEntity.relationships\n      );\n    }\n    \n    return updatedEntity;\n  }\n  \n  /**\n   * Removes an entity\n   * @param id Entity ID\n   */\n  public removeEntity(id: EntityId): boolean {\n    const entity = this.getEntity(id);\n    if (!entity) return false;\n    \n    // Clean up all bidirectional relationships before deleting\n    this.cleanupEntityRelationships(entity);\n    \n    return this.stateManager.removeEntity(id);\n  }\n  \n  /**\n   * Creates a relationship between entities\n   * @param sourceId Source entity ID\n   * @param type Relationship type\n   * @param targetId Target entity ID\n   */\n  public createRelationship(\n    sourceId: EntityId,\n    type: string,\n    targetId: EntityId\n  ): boolean {\n    // Check if entities exist\n    const source = this.getEntity(sourceId);\n    const target = this.getEntity(targetId);\n    if (!source || !target) return false;\n    \n    // Create the relationship\n    const success = this.stateManager.createRelationship(sourceId, type, targetId);\n    \n    // If successful and relationship is bidirectional, create the inverse\n    if (success) {\n      const config = this.config.relationshipConfigs?.[type];\n      if (config?.bidirectional && config.inverseType) {\n        this.stateManager.createRelationship(targetId, config.inverseType, sourceId);\n      }\n    }\n    \n    return success;\n  }\n  \n  /**\n   * Removes a relationship between entities\n   * @param sourceId Source entity ID\n   * @param type Relationship type\n   * @param targetId Target entity ID\n   */\n  public removeRelationship(\n    sourceId: EntityId,\n    type: string,\n    targetId: EntityId\n  ): boolean {\n    // Remove the relationship\n    const success = this.stateManager.removeRelationship(sourceId, type, targetId);\n    \n    // If successful and relationship is bidirectional, remove the inverse\n    if (success) {\n      const config = this.config.relationshipConfigs?.[type];\n      if (config?.bidirectional && config.inverseType) {\n        this.stateManager.removeRelationship(targetId, config.inverseType, sourceId);\n      }\n    }\n    \n    return success;\n  }\n  \n  /**\n   * Gets all entities of a specific type\n   * @param type Entity type\n   */\n  public getEntitiesByType(type: string): Entity[] {\n    const state = this.getState();\n    return Object.values(state.entities).filter(entity => entity.type === type);\n  }\n  \n  /**\n   * Gets entities related to a specific entity\n   * @param id Entity ID\n   * @param type Optional relationship type to filter by\n   */\n  public getRelatedEntities(id: EntityId, type?: string): Entity[] {\n    const entity = this.getEntity(id);\n    if (!entity) return [];\n    \n    const relatedIds: EntityId[] = [];\n    \n    if (type) {\n      // Get entities for a specific relationship type\n      const relationships = entity.relationships[type] || [];\n      relatedIds.push(...relationships);\n    } else {\n      // Get all related entities\n      Object.values(entity.relationships).forEach(ids => {\n        relatedIds.push(...ids);\n      });\n    }\n    \n    // Get the actual entity objects\n    return relatedIds\n      .map(relatedId => this.getEntity(relatedId))\n      .filter((e): e is Entity => e !== undefined);\n  }\n  \n  /**\n   * Validates attributes against attribute configurations\n   * @param type Entity type\n   * @param attributes Attributes to validate\n   */\n  private validateAttributes(type: string, attributes: Record<string, unknown>): void {\n    const configs = this.config.attributeConfigs?.[type];\n    if (!configs) return;\n    \n    // Check for required attributes\n    for (const [key, config] of Object.entries(configs)) {\n      if (config.required && !(key in attributes)) {\n        throw new Error(`Required attribute \"${key}\" missing for entity type \"${type}\"`);\n      }\n      \n      // Skip validation if attribute is not present\n      if (!(key in attributes)) continue;\n      \n      const value = attributes[key];\n      \n      // Type validation\n      if (config.type) {\n        const valueType = value === null ? 'null' : typeof value;\n        if (\n          (config.type === 'array' && !Array.isArray(value)) ||\n          (config.type !== 'array' && config.type !== valueType)\n        ) {\n          throw new Error(\n            `Attribute \"${key}\" for entity type \"${type}\" must be of type \"${config.type}\"`\n          );\n        }\n      }\n      \n      // Custom validation\n      if (config.validate && !config.validate(value as AttributeValue)) {\n        throw new Error(\n          `Attribute \"${key}\" for entity type \"${type}\" failed custom validation`\n        );\n      }\n    }\n  }\n  \n  /**\n   * Creates bidirectional relationships for a new entity\n   * @param entityId Entity ID\n   * @param relationships Relationships to create\n   */\n  private createBidirectionalRelationships(\n    entityId: EntityId,\n    relationships: Record<string, EntityId[]>\n  ): void {\n    for (const [type, targetIds] of Object.entries(relationships)) {\n      const config = this.config.relationshipConfigs?.[type];\n      \n      if (config?.bidirectional && config.inverseType) {\n        for (const targetId of targetIds) {\n          // Create inverse relationship\n          this.stateManager.createRelationship(\n            targetId,\n            config.inverseType,\n            entityId\n          );\n        }\n      }\n    }\n  }\n  \n  /**\n   * Updates bidirectional relationships when an entity is updated\n   * @param entityId Entity ID\n   * @param oldRelationships Old relationships\n   * @param newRelationships New relationships\n   */\n  private updateBidirectionalRelationships(\n    entityId: EntityId,\n    oldRelationships: Record<string, EntityId[]>,\n    newRelationships: Record<string, EntityId[]>\n  ): void {\n    // Process each relationship type\n    for (const [type, config] of Object.entries(this.config.relationshipConfigs || {})) {\n      if (!config.bidirectional || !config.inverseType) continue;\n      \n      const oldTargets = oldRelationships[type] || [];\n      const newTargets = newRelationships[type] || [];\n      \n      // Find targets to add and remove\n      const targetsToAdd = newTargets.filter(id => !oldTargets.includes(id));\n      const targetsToRemove = oldTargets.filter(id => !newTargets.includes(id));\n      \n      // Create new inverse relationships\n      for (const targetId of targetsToAdd) {\n        this.stateManager.createRelationship(\n          targetId,\n          config.inverseType,\n          entityId\n        );\n      }\n      \n      // Remove old inverse relationships\n      for (const targetId of targetsToRemove) {\n        this.stateManager.removeRelationship(\n          targetId,\n          config.inverseType,\n          entityId\n        );\n      }\n    }\n  }\n  \n  /**\n   * Cleans up an entity's relationships before removal\n   * @param entity Entity to clean up\n   */\n  private cleanupEntityRelationships(entity: Entity): void {\n    // For each relationship type\n    for (const [type, targetIds] of Object.entries(entity.relationships)) {\n      const config = this.config.relationshipConfigs?.[type];\n      \n      // If bidirectional, remove inverse relationships\n      if (config?.bidirectional && config.inverseType) {\n        for (const targetId of targetIds) {\n          // Use removeRelationship instead of directly accessing stateManager\n          // to ensure events are emitted properly\n          this.removeRelationship(targetId, config.inverseType, entity.id);\n        }\n      }\n    }\n  }\n  \n  /**\n   * Creates an entity with preset attributes\n   * @param templateName Template name\n   * @param overrides Optional attribute overrides\n   */\n  public createEntityFromTemplate(\n    templateName: string,\n    overrides: Partial<EntityCreationParams> = {}\n  ): Entity | undefined {\n    // This would be implemented to handle entity templates\n    // We could define common entity types (room, item, character) with preset attributes\n    \n    // For now, just return undefined as this is a placeholder\n    return undefined;\n  }\n}\n\n/**\n * Creates a new entity manager with the given state manager\n * @param stateManager State manager to use\n * @param config Configuration options\n */\nexport function createEntityManager(\n  stateManager: StateManager,\n  config?: Partial<EntityManagerConfig>\n): EntityManager {\n  return new EntityManager(stateManager, config);\n}\n```",
      "content": [
        {
          "start_timestamp": "2025-03-27T22:35:26.461806Z",
          "stop_timestamp": "2025-03-27T22:36:00.011091Z",
          "type": "text",
          "text": " Here's the complete `entity-manager.ts` file with the EventEmitter integration:\n\n```typescript\n// packages/core/src/world-model/implementations/entity-manager.ts\n\nimport {\n  Entity,\n  EntityId,\n  EntityCreationParams,\n  EntityOperationOptions,\n  AttributeConfigMap,\n  AttributeValue,\n  RelationshipConfigMap,\n  RelationshipType,\n  WorldState\n} from '../types';\nimport { StateManager } from './immutable-state';\nimport { EventEmitter, StandardEvents } from './event-emitter';\n\n/**\n * Configuration options for the EntityManager\n */\nexport interface EntityManagerConfig {\n  /**\n   * Map of entity types to attribute configurations\n   */\n  attributeConfigs?: Record<string, AttributeConfigMap>;\n  \n  /**\n   * Map of relationship types to relationship configurations\n   */\n  relationshipConfigs?: RelationshipConfigMap;\n  \n  /**\n   * Whether to validate entities on creation and update\n   */\n  validateEntities?: boolean;\n}\n\n/**\n * Default configuration for EntityManager\n */\nconst DEFAULT_CONFIG: EntityManagerConfig = {\n  attributeConfigs: {},\n  relationshipConfigs: {},\n  validateEntities: true\n};\n\n/**\n * Provides higher-level entity operations on top of the StateManager\n */\nexport class EntityManager {\n  private stateManager: StateManager;\n  private config: EntityManagerConfig;\n  private eventEmitter: EventEmitter;\n  \n  /**\n   * Creates a new EntityManager\n   * @param stateManager The state manager to use\n   * @param config Configuration options\n   */\n  constructor(stateManager: StateManager, config: Partial<EntityManagerConfig> = {}) {\n    this.stateManager = stateManager;\n    this.config = { ...DEFAULT_CONFIG, ...config };\n    this.eventEmitter = stateManager.getEventEmitter();\n  }\n  \n  /**\n   * Gets the current world state\n   */\n  public getState(): WorldState {\n    return this.stateManager.getState();\n  }\n  \n  /**\n   * Gets an entity by ID\n   * @param id Entity ID\n   */\n  public getEntity(id: EntityId): Entity | undefined {\n    return this.stateManager.getEntity(id);\n  }\n  \n  /**\n   * Gets the event emitter for this entity manager\n   */\n  public getEventEmitter(): EventEmitter {\n    return this.eventEmitter;\n  }\n  \n  /**\n   * Creates a new entity\n   * @param params Entity creation parameters\n   * @param options Optional creation options\n   */\n  public createEntity(\n    params: EntityCreationParams,\n    options: EntityOperationOptions = {}\n  ): Entity {\n    // Validate attributes if validation is enabled\n    if (this.config.validateEntities) {\n      this.validateAttributes(params.type, params.attributes || {});\n    }\n    \n    // Create the entity\n    const entity = this.stateManager.createEntity(params);\n    \n    // Create bidirectional relationships if configured\n    if (params.relationships) {\n      this.createBidirectionalRelationships(entity.id, params.relationships);\n    }\n    \n    return entity;\n  }\n  \n  /**\n   * Updates an existing entity\n   * @param id Entity ID\n   * @param updates Entity updates\n   * @param options Update options\n   */\n  public updateEntity(\n    id: EntityId,\n    updates: Partial<Entity>,\n    options: EntityOperationOptions = {}\n  ): Entity | undefined {\n    const existingEntity = this.getEntity(id);\n    if (!existingEntity) return undefined;\n    \n    // Validate attributes if validation is enabled\n    if (this.config.validateEntities && updates.attributes) {\n      this.validateAttributes(\n        updates.type || existingEntity.type,\n        updates.attributes\n      );\n    }\n    \n    // Update the entity\n    const updatedEntity = this.stateManager.updateEntity(id, updates, options);\n    \n    // Update bidirectional relationships if needed\n    if (updatedEntity && updates.relationships) {\n      this.updateBidirectionalRelationships(\n        id, \n        existingEntity.relationships, \n        updatedEntity.relationships\n      );\n    }\n    \n    return updatedEntity;\n  }\n  \n  /**\n   * Removes an entity\n   * @param id Entity ID\n   */\n  public removeEntity(id: EntityId): boolean {\n    const entity = this.getEntity(id);\n    if (!entity) return false;\n    \n    // Clean up all bidirectional relationships before deleting\n    this.cleanupEntityRelationships(entity);\n    \n    return this.stateManager.removeEntity(id);\n  }\n  \n  /**\n   * Creates a relationship between entities\n   * @param sourceId Source entity ID\n   * @param type Relationship type\n   * @param targetId Target entity ID\n   */\n  public createRelationship(\n    sourceId: EntityId,\n    type: string,\n    targetId: EntityId\n  ): boolean {\n    // Check if entities exist\n    const source = this.getEntity(sourceId);\n    const target = this.getEntity(targetId);\n    if (!source || !target) return false;\n    \n    // Create the relationship\n    const success = this.stateManager.createRelationship(sourceId, type, targetId);\n    \n    // If successful and relationship is bidirectional, create the inverse\n    if (success) {\n      const config = this.config.relationshipConfigs?.[type];\n      if (config?.bidirectional && config.inverseType) {\n        this.stateManager.createRelationship(targetId, config.inverseType, sourceId);\n      }\n    }\n    \n    return success;\n  }\n  \n  /**\n   * Removes a relationship between entities\n   * @param sourceId Source entity ID\n   * @param type Relationship type\n   * @param targetId Target entity ID\n   */\n  public removeRelationship(\n    sourceId: EntityId,\n    type: string,\n    targetId: EntityId\n  ): boolean {\n    // Remove the relationship\n    const success = this.stateManager.removeRelationship(sourceId, type, targetId);\n    \n    // If successful and relationship is bidirectional, remove the inverse\n    if (success) {\n      const config = this.config.relationshipConfigs?.[type];\n      if (config?.bidirectional && config.inverseType) {\n        this.stateManager.removeRelationship(targetId, config.inverseType, sourceId);\n      }\n    }\n    \n    return success;\n  }\n  \n  /**\n   * Gets all entities of a specific type\n   * @param type Entity type\n   */\n  public getEntitiesByType(type: string): Entity[] {\n    const state = this.getState();\n    return Object.values(state.entities).filter(entity => entity.type === type);\n  }\n  \n  /**\n   * Gets entities related to a specific entity\n   * @param id Entity ID\n   * @param type Optional relationship type to filter by\n   */\n  public getRelatedEntities(id: EntityId, type?: string): Entity[] {\n    const entity = this.getEntity(id);\n    if (!entity) return [];\n    \n    const relatedIds: EntityId[] = [];\n    \n    if (type) {\n      // Get entities for a specific relationship type\n      const relationships = entity.relationships[type] || [];\n      relatedIds.push(...relationships);\n    } else {\n      // Get all related entities\n      Object.values(entity.relationships).forEach(ids => {\n        relatedIds.push(...ids);\n      });\n    }\n    \n    // Get the actual entity objects\n    return relatedIds\n      .map(relatedId => this.getEntity(relatedId))\n      .filter((e): e is Entity => e !== undefined);\n  }\n  \n  /**\n   * Validates attributes against attribute configurations\n   * @param type Entity type\n   * @param attributes Attributes to validate\n   */\n  private validateAttributes(type: string, attributes: Record<string, unknown>): void {\n    const configs = this.config.attributeConfigs?.[type];\n    if (!configs) return;\n    \n    // Check for required attributes\n    for (const [key, config] of Object.entries(configs)) {\n      if (config.required && !(key in attributes)) {\n        throw new Error(`Required attribute \"${key}\" missing for entity type \"${type}\"`);\n      }\n      \n      // Skip validation if attribute is not present\n      if (!(key in attributes)) continue;\n      \n      const value = attributes[key];\n      \n      // Type validation\n      if (config.type) {\n        const valueType = value === null ? 'null' : typeof value;\n        if (\n          (config.type === 'array' && !Array.isArray(value)) ||\n          (config.type !== 'array' && config.type !== valueType)\n        ) {\n          throw new Error(\n            `Attribute \"${key}\" for entity type \"${type}\" must be of type \"${config.type}\"`\n          );\n        }\n      }\n      \n      // Custom validation\n      if (config.validate && !config.validate(value as AttributeValue)) {\n        throw new Error(\n          `Attribute \"${key}\" for entity type \"${type}\" failed custom validation`\n        );\n      }\n    }\n  }\n  \n  /**\n   * Creates bidirectional relationships for a new entity\n   * @param entityId Entity ID\n   * @param relationships Relationships to create\n   */\n  private createBidirectionalRelationships(\n    entityId: EntityId,\n    relationships: Record<string, EntityId[]>\n  ): void {\n    for (const [type, targetIds] of Object.entries(relationships)) {\n      const config = this.config.relationshipConfigs?.[type];\n      \n      if (config?.bidirectional && config.inverseType) {\n        for (const targetId of targetIds) {\n          // Create inverse relationship\n          this.stateManager.createRelationship(\n            targetId,\n            config.inverseType,\n            entityId\n          );\n        }\n      }\n    }\n  }\n  \n  /**\n   * Updates bidirectional relationships when an entity is updated\n   * @param entityId Entity ID\n   * @param oldRelationships Old relationships\n   * @param newRelationships New relationships\n   */\n  private updateBidirectionalRelationships(\n    entityId: EntityId,\n    oldRelationships: Record<string, EntityId[]>,\n    newRelationships: Record<string, EntityId[]>\n  ): void {\n    // Process each relationship type\n    for (const [type, config] of Object.entries(this.config.relationshipConfigs || {})) {\n      if (!config.bidirectional || !config.inverseType) continue;\n      \n      const oldTargets = oldRelationships[type] || [];\n      const newTargets = newRelationships[type] || [];\n      \n      // Find targets to add and remove\n      const targetsToAdd = newTargets.filter(id => !oldTargets.includes(id));\n      const targetsToRemove = oldTargets.filter(id => !newTargets.includes(id));\n      \n      // Create new inverse relationships\n      for (const targetId of targetsToAdd) {\n        this.stateManager.createRelationship(\n          targetId,\n          config.inverseType,\n          entityId\n        );\n      }\n      \n      // Remove old inverse relationships\n      for (const targetId of targetsToRemove) {\n        this.stateManager.removeRelationship(\n          targetId,\n          config.inverseType,\n          entityId\n        );\n      }\n    }\n  }\n  \n  /**\n   * Cleans up an entity's relationships before removal\n   * @param entity Entity to clean up\n   */\n  private cleanupEntityRelationships(entity: Entity): void {\n    // For each relationship type\n    for (const [type, targetIds] of Object.entries(entity.relationships)) {\n      const config = this.config.relationshipConfigs?.[type];\n      \n      // If bidirectional, remove inverse relationships\n      if (config?.bidirectional && config.inverseType) {\n        for (const targetId of targetIds) {\n          // Use removeRelationship instead of directly accessing stateManager\n          // to ensure events are emitted properly\n          this.removeRelationship(targetId, config.inverseType, entity.id);\n        }\n      }\n    }\n  }\n  \n  /**\n   * Creates an entity with preset attributes\n   * @param templateName Template name\n   * @param overrides Optional attribute overrides\n   */\n  public createEntityFromTemplate(\n    templateName: string,\n    overrides: Partial<EntityCreationParams> = {}\n  ): Entity | undefined {\n    // This would be implemented to handle entity templates\n    // We could define common entity types (room, item, character) with preset attributes\n    \n    // For now, just return undefined as this is a placeholder\n    return undefined;\n  }\n}\n\n/**\n * Creates a new entity manager with the given state manager\n * @param stateManager State manager to use\n * @param config Configuration options\n */\nexport function createEntityManager(\n  stateManager: StateManager,\n  config?: Partial<EntityManagerConfig>\n): EntityManager {\n  return new EntityManager(stateManager, config);\n}\n```",
          "citations": []
        }
      ],
      "sender": "assistant",
      "created_at": "2025-03-27T22:36:04.725591Z",
      "updated_at": "2025-03-27T22:36:04.725591Z",
      "attachments": [],
      "files": []
    }
  ],
  "_extraction_metadata": {
    "extraction_method": "exact_title_match",
    "matched_title": "Developing the World Model for Interactive Fiction",
    "extraction_timestamp": "2025-06-21T06:39:33.573Z",
    "source": "claude_project_sharpee"
  }
}