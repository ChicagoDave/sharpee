# ADR-058: Action Report Function for Atomic Event Generation

## Status
Proposed

## Context
For true atomic events that support historical replay, we need events to contain all necessary data at creation time rather than requiring world queries later. The current system mixes state mutation and event generation in the `execute()` method, making it difficult to capture complete state snapshots.

Key requirements:
- Events must be self-contained with all display data
- State must be captured AFTER all mutations complete
- Authors need to customize event generation
- The system must support the atomic events architecture from ADR-051

## Decision

### Three-Phase Action Pattern
Separate action execution into three distinct phases:

```typescript
interface Action {
  id: string;
  
  // Phase 1: Can this action happen?
  validate(context: ActionContext): ValidationResult;
  
  // Phase 2: Make it happen (mutations only)
  execute(context: ActionContext): void;
  
  // Phase 3: Report what happened (event generation)
  report(context: ActionContext): ISemanticEvent[];
}
```

### Report Function Design
The `report()` function is responsible for:
1. Capturing all relevant state AFTER mutations
2. Creating atomic events with embedded data
3. Generating display events for the text service

```typescript
class LookingAction implements Action {
  report(context: ActionContext): ISemanticEvent[] {
    const location = context.currentLocation;
    const visible = context.getVisible();
    
    // Capture complete state at this moment
    const roomData = {
      roomId: location.id,
      roomName: location.name,
      roomDescription: location.description,
      contents: visible.map(entity => ({
        id: entity.id,
        name: entity.name,
        description: entity.description
      })),
      isDark: this.checkDarkness(context),
      timestamp: Date.now()
    };
    
    return [
      // Atomic event with all data embedded
      context.event('room.described', roomData),
      
      // Display event for text service
      context.event('action.success', {
        actionId: this.id,
        messageId: 'room_description',
        params: { location: location.name }
      })
    ];
  }
}
```

### Customization Options

#### Option 1: Direct Implementation (Chosen)
Actions implement their own `report()` function with full control:

```typescript
const customAction: Action = {
  report(context): ISemanticEvent[] {
    // Full control over event generation
    const events = [];
    
    // Add standard events
    events.push(context.event('action.completed', {...}));
    
    // Add custom story events
    if (context.world.getFlag('special-mode')) {
      events.push(context.event('story.special', {...}));
    }
    
    return events;
  }
};
```

**Pros:**
- Simple and direct
- Full control for each action
- No additional abstraction layers

**Cons:**
- Some duplication across actions
- Authors must understand event structure

#### Option 2: Declarative Configuration (Not Chosen)
```typescript
const action: Action = {
  reportConfig: {
    captureFields: ['location', 'target', 'contents'],
    eventType: 'action.taken',
    messageId: 'item_taken'
  }
};
```

**Rejected because:** Too limiting for complex scenarios

#### Option 3: Report Middleware (Not Chosen)
```typescript
const action: Action = {
  report: compose(
    captureRoomState,
    addStoryEvents,
    generateDisplayEvent
  )
};
```

**Rejected because:** Adds complexity without clear benefit

### Integration with Rules System
The complete execution flow:

1. **Before Rules** - Can modify state
2. **Action.validate()** - Check if action is valid
3. **Action.execute()** - Perform mutations
4. **After Rules** - Can react and modify state
5. **Action.report()** - Generate events from final state

This ensures that `report()` sees the complete, final state after all mutations.

### Event Data Structure
Events generated by `report()` should follow this pattern:

```typescript
interface AtomicEvent extends ISemanticEvent {
  type: string;
  data: {
    // All data needed for display/replay
    // No world queries required later
    [key: string]: any;
  };
  timestamp: number;
  entities: Record<string, string>;  // Entity relationships
}
```

## Consequences

### Positive
- **Clean separation** - Mutations vs reporting are distinct
- **Atomic events** - All data captured at creation time
- **Predictable timing** - State captured after all mutations
- **Testable** - Can verify events match expected state
- **Historical accuracy** - Events preserve state at that moment

### Negative
- **Migration effort** - Existing actions need refactoring
- **Potential duplication** - Similar reporting logic across actions
- **Learning curve** - Authors must understand the three-phase pattern

### Neutral
- Event size increases (more embedded data)
- Text service becomes simpler (no world queries)
- Actions become more explicit about their effects

## Alternatives Considered

1. **Keep execute() combined** - Current approach, harder to ensure atomic events
2. **Two-phase (validate/execute)** - No separation of mutations and reporting
3. **Four-phase (validate/prepare/execute/report)** - Too complex
4. **Event sourcing only** - Would require complete rewrite

## Implementation Notes

- Start with high-impact actions (looking, taking, going)
- Provide helper functions for common capture patterns
- Document clear examples for authors
- Consider performance impact of larger events
- Ensure backward compatibility during migration

## Examples

### Simple Action
```typescript
const takingAction: Action = {
  validate(context): ValidationResult {
    const item = context.command.directObject?.entity;
    if (!item) return { valid: false, error: 'no_target' };
    if (!context.canReach(item)) return { valid: false, error: 'cannot_reach' };
    return { valid: true };
  },
  
  execute(context): void {
    const item = context.command.directObject.entity;
    context.world.moveEntity(item.id, context.player.id);
  },
  
  report(context): ISemanticEvent[] {
    const item = context.command.directObject.entity;
    return [
      context.event('item.taken', {
        item: {
          id: item.id,
          name: item.name,
          description: item.description
        },
        from: context.world.getLocation(item.id),
        by: context.player.id,
        timestamp: Date.now()
      }),
      context.event('action.success', {
        actionId: this.id,
        messageId: 'taken',
        params: { item: item.name }
      })
    ];
  }
};
```

### Complex Action with Story Integration
```typescript
const pushingAction: Action = {
  report(context): ISemanticEvent[] {
    const target = context.command.directObject.entity;
    const events = [];
    
    // Standard event
    events.push(context.event('object.pushed', {
      object: {
        id: target.id,
        name: target.name,
        state: target.getState()
      }
    }));
    
    // Story-specific events
    if (target.id === 'red-button') {
      const count = context.world.getFlag('button-presses');
      if (count === 3) {
        events.push(context.event('puzzle.solved', {
          puzzle: 'three-buttons',
          reward: 'secret-door-opens'
        }));
      }
    }
    
    // Display event
    events.push(context.event('action.success', {
      actionId: this.id,
      messageId: 'pushed',
      params: { object: target.name }
    }));
    
    return events;
  }
};
```