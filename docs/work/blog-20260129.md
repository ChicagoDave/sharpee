# Building a Platform in Public: What Six Architecture Decisions Taught Us

*January 29, 2026*

We're building Sharpee, a parser-based Interactive Fiction authoring tool in TypeScript. For the past week we've been dog-fooding it by implementing Mainframe Zork — all 191 rooms — and the pressure of a real game has been forcing architectural questions we couldn't have anticipated from the whiteboard.

Six of those questions crystallized into formal architecture decisions over the last few days. This is the story of how they connect, what surprised us, and what we threw away.

## It Started With a Boat

We were implementing the inflatable boat from Zork. The player climbs in, and if they're carrying something sharp, the boat punctures. Simple puzzle, ancient lineage. But in Sharpee, the ENTER action has standard semantics — it moves the player into a container. The boat doesn't get a say.

Our event handler could react *after* the enter, but it couldn't block it or modify it. The entity didn't own its participation in the action. We'd been papering over this with post-hoc event handlers for a while, but the boat made the gap impossible to ignore.

So we designed **action interceptors** — hooks that let entities participate in standard actions without replacing them. `preValidate` to block early, `postValidate` to add entity-specific conditions, `postExecute` to layer on consequences. The boat interceptor lets the standard ENTER proceed, then punctures the boat in `postExecute`. The action happened; the consequence is entity-owned.

The deeper realization was that we already had two patterns and hadn't named them. Verbs like LOWER and TURN have no standard semantics — they mean different things for different entities, so we fully delegate to behaviors. Verbs like ENTER and PUT *do* have standard semantics — they just need extension points. Naming the split (capability dispatch vs interceptors) made the whole system legible.

## Every Puzzle Was Reinventing the Wheel

With the boat sorted, we turned to Zork's multi-step puzzles. The tiny room puzzle requires four actions in sequence: PUT MAT under door, PUSH KEY through keyhole, PULL MAT back, UNLOCK door. Each step depends on the last. We'd been coding these as hand-rolled orchestration modules — utility files exporting mutation functions, called from story actions. Every puzzle reinvented state storage, guard conditions, transitions, and message selection.

They were all state machines. We just hadn't said it out loud.

So we built a **declarative state machine system**. States, transitions, guards, effects. One runtime serving two patterns: tight puzzle orchestration (action-triggered, entity-scoped, a few states) and loose narrative arcs (event-triggered, global, many states). We studied Inform 7's scene system closely — it partitions narrative *time* using condition polling, while ours partitions entity *state* using event triggers — but the underlying mechanics are the same.

We migrated five real handlers to validate the design. The rainbow puzzle was the most interesting: it's bidirectional, toggling between inactive and active when the player waves the sceptre. The migration established a clean pattern — actions emit semantic events in the report phase, state machines pick them up and own the mutations. Causality becomes explicit.

But we also discovered what state machines *can't* do. The endgame trigger handler monitors a condition over many turns: are there treasures not in the trophy case? It accumulates a counter, resets when the condition breaks, and fires at a threshold. That's not event-driven. It's a watchdog. The state machine doesn't fit, and forcing it would create a convoluted mess.

That discovery seeded what came later.

## The Engine Was Getting Fat

By now we had three subsystems running after each player action: NPCs, the scheduler (daemons and fuses), and the new state machine evaluator. Each had ~45 lines of identical boilerplate in `game-engine.ts` for event enrichment, perception filtering, and emission. Three copies. A fourth was coming.

The fix was obvious once we stopped to look: a **plugin architecture**. The engine defines a `TurnPlugin` interface with one method (`onAfterAction`) and optional serialization. Subsystems register as plugins. The engine loop collapses from three hardcoded blocks to one iteration. Adding a new reactive system never touches the engine again.

This was the least dramatic decision of the six, but maybe the most important for long-term health. The engine went from knowing about NPCs, daemons, fuses, and state machines to knowing about *plugins*. The rest is someone else's problem.

## What Does Distribution Look Like?

With the engine cleaned up, a bigger question surfaced. Every Sharpee story compiles into a monolithic 1.2MB bundle — the engine, the standard library, the parser, the language layer, and the client, all in one file. Authors have to build and deploy a full web application. There's no way to just *share a story*.

The IF community solved this in 1979. Frotz loads Z-machine files. Gargoyle loads Glulx. Lectrote loads Blorb. Authors distribute small story files; players install one runner. We had no equivalent.

So we designed the **Sharpee Runner** — a standalone application (Tauri for desktop, a static site for web) that contains the entire platform. Stories become `.sharpee` files: zip archives holding `story.js` (the story code with all platform packages marked as external), `meta.json` (title, author, version, IFID), and optional assets.

The `story.js` module exports the exact same `Story` interface stories already implement. Stories don't know or care whether they're running inside a monolith or a runner. The build change is scope, not shape.

Tauri was the obvious choice for the desktop variant — ~10MB vs ~150MB for Electron, native file pickers, and a sandboxed webview where story code runs with no filesystem or network access. The runner acts as a capability broker. The story asks "save this state" and the runner decides how and where.

The `meta.json` file is the quiet star. The runner reads it from the zip without executing any code, which enables a story library UI, version compatibility checks, and IFDB integration. It includes an IFID following the Treaty of Babel, so Sharpee stories can participate in the broader IF cataloging ecosystem from day one.

## Text-Only IF in 2026

Once we had a distribution format with an `assets/` directory, the next question was inevitable. Can stories include illustrations? Custom styling?

Vorple gave Inform 7 authors access to HTML/CSS/JS. Harmonia embedded illustrations inline with prose, wrapping text around images like an illustrated book. Twine stories freely mix media. Sharpee produced plain text.

But the architecture was already positioned for this. Stories are TypeScript running in a browser. The missing piece was a contract.

We split it into two independent concerns. **Inline illustrations** flow through the trait and event system: an `IllustrationTrait` on an entity carries pure data (source, alt text, position, width), and the action report phase emits an illustration event alongside the text event. The client composes them at render time. A browser floats the image alongside prose. A CLI prints `[Image: alt text]`. The engine and language layer never see it. Players toggle illustrations off with a preference and nothing upstream changes.

**Story styling** is standard CSS. A `theme.css` in the `.sharpee` archive, scoped to the game content area so it can't break the runner's UI. The style cascade is explicit: runner defaults, then story theme, then player preferences. Accessibility always wins.

The layer separation is the point. The engine passes events through without understanding them. The language layer produces text without knowing images exist. The world model holds illustration data as a trait. The client renders everything. Each layer does exactly one thing.

## The Hierarchy That Wasn't

Back to that watchdog pattern from the state machine work. We surveyed all ~15 daemons in the codebase and found five recurring shapes: watchdogs (monitor a condition, count turns, fire at threshold), location reactors (active in specific rooms), ambience emitters (atmospheric messages with cooldowns), countdowns (fire after N turns), and state watchers (already migrated to state machines).

Five patterns, five base classes. Clean taxonomy. Good ADR. We implemented all of it.

Then we migrated real daemons and started paying attention.

`LocationDaemon` saved exactly one line of code — a player location check. `TrollRecoveryRunner` extended `DaemonRunner` and used zero features from it. `AmbienceDaemon` and `CountdownDaemon` existed as base classes with no subclasses. The forest ambience runner was *longer* than the factory function it replaced.

Each daemon is quirky. Puzzle-specific. Full of conditional logic that doesn't generalize. The pattern taxonomy looked clean on paper and fell apart on contact with reality. We were paying the complexity tax of a class hierarchy and getting almost nothing back.

So we deleted it. All five base classes, all six migrations, reverted to factory functions. The ADR's status is "PARTIALLY ACCEPTED" — because one piece survived.

**Serialization.** The ADR also proposed `getRunnerState()` / `restoreRunnerState()` hooks on the `Daemon` interface, with scheduler integration for save/load. That was genuinely valuable. The sword-glow daemon tracks a glow level that must survive save/restore. Factory functions can implement those hooks just as easily as classes. We kept the horizontal concern and threw away the vertical taxonomy.

The whole cycle — design, implement, assess, revert — took about four hours across three sessions. The codebase is better for having tried it. We learned that serialization is a separate concern from structure, that pattern recognition on paper doesn't predict real-world fit, and that reverting is a sign of health, not failure.

## What Connects All of This

Six decisions in a week, and they tell one story: a platform figuring out where its boundaries are.

The engine used to know about NPCs and daemons and fuses. Now it knows about plugins. Actions used to be sealed units. Now entities can intercept them. Puzzles used to be bespoke code. Now they're state machines. Stories used to be monoliths. Now they're portable bundles. Media used to be nonexistent. Now it flows through the event system like everything else.

And when we built a class hierarchy that looked elegant in theory, we had the discipline to measure it against reality and delete it in the same week.

The common thread is separation of concerns carried to its conclusion. Each layer does one thing. The engine orchestrates turns. Plugins react to them. State machines own transitions. Traits own entity data. Actions own mutations. The language layer owns prose. The client owns rendering. Stories own content. The runner owns the player experience.

We're still deep in the Zork implementation — 148 walkthroughs passing, dozens more rooms to build. The architecture work isn't done; it never is. But the platform that emerged this week feels like it knows what it wants to be.
