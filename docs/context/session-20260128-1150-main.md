# Session Summary: 2026-01-28 - main

## Status: Completed

## Goals
- Implement ADR-120 Engine Plugin Architecture Phase 1: Core plugin contract
- Implement ADR-120 Phase 2: Extract scheduler service to first plugin
- Validate architecture with full test suite (148 walkthroughs + 79 unit transcripts)

## Completed

### Phase 1: Core Plugin Contract Package

Created `@sharpee/plugins` as the foundational contract package for the plugin system:

**Package Structure:**
- `packages/plugins/src/turn-plugin.ts` - Core TurnPlugin interface with id, priority, lifecycle hooks
- `packages/plugins/src/turn-plugin-context.ts` - TurnPluginContext interface providing world access, turn state, random, action results
- `packages/plugins/src/plugin-registry.ts` - PluginRegistry class for registration, retrieval (priority-sorted), state management
- `packages/plugins/src/index.ts` - Barrel export for all plugin types

**Key Design Decisions:**
- Plugins execute via `onAfterAction(context)` lifecycle hook
- Priority determines execution order (higher = earlier, descending sort)
- State serialization handled via `getState()/setState()` for save/restore
- TurnPluginContext provides controlled access to engine internals without tight coupling

**Integration:**
- Added to build.sh after world-model, before engine
- Engine dependency: @sharpee/plugins for PluginRegistry and types
- Story dependency: Will use plugin-specific packages (e.g., @sharpee/plugin-scheduler)

### Phase 2: Scheduler Extraction to Plugin

Extracted the scheduler service from engine core to `@sharpee/plugin-scheduler`:

**Package Contents:**
- `scheduler-service.ts` - Core SchedulerService (moved from engine)
- `seeded-random.ts` - SeededRandom class (moved from engine)
- `types.ts` - ScheduledEvent, FuseEvent, DaemonEvent types (moved from engine)
- `scheduler-plugin.ts` - NEW: SchedulerPlugin wrapper implementing TurnPlugin
- Priority: 50 (convention: NPC=100, StateMachine=75, Scheduler=50)

**Engine Refactoring (`packages/engine/src/game-engine.ts`):**

Replaced scheduler-specific implementation with generic plugin architecture:

```typescript
// OLD:
private scheduler: SchedulerService;

// NEW:
private pluginRegistry: PluginRegistry;
private random: SeededRandom;
```

**Critical Changes:**
1. **Constructor**: Initialize PluginRegistry and SeededRandom centrally
2. **Plugin Loop**: New phase after NPC actions
   ```typescript
   // After NPC actions, run all registered plugins
   for (const plugin of this.pluginRegistry.getAll()) {
     const pluginContext: TurnPluginContext = {
       world: this.world,
       turn: this.turnCount,
       playerId: this.playerId,
       playerLocation: this.world.getLocation(this.playerId),
       random: this.random,
       actionResult,
       actionEvents
     };
     const pluginEvents = await plugin.onAfterAction(pluginContext);
     await this.processPluginEvents(pluginEvents);
   }
   ```
3. **processPluginEvents()**: Shared event pipeline for plugin-emitted events
   - Enrich with metadata (turn, timestamp)
   - Filter duplicate events
   - Store in turn context
   - Emit to story handlers
4. **Save/Restore**: Generic plugin state serialization
   ```typescript
   // Save:
   pluginStates: this.pluginRegistry.getStates()

   // Restore:
   this.pluginRegistry.setStates(state.pluginStates || {})
   ```

**API Changes:**
- Removed: `getScheduler(): SchedulerService`
- Added: `getPluginRegistry(): PluginRegistry`

**Deleted Files:**
- `packages/engine/src/scheduler/scheduler-service.ts`
- `packages/engine/src/scheduler/seeded-random.ts`
- `packages/engine/src/scheduler/types.ts`
- `packages/engine/src/scheduler/index.ts`

**Story Updates (24 files modified):**

All Dungeo story files updated to use new plugin-scheduler package:

```typescript
// OLD:
import { SchedulerService } from '@sharpee/engine';

// NEW:
import { SchedulerService } from '@sharpee/plugin-scheduler';
```

**Story Orchestration Changes:**

`stories/dungeo/src/orchestration/index.ts`:
```typescript
import { SchedulerPlugin } from '@sharpee/plugin-scheduler';

export function initializeWorld(world: WorldModel, engine: GameEngine): void {
  // ... world setup ...

  // Register scheduler plugin
  const schedulerPlugin = new SchedulerPlugin();
  engine.getPluginRegistry().register(schedulerPlugin);

  // Initialize puzzle handlers with scheduler
  initializePuzzleHandlers(world, engine, schedulerPlugin.getScheduler());
}
```

`stories/dungeo/src/orchestration/puzzle-handlers.ts`:
```typescript
// NOW receives scheduler as parameter instead of calling engine.getScheduler()
export function initializePuzzleHandlers(
  world: WorldModel,
  engine: GameEngine,
  scheduler: SchedulerService
): void {
  // Use scheduler directly
}
```

### Core Type Changes

**`packages/core/src/types/save-data.ts`:**
```typescript
export interface IEngineState {
  playerId: string;
  turnCount: number;
  worldState: IWorldState;
  schedulerState?: ISchedulerState;  // DEPRECATED (Phase 2)
  pluginStates?: Record<string, unknown>; // NEW (Phase 2)
}
```

### Build System Updates

**`build.sh`:**
- Added `plugins` to PACKAGES array (after world-model)
- Added `plugin-scheduler` to PACKAGES array (after plugins)
- Dependency order: core → world-model → plugins → engine → plugin-scheduler → stdlib → stories

### Test Results

**Walkthrough Tests:**
- All 148 walkthrough tests PASS
- State persistence validated (save/restore with plugin states)
- Scheduler events (fuses, daemons) working correctly

**Unit Transcript Tests:**
- 78/79 PASS (1 pre-existing failure unrelated to plugin work)

## Key Decisions

### 1. Engine Owns SeededRandom Centrally

**Rationale:** Multiple plugins may need deterministic randomness (scheduler for event delays, combat for damage rolls, NPCs for behavior). Centralizing SeededRandom in the engine and passing it via TurnPluginContext ensures:
- Consistent save/restore of RNG state
- Plugins don't need separate random instances
- Replay/testing reliability

**Implication:** TurnPluginContext includes `random: SeededRandom` field.

### 2. Generic Plugin State Serialization

**Rationale:** Save/restore should not know about specific plugin types. Each plugin manages its own state via `getState()/setState()`.

**Implementation:**
```typescript
// PluginRegistry manages all plugin states
pluginStates: Record<string, unknown> = {
  'scheduler': { seed: 12345, events: [...] },
  'npc': { npcStates: [...] },
  'state-machine': { machines: [...] }
}
```

**Benefit:** Adding new plugins requires no changes to save/restore service.

### 3. NPC Block Stays Hardcoded (Phase 3 Deferred)

**Rationale:** Phase 2 focused on extracting scheduler as proof-of-concept. NPC extraction requires more refactoring (NPC entity lookup, turn logic, state management).

**Current State:** Engine still has hardcoded NPC block:
```typescript
// Execute NPC turns (HARDCODED - will be extracted in Phase 3)
const npcEntities = this.world.findEntitiesByTrait(NPCTrait.type);
for (const npc of npcEntities) {
  const behavior = this.world.findBehavior<NPCBehavior>(npc.id, NPCTrait.type);
  if (behavior && !npc.metadata.dead) {
    const npcEvents = await behavior.onNPCTurn(npc, this.world, this.playerId);
    // ... process NPC events ...
  }
}
```

**Phase 3 Plan:** Extract to `@sharpee/plugin-npc` with priority 100 (executes before scheduler).

### 4. Plugin Priority Convention

**Convention:**
- NPC Service: 100 (highest - affects world state before other systems)
- State Machine Service: 75 (medium-high - game state transitions)
- Scheduler Service: 50 (medium - time-based events)
- Custom Story Plugins: 0-49 (story-specific logic)

**Rationale:** Priority determines execution order. NPCs should act before scheduled events trigger, state machines should update before scheduler checks conditions.

### 5. Shared Event Processing Pipeline

**Decision:** Created `processPluginEvents(events)` method to handle all plugin-emitted events consistently.

**Pipeline:**
1. Enrich with metadata (turn number, timestamp)
2. Filter duplicates
3. Store in turn context
4. Emit to story event handlers

**Benefit:** All plugins get same event semantics, eliminating code duplication.

## Open Items

### Short Term

**Phase 3: Extract NPC Service to @sharpee/plugin-npc**
- Create `packages/plugin-npc/` package
- Move NPC turn logic from engine to NPCPlugin
- Priority: 100 (executes before scheduler)
- Update stories to register NPCPlugin
- Remove hardcoded NPC block from engine

**Phase 4: Build State Machine Plugin**
- Create `@sharpee/plugin-state-machine` package
- Implement StateMachinePlugin with priority 75
- Support fuse/daemon-like state transitions
- Replace ADR-119 proposal with plugin-based implementation

**Phase 5: Cleanup Engine**
- Remove all NPC-specific imports from engine
- Remove scheduler-specific imports from engine
- Verify engine has no domain logic (pure orchestration)
- Update engine documentation

### Long Term

**Future Plugin Opportunities:**
- Combat plugin (damage calculation, death handling)
- Light/darkness plugin (vision calculations)
- Ambient messaging plugin (randomized atmospheric descriptions)
- Hint system plugin (context-aware hints)
- Achievement tracking plugin

**Migration Path for Stories:**
- Stories currently depend on scheduler directly
- Future: Stories register plugins, query via PluginRegistry.getById()
- Benefit: Stories can override/replace plugins (custom scheduler, custom NPC logic)

## Files Modified

**New Packages** (2):
- `packages/plugins/` - Core plugin contract (4 files)
- `packages/plugin-scheduler/` - Scheduler service extracted (5 files)

**Engine Package** (4 files):
- `packages/engine/src/game-engine.ts` - Plugin registry, plugin loop, processPluginEvents
- `packages/engine/src/save-restore-service.ts` - Plugin state serialization
- `packages/engine/src/index.ts` - Export plugin types instead of scheduler
- `packages/engine/package.json`, `packages/engine/tsconfig.json` - Dependencies updated

**Core Package** (1 file):
- `packages/core/src/types/save-data.ts` - Added pluginStates field to IEngineState

**Dungeo Story** (26 files):
- `stories/dungeo/package.json`, `stories/dungeo/tsconfig.json` - Added plugin-scheduler dependency
- `stories/dungeo/src/orchestration/index.ts` - Register SchedulerPlugin
- `stories/dungeo/src/orchestration/puzzle-handlers.ts` - Receive scheduler as parameter
- 22 story files - Changed import paths from @sharpee/engine to @sharpee/plugin-scheduler

**Build System** (1 file):
- `build.sh` - Added plugins and plugin-scheduler to build order

**Total Modified:** 34 files
**Total Deleted:** 4 files (scheduler directory in engine)

## Architectural Notes

### Plugin System Design Strengths

**Decoupling:** Engine knows nothing about schedulers, NPCs, or state machines. It only knows the TurnPlugin interface.

**Extensibility:** Stories can register custom plugins for game-specific mechanics without touching platform code.

**Testability:** Plugins can be tested in isolation with mock TurnPluginContext. Engine tests don't need real scheduler/NPC logic.

**Serialization:** Generic plugin state map in save files means new plugins don't require save format changes.

### TurnPluginContext as Boundary

TurnPluginContext provides controlled access to engine internals:
- World model (read/write)
- Turn state (read-only)
- Player state (read-only)
- Random generator (shared state)
- Action results (optional - only for post-action plugins)

Plugins cannot:
- Manipulate engine lifecycle
- Access other plugins directly
- Control turn ordering

This maintains clean separation while allowing powerful plugin capabilities.

### Event Processing Consistency

Both engine's player action phase and plugin loop use the same event pipeline:
1. Action executes → returns effects
2. Engine enriches effects with metadata
3. Engine filters duplicates
4. Engine stores in turn context
5. Engine emits to story handlers

This ensures consistent event semantics whether events come from actions, NPCs, scheduler, or future plugins.

### State Persistence Pattern

Plugins implement:
```typescript
getState(): unknown {
  return { /* serializable state */ };
}

setState(state: unknown): void {
  this.internalService.restore(state as MyStateType);
}
```

PluginRegistry collects all states:
```typescript
getStates(): Record<string, unknown> {
  return Object.fromEntries(
    this.plugins.map(p => [p.id, p.getState()])
  );
}
```

Save file contains:
```json
{
  "pluginStates": {
    "scheduler": { "seed": 12345, "events": [] },
    "npc": { "npcStates": [] }
  }
}
```

Clean, extensible, no coupling between plugins.

## Notes

**Session duration**: ~4 hours

**Approach**: Incremental refactoring with continuous test validation. After Phase 1 (contract package), ran full test suite. After Phase 2 (scheduler extraction), validated all 148 walkthroughs and 79 unit transcripts. No breaking changes to game behavior - purely architectural improvement.

**Testing Strategy:** Used bundle testing (`node dist/sharpee.js --test`) for rapid iteration. Bundle loads in ~170ms vs 5+ seconds for package-based testing.

**Build Optimization:** Used `./build.sh --skip stdlib -s dungeo` to resume builds from stdlib, avoiding slow full rebuilds.

**Next Session:** Phase 3 will extract NPC service following the same pattern. Expect similar changes (create plugin-npc package, update engine to use plugin loop, update stories to register NPCPlugin).

---

**Progressive update**: Session completed 2026-01-28 11:50
