# Session Summary: 2026-02-08 - main (4:08 PM CST)

## Status: Completed

## Goals
- Investigate Phase 7 of thief-fight-plan: Troll Integration
- Diagnose why troll capability behaviors not dispatching at runtime
- Create implementation plan for Phase 7

## Completed

### Phase 7 Investigation: Capability Registry Cross-Module Bug

Investigated why troll's registered capability behaviors (TrollTakingBehavior, TrollAttackingBehavior, TrollTalkingBehavior) were not being invoked at runtime despite clean registration during story initialization.

#### 1. Symptoms

**Runtime stderr output**:
```
Universal dispatch: trait 'dungeo.trait.troll' claims 'if.action.attacking' but no behavior registered
Universal dispatch: trait 'dungeo.trait.troll' claims 'if.action.taking' but no behavior registered
Universal dispatch: trait 'dungeo.trait.troll' claims 'if.action.talking' but no behavior registered
```

**Test failures**:
- troll-interactions.transcript: 3 failures (TAKE TROLL, ATTACK TROLL with bare hands)
- troll-recovery.transcript: 5 failures (GDT KO interaction with melee state)
- Combined: 8 test failures out of 104 total tests

**What worked**:
- All interceptor behaviors (TrollMeleeInterceptor, guardians GDT/PTROLL, basket elevator)
- All other troll transcripts (combat, blocking, visibility)

#### 2. Root Cause Analysis

**The bug**: Module-level storage in capability-registry.ts vs globalThis in interceptor-registry.ts

**How it happens**:
1. CLI bundle (`dist/cli/sharpee.js`) compiles with `@sharpee/world-model` as a module
2. Story loads via `require(storyPath)` at runtime
3. Story gets its own instance of `@sharpee/world-model` module (separate from bundle's instance)
4. Story's `registerCapabilityBehavior()` writes to story's module-level `capabilityBehaviors` Map
5. Platform's `getBehaviorBinding()` reads from bundle's module-level `capabilityBehaviors` Map
6. Two different Maps, zero shared state

**Why interceptors work**:
```typescript
// interceptor-registry.ts (WORKS)
const registry = (globalThis as any).__sharpee_action_interceptors ||
  ((globalThis as any).__sharpee_action_interceptors = new Map());

// capability-registry.ts (BROKEN)
const capabilityBehaviors = new Map<string, Map<string, CapabilityBehavior>>();
```

`globalThis` is shared across all module instances. Module-level `const` is not.

**Affected systems**:
- All story capability behaviors: troll, basket elevator, egg (wind canary), any future ones
- Does NOT affect: interceptors (use globalThis), traits, regular actions, event handlers

#### 3. Solution Strategy

**Platform fix** (correct but requires discussion per CLAUDE.md):
```typescript
// capability-registry.ts
const registry = (globalThis as any).__sharpee_capability_behaviors ||
  ((globalThis as any).__sharpee_capability_behaviors = new Map());
```

**Story-level workaround** (chosen for now):
- Convert troll capability behaviors ‚Üí action interceptors
- Interceptors use globalThis, so they work across module boundaries
- Same 4-phase pattern (validate/execute/report/blocked)
- No platform changes required

**Decision**: Use story-level workaround and log platform bug as ISSUE-052 for future discussion.

**Rationale**: CLAUDE.md requires discussion before platform changes. Interceptors are functionally equivalent for troll's needs (blocking/augmenting standard actions). Can revisit platform fix after Phase 7 complete.

#### 4. Phase 7 Implementation Plan

Created comprehensive plan in `docs/work/dungeo/thief-phase-7-plan.md`:

**Phase 7.1: Convert Capability Behaviors to Interceptors**
- Convert TrollTakingBehavior ‚Üí TrollTakingInterceptor (blocks TAKE TROLL with "not yours" message)
- Convert TrollAttackingBehavior ‚Üí TrollUnarmedInterceptor (blocks unarmed ATTACK with "suicide" message)
- Convert TrollTalkingBehavior ‚Üí TrollTalkingInterceptor (blocks TALK TO TROLL with "deaf" message)
- Remove capability behavior registrations from troll initialization
- Register interceptors instead

**Phase 7.2: Clean Up TrollTrait Capabilities**
- Remove stale capability declarations from TrollTrait.capabilities array
- Fix ISSUE-051 (cosmetic stderr warning about unclaimed capabilities)

**Phase 7.3: Fix troll-recovery.transcript**
- Investigate why GDT KO + melee state interaction causes failures
- Player KO'd by GDT should set MeleeCombatantTrait.staggered=true and unconscious=true
- Verify troll doesn't attack while player is unconscious
- Verify player wakes up after unconscious countdown

**Phase 7.4: Verification Testing**
- Run all 5 troll transcripts: combat, interactions, blocking, recovery, visibility
- Target: 104 tests pass, 3 expected failures (no regressions)
- Run full walkthrough chain (216 pass / 6 skip)

**Phase 7.5: Log Platform Bug**
- Create ISSUE-052 in `docs/work/issues/issues-list-03.md`
- Document cross-module capability registry bug
- Propose globalThis solution for future platform fix

#### 5. Current Test Status (Before Phase 7)

**Passing transcripts**:
- troll-combat.transcript: 16 pass
- troll-blocking.transcript: 15 pass, 1 expected failure
- troll-visibility.transcript: 15 pass, 1 expected failure
- combat-disengagement.transcript: 19 pass

**Failing transcripts**:
- troll-interactions.transcript: 15 pass, 3 fail (TAKE TROLL, unarmed ATTACK)
- troll-recovery.transcript: 13 pass, 5 fail (GDT KO + melee state)

**Total**: 93 pass, 8 fail, 3 expected failures (out of 104 tests)

## Key Decisions

### 1. Use Story-Level Workaround Instead of Platform Fix

**Decision**: Convert troll capability behaviors to action interceptors rather than fixing capability-registry.ts to use globalThis.

**Rationale**:
- CLAUDE.md requires discussion before platform changes
- Interceptors use globalThis (already works across module boundaries)
- Functionally equivalent for troll's needs (all three behaviors are "block action with custom message")
- Can revisit platform fix after Phase 7 complete (log as ISSUE-052)

**Trade-off**: Story workaround doesn't fix the underlying bug. Any future story that needs capability behaviors will hit the same issue. But it unblocks Phase 7 without requiring platform discussion.

### 2. Keep Capability Behaviors for Basket Elevator and Egg

**Decision**: Only convert troll behaviors to interceptors. Leave basket elevator (LOWER/RAISE) and egg (WIND) as capability behaviors.

**Rationale**:
- Basket and egg are registered during world initialization (before story module split)
- They work correctly in current codebase
- No need to refactor working code
- Scope creep to convert everything would delay Phase 7

**Note**: This decision may need revisiting if we discover basket/egg have the same bug in a different loading scenario.

### 3. Fix troll-recovery.transcript in Phase 7

**Decision**: Include troll-recovery.transcript fix in Phase 7 scope (not defer to Phase 8).

**Rationale**:
- Test failures are related to melee system (GDT KO + unconscious state)
- Troll integration must verify melee system works for all guardians (GDT, PTROLL, troll)
- Better to fix now while context is fresh than come back later
- Only 5 failing tests (manageable scope)

### 4. Log Platform Bug but Don't Fix It

**Decision**: Document capability registry bug as ISSUE-052, but don't implement platform fix in this session.

**Rationale**:
- Platform changes require user discussion (per CLAUDE.md)
- Story workaround unblocks Phase 7
- Bug documentation preserves investigation findings for future work
- User can decide when/if to apply platform fix

## Open Items

### Short Term

**Phase 7 Implementation** (next session)
- Execute thief-phase-7-plan.md (5 sub-phases)
- Convert 3 capability behaviors ‚Üí interceptors
- Clean up TrollTrait.capabilities (ISSUE-051)
- Fix troll-recovery.transcript (GDT KO + melee state)
- Verify all troll transcripts pass (104 tests, 3 expected failures)

**ISSUE-052: Capability Registry Cross-Module Bug**
- Not yet logged in issues-list-03.md
- Platform fix: Change capability-registry.ts to use globalThis (like interceptor-registry.ts)
- Scope: Affects all story capability behaviors registered after bundle load
- Requires user discussion per CLAUDE.md

### Long Term

**Capability System Design Review**
- Should capability behaviors exist at all, or just use interceptors?
- Interceptors handle "augment/block standard action" pattern well
- Capability behaviors were designed for entity-specific semantics (LOWER basket vs LOWER pole)
- Is the distinction worth the complexity?

**Module Loading Architecture**
- Why does story get separate module instance of world-model?
- Could we use `require.cache` to force module sharing?
- Would this break other things (story isolation, testing)?

**Combat-Disengagement Flakiness** (pre-existing)
- Troll can be one-shot killed by sword (DEF1 table with ATT=2)
- Test passes 60%, fails 40%
- Options: Add WHILE loop, increase OSTRENGTH, or accept flakiness
- Not blocking Phase 7

## Files Created

**Phase 7 plan**:
- `docs/work/dungeo/thief-phase-7-plan.md` ‚Äî Detailed implementation plan (5 sub-phases)

**No code changes made** ‚Äî Investigation and planning session only.

## Architectural Notes

### Cross-Module State Sharing Patterns

This bug revealed two different patterns for sharing state between platform and story modules:

**Pattern 1: globalThis (interceptor-registry.ts)**
```typescript
const registry = (globalThis as any).__sharpee_action_interceptors ||
  ((globalThis as any).__sharpee_action_interceptors = new Map());
```

**Pros**:
- Works across module instances (story gets same Map as platform)
- Simple fallback initialization pattern
- Used by V8 for built-in globals

**Cons**:
- Pollutes global namespace (could conflict with other code)
- No type safety (cast to `any`)
- Hard to test in isolation (global state)

**Pattern 2: Module-level const (capability-registry.ts)**
```typescript
const capabilityBehaviors = new Map<string, Map<string, CapabilityBehavior>>();
```

**Pros**:
- Clean module encapsulation (no global pollution)
- Type-safe (no `any` casts)
- Easy to test (import module, call functions)

**Cons**:
- Breaks when story loaded as separate module instance
- Each module instance gets its own Map
- Silent failure (no error, just empty Map lookups)

### CLI Bundle Module Loading

The CLI bundle uses different loading strategies for platform vs story:

**Platform code** (engine, stdlib, world-model):
- Compiled into bundle by esbuild
- All platform packages share same module instances
- Cross-references (engine ‚Üí world-model) work correctly

**Story code** (stories/dungeo):
- Loaded at runtime via `require(storyPath)`
- Gets fresh module instances for all dependencies
- Story's `@sharpee/world-model` ‚â† bundle's `@sharpee/world-model`

**Why this happens**: esbuild bundles platform code into single file, but story is loaded dynamically to support different stories without recompiling.

**Implications**:
- Any state shared between platform and story must use globalThis or similar
- Module-level state (const, static) is NOT shared
- This affects: registries, caches, singletons

### When to Use Capability Behaviors vs Interceptors

Before this bug, the distinction was:

**Capability behaviors**: Entity-specific semantics (LOWER basket ‚â† LOWER pole)
**Interceptors**: Augment/block standard actions (all entities)

After this bug, the distinction is:

**Interceptors**: Anything that needs to work when registered by story code
**Capability behaviors**: Only use if registered during platform initialization

This may argue for deprecating capability behaviors entirely and using interceptors for everything.

### Alternative Solutions Considered

**Option A: Fix capability-registry.ts** (correct, requires discussion)
```typescript
const registry = (globalThis as any).__sharpee_capability_behaviors ||
  ((globalThis as any).__sharpee_capability_behaviors = new Map());
```

**Option B: Force module sharing** (risky)
```typescript
// In CLI bundle loader
const worldModel = require('@sharpee/world-model');
require.cache['@sharpee/world-model'] = worldModel;
// Now story's require() gets same instance
```

**Option C: Story interceptors** (chosen)
```typescript
// Convert TrollTakingBehavior ‚Üí TrollTakingInterceptor
// Use interceptor registry (already uses globalThis)
```

**Option D: Abandon dynamic story loading** (nuclear)
```typescript
// Compile story into bundle at build time
// Loses ability to load different stories without recompiling
```

## Thief Fight Plan Progress

| Phase | Status | Description |
|-------|--------|-------------|
| Phase 1 | ‚úÖ COMPLETE | Canonical melee engine (OSTRENGTH tables, stagger, unconscious, wounds) |
| Phase 2 | ‚úÖ COMPLETE | Melee messages (villain attacks, stagger, unconscious, death) |
| Phase 3 | ‚úÖ COMPLETE | Melee interceptor (attack action integration, turn-by-turn combat) |
| Phase 4 | ‚úÖ COMPLETE | Disengagement + healing (flee-and-recover, CURE-CLOCK daemon) |
| Phase 5 | ‚úÖ COMPLETE | Thief behavior (WINNING? function, engrossed flag, fight/flee AI) |
| Phase 6 | ‚úÖ COMPLETE | DIAGNOSE command verification (canonical text, CLI/browser parity) |
| Phase 7 | üîç INVESTIGATING | Troll integration (capability bug found, plan created) |

## Notes

**Session duration**: ~30 minutes

**Approach**: Investigation and planning session. Started with "why aren't troll capability behaviors dispatching?", traced through registration ‚Üí lookup ‚Üí dispatch pipeline, found cross-module bug (story registers to different Map than platform reads from), compared with working interceptor registry (uses globalThis), decided on story-level workaround (convert to interceptors), documented platform fix as ISSUE-052, created detailed 5-phase implementation plan.

**Platform Changes**: Zero. Bug discovered but not fixed (requires discussion per CLAUDE.md). Story workaround will use existing interceptor system.

**Build Performance**: Not measured (no code changes).

**Next Steps**: Execute thief-phase-7-plan.md in next session. Should be straightforward refactoring (behaviors ‚Üí interceptors are same 4-phase pattern). Main unknown is troll-recovery.transcript failures (GDT KO + melee state interaction).

**Key Insight**: Any state shared between platform and story code must use globalThis (or similar cross-module mechanism), not module-level `const`. Module-level state breaks when story loaded dynamically because story gets separate module instances. This is a fundamental constraint of the CLI's dynamic story loading architecture.

---

**Progressive update**: Session completed 2026-02-08 4:08 PM CST
