# Session Summary: 2026-02-08 - main (5:37 PM CST)

## Status: Completed

## Goals
- Execute Phase 7 of thief-fight-plan: Convert troll capability behaviors to interceptors
- Fix troll-interactions.transcript (3 failures)
- Fix troll-recovery.transcript (5 failures)
- Verify all troll transcripts pass (target: 104 tests, 3 expected failures)
- Log ISSUE-052 for capability registry bug

## Completed

### Phase 7.1-7.2: Troll Interceptor Conversion (COMPLETE)

Converted all three troll capability behaviors to action interceptors, resolving the cross-module registry bug discovered in session-20260208-1608-main.md.

**What was done**:
- Rewrote `troll-capability-behaviors.ts` with three interceptors:
  - `TrollTakingInterceptor` — blocks TAKE TROLL with "not yours" message
  - `TrollAttackingInterceptor` — composite interceptor handling unarmed (blocks with "suicide" mock) and armed (delegates to MeleeInterceptor)
  - `TrollTalkingInterceptor` — blocks TALK TO TROLL with "deaf" message
- Removed `static readonly capabilities` array from TrollTrait (fixes ISSUE-051 cosmetic warning)
- Changed registration in `index.ts`: `registerCapabilityBehavior()` → `registerActionInterceptor()`
- Registered all three interceptors at priority 100 (wins over CombatantTrait's MeleeInterceptor at priority 0)

**Design decisions**:
- TrollAttackingInterceptor is a composite that checks weapon presence and either blocks (unarmed) or delegates (armed)
- Armed attacks delegate to MeleeInterceptor using `getInterceptorForAction(trollId, 'if.action.attacking')` lookup
- Higher priority (100) ensures troll's unarmed check runs before melee system processes the attack
- Custom `onBlocked` handlers for TrollTakingInterceptor and TrollAttackingInterceptor to avoid `if.action.attacking.dungeo.troll.suicide` message ID prefix bug (attacking action prepends action ID to error messages)

**Result**: troll-interactions.transcript now 18 pass, 1 expected failure (down from 3 failures)

### Phase 7.3: Fix troll-recovery.transcript (COMPLETE)

Debugged and fixed 5 failing tests in troll-recovery.transcript. Root cause was two-fold.

#### Root Cause 1: GDT Commands Consume Game Turns

**The problem**: Player uses `$gdt ko` to knock themselves out, then `$gdt ex` to examine melee state. Both commands count as game turns, consuming daemon ticks. With `TROLL_RECOVERY_TURNS=2`, the KO and EX commands consumed both recovery ticks, causing the troll to wake up immediately.

**Evidence from logs**:
```
[16:55:19] [DAEMON] Troll recovery check: DOFPZ1 (troll) - tick 1/2
  Player KO'd themselves with GDT - skipping attack
[16:55:19] [DAEMON] Troll recovery check: DOFPZ1 (troll) - tick 2/2 - WAKING UP
```

**Fix**: Increased `TROLL_RECOVERY_TURNS` from 2 to 4 in `underground.ts`. Original MDL source shows `<TURNS 5>` for troll recovery, so 4 is still conservative.

#### Root Cause 2: NpcTrait.isConscious Not Synced with CombatantTrait.isConscious

**The problem**: When player is knocked out by GDT, the KO command only sets `CombatantTrait.isConscious = false`. But the troll recovery daemon checks `NpcTrait.isConscious` to determine if the troll should attack. The two traits have separate `isConscious` states that were not synced.

**Fix**: Added NpcTrait sync in two places:
1. `knocked_out` event handler in `underground.ts` — when player is knocked out, sync NpcTrait.isConscious
2. `wakeUp()` function in `troll-daemon.ts` — when troll wakes up, sync NpcTrait.isConscious

**Code changes**:
```typescript
// underground.ts knocked_out handler
if (player.hasTrait(NpcTrait.type)) {
  const npcTrait = player.getTrait(NpcTrait.type);
  npcTrait.isConscious = false;
}

// troll-daemon.ts wakeUp()
if (troll.hasTrait(NpcTrait.type)) {
  const npcTrait = troll.getTrait(NpcTrait.type);
  npcTrait.isConscious = true;
}
```

**Result**: troll-recovery.transcript now 18 pass, 0 failures (down from 5 failures)

### Phase 7.4: Verification Testing (COMPLETE)

Ran all troll transcripts and full walkthrough chain.

**Troll transcripts** (104 tests, 3 expected failures):
- troll-interactions.transcript: 18 pass, 1 expected failure ✅
- troll-recovery.transcript: 18 pass ✅
- troll-combat.transcript: 16 pass ✅
- troll-visibility.transcript: 15 pass, 1 expected failure ✅
- troll-blocking.transcript: 15 pass, 1 expected failure ✅
- combat-disengagement.transcript: 19 pass ✅

**Full walkthrough chain**: 216 pass, 6 skip ✅

**Zero regressions**. All tests passing.

### Phase 7.5: Platform Bug Documentation (COMPLETE)

**Logged ISSUE-052** in `docs/work/issues/issues-list-03.md`:
- Title: "Capability registry uses module-level Map (broken) instead of globalThis (works)"
- Root cause: `capability-registry.ts` uses `const capabilityBehaviors = new Map()` while `interceptor-registry.ts` uses `globalThis.__sharpee_action_interceptors`
- Impact: Story-registered capability behaviors not visible to platform dispatch (separate module instances)
- Proposed fix: Change capability-registry.ts to use globalThis pattern (like interceptor-registry.ts)
- Status: Workaround implemented (troll uses interceptors), platform fix deferred pending discussion

**Updated ISSUE-051** status to FIXED:
- Stale `TrollTrait.capabilities` array removed
- No longer emits "trait claims capability but none registered" stderr warning

## Key Decisions

### 1. Use Composite Interceptor for Troll Attacking

**Decision**: TrollAttackingInterceptor is a composite that checks weapon presence and delegates to MeleeInterceptor for armed attacks.

**Rationale**:
- Troll needs two behaviors: block unarmed ATTACK (suicide message), allow armed ATTACK (melee combat)
- Can't use capability behaviors (cross-module bug)
- Can't register two interceptors for same action (getInterceptorForAction returns only highest priority)
- Composite pattern: one interceptor that switches behavior based on game state

**Implementation**:
```typescript
const TrollAttackingInterceptor: ActionInterceptor = {
  priority: 100,
  shouldIntercept: (entity, world, actorId) => entity.hasTrait(TrollTrait.type),
  onBlocked: (entity, world, actorId, error) => /* custom blocked handler */,
  execute: (entity, world, actorId, sharedData, next) => {
    const weapon = findPlayerWeapon(world, actorId);
    if (!weapon) {
      // Unarmed attack - block with suicide message
      return { blocked: { reason: 'dungeo.troll.suicide', messageId: 'dungeo.troll.suicide' } };
    }
    // Armed attack - delegate to melee system
    const meleeInterceptor = getInterceptorForAction(entity.id, 'if.action.attacking');
    return meleeInterceptor.execute(entity, world, actorId, sharedData, next);
  },
};
```

**Trade-off**: More complex interceptor code, but avoids need for multiple interceptors per action or capability behavior workarounds.

### 2. Increase TROLL_RECOVERY_TURNS from 2 to 4

**Decision**: Changed troll unconscious recovery from 2 turns to 4 turns.

**Rationale**:
- Original MDL source shows `<TURNS 5>` for troll recovery
- GDT commands count as game turns (KO + EX = 2 turns consumed)
- With TROLL_RECOVERY_TURNS=2, troll woke up immediately after GDT commands
- 4 turns gives reasonable buffer for testing while staying close to canonical 5

**Evidence from MDL source** (`docs/dungeon-81/mdlzork_810722/1actions.mud`):
```
<ROUTINE TROLL-MELEE ("AUX" (PROB 0) ATK)
   ...
   <COND (<NOT <FSET? ,TROLL ,FIGHTBIT>>
          <FCLEAR ,TROLL ,INVISIBLE>
          <TELL
"The troll, recovering from his recent misfortune, scrambles to his feet." CR>
          <CLOCK-DISABLE <CLOCK-INT ,TROLL-CLOCK>>
          <TURNS 5>)>>  ; <--- CANONICAL RECOVERY TIME
```

**Alternative considered**: Use WHILE loops in transcript to wait for recovery. Rejected because GDT commands already advance turn counter, and increasing recovery turns is more canonical.

### 3. Sync NpcTrait.isConscious with CombatantTrait.isConscious

**Decision**: Added explicit sync between NpcTrait and CombatantTrait consciousness states.

**Rationale**:
- Two traits both track consciousness for different purposes
- CombatantTrait: Melee combat eligibility (can be attacked/attack)
- NpcTrait: NPC behavior eligibility (should NPC take turn)
- Setting one doesn't automatically update the other
- Troll daemon checks NpcTrait to decide if troll should attack
- Player KO only set CombatantTrait, leaving NpcTrait.isConscious=true

**Why not use single trait**: CombatantTrait is in world-model (platform), NpcTrait is in engine (platform). Both are general-purpose systems that don't know about each other. Story code must sync them.

**Alternative considered**: Make NpcTrait.isConscious a computed property that reads from CombatantTrait. Rejected because not all NPCs are combatants (breaking change to engine).

### 4. Custom onBlocked Handlers for Interceptors

**Decision**: TrollTakingInterceptor and TrollAttackingInterceptor both define custom `onBlocked` handlers.

**Rationale**:
- Attacking action's default `blocked()` handler prepends `${context.action.id}.` to error messages
- Results in message IDs like `if.action.attacking.dungeo.troll.suicide` (unresolvable)
- Custom onBlocked handler returns direct message ID without prefix

**Implementation**:
```typescript
onBlocked: (entity, world, actorId, error) => {
  return { messages: [{ id: error.messageId, args: {} }] };
},
```

**Bug filed**: This is a platform issue (attacking action shouldn't prepend action ID to interceptor-provided message IDs), but fixing it would require platform changes. Story workaround is simpler.

## Open Items

### Short Term

**Phase 7 Complete** ✅
- All 5 sub-phases executed successfully
- All troll transcripts passing (104 tests, 3 expected failures)
- Full walkthrough chain passing (216 pass, 6 skip)
- Platform bug logged as ISSUE-052
- ISSUE-051 marked as fixed

**Ready for Phase 8** (next session)
- Thief NPC integration with melee system
- Thief fight/flee AI verification
- Thief treasure theft mechanics
- Thief combat transcripts

### Long Term

**ISSUE-052: Capability Registry Cross-Module Bug** (logged, not fixed)
- Platform fix: Change capability-registry.ts to use globalThis
- Requires user discussion per CLAUDE.md
- Story workaround (interceptors) unblocks all current work

**Capability System Design Review**
- Should capability behaviors exist, or just use interceptors for everything?
- Interceptors handle "entity-specific action semantics" pattern equally well
- Capability behaviors only add value if registered during platform initialization
- Consider deprecating capability behaviors in favor of interceptor-only model

**Combat System Enhancements** (post-Phase 8)
- Multi-combatant scenarios (player vs troll + thief)
- Combatant targeting (which villain to attack when multiple present)
- Area-of-effect weapons (blast all combatants in room)

**NpcTrait / CombatantTrait Sync** (architectural debt)
- Two separate consciousness states that must be manually synced
- Should consciousness be a shared concept?
- Should CombatantTrait extend NpcTrait (or vice versa)?
- Refactoring would affect engine + world-model (platform change)

## Files Modified

**Troll interceptors** (3 files):
- `stories/dungeo/src/traits/troll-capability-behaviors.ts` — Complete rewrite: capability behaviors → interceptors
- `stories/dungeo/src/traits/troll-trait.ts` — Removed `static readonly capabilities` array
- `stories/dungeo/src/traits/index.ts` — Updated exports (no functional change)

**Registration** (1 file):
- `stories/dungeo/src/index.ts` — Changed from `registerCapabilityBehavior()` to `registerActionInterceptor()` for all three troll interceptors

**Troll recovery** (2 files):
- `stories/dungeo/src/regions/underground.ts` — TROLL_RECOVERY_TURNS=4, added NpcTrait sync in knocked_out handler
- `stories/dungeo/src/scheduler/troll-daemon.ts` — Added NpcTrait sync in wakeUp(), added NpcTrait import

**Test transcripts** (2 files):
- `stories/dungeo/tests/transcripts/troll-interactions.transcript` — Fixed event type assertions (`action.blocked` → `if.event.take_blocked` / `if.event.attacked`)
- `stories/dungeo/tests/transcripts/troll-recovery.transcript` — Updated assertions for 4-tick recovery

**GDT debug** (1 file):
- `stories/dungeo/src/actions/gdt/commands/ko.ts` — Cleaned up debug output (removed verbose logging)

**Documentation** (1 file):
- `docs/work/issues/issues-list-03.md` — Added ISSUE-052, updated ISSUE-051 status to FIXED

## Architectural Notes

### Action Interceptor Priority System

Discovered that `getInterceptorForAction()` returns only ONE interceptor per entity+action pair (highest priority wins). This has implications for interceptor design.

**Example**: Troll has two interceptors registered for `if.action.attacking`:
1. TrollAttackingInterceptor (priority 100) — troll-specific unarmed check + melee delegation
2. MeleeInterceptor (priority 0) — generic melee combat (from CombatantTrait)

When player ATTACKs troll, only TrollAttackingInterceptor executes (priority 100 > 0).

**Implications**:
- Can't register multiple interceptors for same action and expect both to run
- Higher priority interceptor is responsible for delegating to lower priority if needed
- Composite pattern required for "check condition, then delegate" scenarios

**Delegation pattern**:
```typescript
// In high-priority interceptor
const lowerPriorityInterceptor = getInterceptorForAction(entityId, actionId);
return lowerPriorityInterceptor.execute(entity, world, actorId, sharedData, next);
```

**Alternative considered**: Chain of responsibility (all interceptors run in priority order). Rejected because it would require platform changes and unclear use case beyond troll.

### GDT Commands and Turn Advancement

Discovered that GDT (Game Development Toolkit) commands count as full game turns, advancing:
- Scheduler daemon ticks (CURE-CLOCK, troll recovery, carousel rotation)
- Turn counter (for scoring, time-based events)
- NPC behavior phases (if NPCs are conscious)

**Example**: `$gdt ko` → `$gdt ex` consumes 2 turns:
```
[DAEMON] Troll recovery check: tick 1/2
[DAEMON] Troll recovery check: tick 2/2 - WAKING UP
```

**Implications**:
- Test transcripts using GDT must account for turn consumption
- WHILE loops in transcripts may need adjustment (each iteration = N turns)
- Recovery timers must be generous enough to allow GDT debugging

**Why GDT commands are turns**: They use the same command processing pipeline as player commands. The engine doesn't distinguish between player input and GDT input, so both advance the turn counter.

**Alternative considered**: Make GDT commands "free" (don't advance turn). Rejected because:
1. Requires platform changes (command execution pipeline)
2. Would break debugging scenarios (can't observe daemon ticks)
3. Would create inconsistency (some commands advance turn, others don't)

### NpcTrait vs CombatantTrait Consciousness

Discovered that two traits track consciousness separately:

**NpcTrait** (engine):
- `isConscious: boolean` — Whether NPC should take turns
- Used by scheduler to determine if NPC behavior should run
- Used by melee daemons to check if villains should attack

**CombatantTrait** (world-model):
- `isConscious: boolean` — Whether entity can participate in combat
- Set by melee system when entity is knocked out or wakes up
- Used by melee interceptor to validate attack targets

**The sync problem**: Setting one doesn't update the other. Melee system sets CombatantTrait, but troll daemon reads NpcTrait.

**Current solution**: Manual sync in knocked_out handler and wakeUp() function.

**Long-term solution candidates**:
1. **Shared consciousness**: Single trait or service that both read from
2. **Trait composition**: CombatantTrait extends NpcTrait (or vice versa)
3. **Event-driven sync**: knocked_out event handler syncs all consciousness-tracking traits
4. **Computed property**: NpcTrait.isConscious reads from CombatantTrait.isConscious

All require platform changes (engine + world-model). Current manual sync is acceptable for now.

### Attacking Action's Blocked Handler Message ID Bug

Discovered that attacking action's `blocked()` handler prepends action ID to error messages:

```typescript
// packages/stdlib/src/actions/standard/attacking/attacking.ts
blocked(context, result) {
  if (result.blocked) {
    return {
      effects: [{
        type: 'message',
        messageId: `${context.action.id}.${result.blocked.messageId}`,  // <-- BUG
        args: result.blocked.args || {},
      }],
    };
  }
}
```

**Impact**: Interceptor returns `{ blocked: { messageId: 'dungeo.troll.suicide' } }`, but platform emits message ID `if.action.attacking.dungeo.troll.suicide` (unresolvable).

**Workaround**: Custom `onBlocked` handler in interceptor:
```typescript
onBlocked: (entity, world, actorId, error) => {
  return { messages: [{ id: error.messageId, args: {} }] };
},
```

**Root cause**: Attacking action assumes all blocked messages are stdlib messages (e.g., `if.action.attacking.no_weapon`). Doesn't account for interceptor-provided message IDs.

**Fix candidates**:
1. Don't prepend action ID if message ID already contains a dot
2. Add `skipPrefix: boolean` flag to blocked result
3. Interceptors should return full effects, not just error data

All require platform changes. Story workaround (custom onBlocked) is simpler for now.

### Test Transcript Event Type Assertions

Fixed incorrect event type assertions in troll-interactions.transcript:

**Before** (incorrect):
```
ATTACK TROLL
  [EXPECTS: event "action.blocked" "dungeo.troll.suicide"]
```

**After** (correct):
```
ATTACK TROLL
  [EXPECTS: event "if.event.attacked" entity "TROLL" attacker entity "PLAYER"]
```

**Lesson**: Blocked actions still emit `if.event.attacked` (action executed but interceptor blocked it). `action.blocked` is not an event type, just a validation result.

**Correct event types**:
- `if.event.take_blocked` — Taking action blocked (e.g., TAKE TROLL)
- `if.event.attacked` — Attacking action executed (may succeed or be blocked)
- `if.event.talked` — Talking action executed (may succeed or be blocked)

### ISSUE-051 vs ISSUE-052 Distinction

**ISSUE-051** (cosmetic, FIXED):
- TrollTrait declared `static readonly capabilities` array but capabilities were registered as interceptors
- Platform emitted stderr warning: "trait claims capability but none registered"
- Fix: Remove capabilities array from TrollTrait
- No functional impact (just noisy logs)

**ISSUE-052** (functional, WORKAROUND):
- capability-registry.ts uses module-level Map (not shared across require() boundaries)
- Story-registered capabilities not visible to platform dispatch
- Fix: Convert to interceptors (use globalThis registry), or fix platform (change capability-registry to use globalThis)
- Functional impact: Capability behaviors don't work when registered by story code

## Thief Fight Plan Progress

| Phase | Status | Description |
|-------|--------|-------------|
| Phase 1 | ✅ COMPLETE | Canonical melee engine (OSTRENGTH tables, stagger, unconscious, wounds) |
| Phase 2 | ✅ COMPLETE | Melee messages (villain attacks, stagger, unconscious, death) |
| Phase 3 | ✅ COMPLETE | Melee interceptor (attack action integration, turn-by-turn combat) |
| Phase 4 | ✅ COMPLETE | Disengagement + healing (flee-and-recover, CURE-CLOCK daemon) |
| Phase 5 | ✅ COMPLETE | Thief behavior (WINNING? function, engrossed flag, fight/flee AI) |
| Phase 6 | ✅ COMPLETE | DIAGNOSE command verification (canonical text, CLI/browser parity) |
| Phase 7 | ✅ COMPLETE | Troll integration (capability→interceptor, recovery fix, all tests pass) |

**Next**: Phase 8 - Thief Integration (melee + treasure theft)

## Notes

**Session duration**: ~90 minutes

**Approach**: Implementation session. Started with Phase 7.1 (convert capability behaviors to interceptors), discovered composite interceptor pattern for troll attacking, fixed troll-interactions.transcript event assertions, debugged troll-recovery.transcript (GDT turn consumption + NpcTrait sync), ran full verification suite, logged ISSUE-052, marked ISSUE-051 as fixed.

**Platform Changes**: Zero. Bug workaround (interceptors) instead of platform fix (globalThis registry). Logged ISSUE-052 for future discussion.

**Build Performance**: Not measured (no build.sh run, only transcript testing).

**Test Results**:
- Before Phase 7: 93 pass, 8 fail, 3 expected failures (out of 104 troll tests)
- After Phase 7: 101 pass, 0 fail, 3 expected failures (out of 104 troll tests)
- Full walkthrough chain: 216 pass, 6 skip (no regressions)

**Key Insight**: Action interceptor priority system supports only ONE interceptor per entity+action. High-priority interceptors must delegate to lower-priority interceptors if needed (composite pattern). This is a fundamental constraint of the interceptor system design.

**Success Criteria Met**:
- ✅ All troll capability behaviors converted to interceptors
- ✅ TrollTrait.capabilities array removed (ISSUE-051 fixed)
- ✅ troll-interactions.transcript passing (18 pass, 1 expected failure)
- ✅ troll-recovery.transcript passing (18 pass, 0 failures)
- ✅ All troll transcripts passing (104 tests, 3 expected failures)
- ✅ Full walkthrough chain passing (216 pass, 6 skip)
- ✅ ISSUE-052 logged for capability registry bug

**Ready for Phase 8**: Thief melee integration, fight/flee AI verification, treasure theft mechanics.

---

**Progressive update**: Session completed 2026-02-08 5:37 PM CST
