# Session Summary: 2026-01-29 — main

## Status: Completed

## Goals

1. Execute ADR-123 undo plan: revert typed daemon hierarchy, preserve serialization infrastructure
2. Implement Zifmia Phase 1: produce `.sharpee` story bundle format with build tooling
3. Design Zifmia Phase 2: story loader and module resolution strategy

## Completed

### 1. ADR-123 Undo Plan Execution

**Reverted the typed daemon class hierarchy (5 base classes, 6 daemon migrations) back to factory functions.**

The class hierarchy (`DaemonRunner`, `WatchdogDaemon`, `LocationDaemon`, `AmbienceDaemon`, `CountdownDaemon`) was over-engineering. Each daemon in the Dungeo story is quirky enough that base classes provided minimal reuse benefit. Factory functions are simpler, equally clear, and avoid unnecessary inheritance.

**Preserved the genuinely useful serialization infrastructure:**
- `getRunnerState?()` and `restoreRunnerState?(state)` hooks on the `Daemon` interface
- `DaemonState.runnerState?: Record<string, unknown>` in scheduler state
- `SchedulerService.getState()` and `setState()` capturing/restoring daemon internal state

**Migration details:**
- Deleted all 5 base class files from `packages/plugin-scheduler/src/daemons/`
- Reverted 6 daemon factory files in `stories/dungeo/src/` (handlers and schedulers) to pre-ADR-123 state
- Added serialization hook to `sword-glow-daemon.ts` to preserve `currentGlowLevel` across save/load (only daemon needing this — others track state via world metadata already)
- Updated `ADR-123` status to **PARTIALLY ACCEPTED**: serialization infrastructure adopted, class hierarchy rejected as unnecessary

**Test results:** 148/148 walkthroughs passed with all reversions

**Commit:** `55d726a` (revert: Remove ADR-123 daemon class hierarchy, keep serialization)

### 2. Zifmia Phase 1 — Story Bundle Format

**Added `--story-bundle` / `-b` flag to `build.sh` to produce `.sharpee` zip files.**

The Zifmia story runner needs a portable bundle format for distributing stories. Phase 1 defines the format and implements build tooling to produce it.

**Bundle structure:**
```
dungeo.sharpee (zip archive)
├── story.js          # Bundled story code (esbuild with @sharpee/* as externals)
└── meta.json         # Story metadata (title, author, version, sharpeeVersion, ifid, etc.)
```

**Implementation details:**
- `build.sh` enhancement adds bundle build logic after standard story compilation
- Uses esbuild to bundle story code with all `@sharpee/*` platform packages marked as **external** dependencies (not inlined)
- `meta.json` generated from story's `package.json` `sharpee` section and build-time metadata
- Bundle compressed with zip; output: `dist/stories/{name}.sharpee`
- Size for dungeo: **172KB**

**What the flag does:**
```bash
./build.sh --story-bundle -s dungeo
./build.sh -b -s dungeo                    # Short form

# Produces:
# - dist/stories/dungeo.sharpee (172KB)
# - dist/stories/meta.json (metadata used during bundle creation)
```

**Key decisions:**
- Bundle from story **source code** (`src/index.ts`), not compiled dist, so esbuild produces true ES module imports for externals (not pre-bundled)
- `meta.json` fields include: `format`, `formatVersion`, `title`, `author`, `version`, `description`, `sharpeeVersion`, `ifid`, `hasAssets`, `hasTheme`
- Asset/theme packaging prepared but not yet implemented (Phase 1.3)

**Updated documentation:**
- Added daemon serialization note to `docs/work/zifmia/implementation-plan.md` (Phases 1-3 unaffected by ADR-123 changes; Phase 3 `StorageProvider` carries daemon state transparently)

**Commit:** `825ef57` (feat: Zifmia Phase 1 — .sharpee story bundle format)

### 3. Zifmia Phase 2 Design (Planned, Not Implemented)

**Designed Phase 2: Story Loader and Runtime Module Resolution**

Phase 2 covers how Zifmia loads and executes `.sharpee` bundles at runtime. Design completed but implementation deferred due to context limits.

**Phase 2 components:**

1. **Bundle Extractor** (2.1)
   - Unzip `.sharpee` in-memory (browser: fflate library; Tauri: native fs)
   - Parse and validate `meta.json` metadata
   - Extract `story.js` as blob/module URL for dynamic import

2. **Dynamic Story Import** (2.2)
   - Load `story.js` via dynamic `import()` (blob URL in browser, temp file in Tauri)
   - Validate exported `story` object shape before proceeding
   - Error handling for invalid/incompatible bundles

3. **Module Resolution & Platform Provider** (2.3)
   - **CRITICAL DECISION: Use ES module importmap**
   - Story code references `@sharpee/*` packages as imports
   - Runner bundles all platform packages (`@sharpee/engine`, `@sharpee/stdlib`, etc.) in a separate sharpee.js file
   - Browser HTML provides `<script type="importmap">` that maps `@sharpee/*` to runner-provided modules
   - Alternative considered (global namespace shim) rejected — importmap is cleaner, standard approach
   - No changes to story source code needed — bundles use normal ES imports

4. **Asset Serving** (2.4)
   - Extract `assets/` directory to temporary location or memory blob URLs
   - Create `resolveAsset(path)` helper that story code can call
   - Wire into illustration rendering (Phase 4)

**Phase 2 key decision:** Bundle story **from source code**, not dist/index.js, so that esbuild produces true ES module imports for `@sharpee/*` packages that can be resolved by the importmap. This is critical for the approach to work cleanly.

**Deliverable:** `<ZifmiaRunner bundleUrl="dungeo.sharpee" />` component loads, extracts, and executes stories.

**Planning location:** Design notes in user's local plan store (`.claude/plans/glittery-wobbling-firefly.md`) — approved by user but not in repo.

## Key Decisions

### 1. ADR-123 Serialization Infrastructure Valuable, Class Hierarchy Over-Engineered

Each Dungeo daemon has sufficiently unique quirks (different mutable state, different condition logic, different trigger points) that shared base classes provided minimal code reuse. Factory functions were clearer and simpler. However, the serialization hooks (`getRunnerState`/`restoreRunnerState`) genuinely solve the problem of daemon state surviving save/restore — worth keeping on the interface.

### 2. Story Bundle Sourced from Source, Not Compiled Dist

Phase 1 bundles story code from `src/index.ts`, not from compiled `dist/index.js`. This allows esbuild to emit true ES module `import` statements for `@sharpee/*` packages, which Phase 2 can then resolve via importmap. If we bundled from dist, we'd get pre-bundled CommonJS or obfuscated modules, breaking the clean resolution mechanism.

### 3. Module Resolution via ES Importmap (Rejected: Global Namespace)

Phase 2 uses `<script type="importmap">` in the browser to map `@sharpee/engine` → `window.Sharpee.engine` etc. This is standard, declarative, and doesn't require changes to story source code. Alternative of shimming a global `Sharpee` namespace was simpler-seeming but less clean and harder to extend.

### 4. Daemon Serialization Orthogonal to Zifmia Bundle Format

ADR-123's addition of `getRunnerState`/`restoreRunnerState` doesn't affect Zifmia Phase 1 (bundle format) or Phase 2 (loader). Save data flows through the existing platform and bundling mechanism transparently. Noted in implementation-plan.md for future reference.

## Open Items

### Short Term (Next Session)

1. **Commit Zifmia Phase 1 changes** (if not already done)
   - `build.sh` enhancements
   - `docs/work/zifmia/implementation-plan.md` daemon note update
   - Status: Already committed as `825ef57`

2. **Implement Zifmia Phase 2: Story Loader**
   - Add `StoryMetadata` type and validation
   - Implement `BundleExtractor` with fflate
   - Implement `DynamicStoryImporter` with dynamic `import()`
   - Wire platform module provider (importmap resolution)
   - Test with dungeo.sharpee bundle

3. **Verify Phase 1 bundle size and structure**
   - Ensure 172KB size is reasonable and repeatable
   - Check that `meta.json` has all necessary fields for Phase 2

### Long Term (Future Phases)

1. **Phase 2 completion:** Asset serving and story validation before game starts
2. **Phase 3:** Runner application shell with story library UI, save/restore abstraction, `StorageProvider` interface
3. **Phase 4:** IllustrationTrait and illustration event emission for story-provided inline images
4. **Phase 5:** Story-specific CSS scoping and theming
5. **Phase 6:** Tauri desktop shell for native `.sharpee` file handling

## Files Modified

**Platform** (2 commits):
- `packages/plugin-scheduler/src/index.ts` — removed daemons barrel export (55d726a)
- `docs/architecture/adrs/adr-123-typed-daemon-hierarchy.md` — updated status to PARTIALLY ACCEPTED (55d726a)
- `docs/work/platform/undo-daemon-work.md` — rationale for revert (55d726a)

**Story: Dungeo** (55d726a):
- `stories/dungeo/src/handlers/index.ts` — removed crypt-ritual-daemon, bat-room-runner, exorcism-runner exports; restored factory exports
- `stories/dungeo/src/scheduler/index.ts` — removed runner exports; restored factory exports
- `stories/dungeo/src/orchestration/scheduler-setup.ts` — reverted to factory registration
- `stories/dungeo/src/index.ts` — reverted initialization
- `stories/dungeo/src/handlers/bat-handler.ts` — restored from `ae82c95`
- `stories/dungeo/src/handlers/endgame-trigger-handler.ts` — restored from `ae82c95`
- `stories/dungeo/src/handlers/exorcism-handler.ts` — restored from `ae82c95`
- `stories/dungeo/src/scheduler/forest-daemon.ts` — restored from `ae82c95`
- `stories/dungeo/src/scheduler/sword-glow-daemon.ts` — restored with serialization hooks added
- `stories/dungeo/src/scheduler/troll-daemon.ts` — restored from `ae82c95`
- Deleted: crypt-ritual-daemon.ts, bat-room-runner.ts, exorcism-runner.ts, forest-ambience-runner.ts, sword-glow-runner.ts, troll-recovery-runner.ts

**Build & Zifmia** (825ef57):
- `build.sh` — added `--story-bundle` / `-b` flag with full zip/metadata/esbuild logic (+103 lines)
- `docs/work/zifmia/implementation-plan.md` — added daemon serialization note (Phase 2.3)
- `docs/context/.work-log.txt` — build log of session work

## Architectural Notes

### ADR-123 Teaches: Inheritance for Code Reuse, Not Taxonomy

The class hierarchy was designed to create a taxonomy of daemon patterns (watchdog, location, ambient, countdown). While intellectually clean, it provided little reuse because each daemon's logic is sufficiently unique. The serialization hooks, by contrast, solve a real platform problem (state survival across save/load) and justified being added to the interface.

Lesson: Don't design inheritance hierarchies for documentation. Use them when multiple implementations share enough code to make subclassing worthwhile. Here, factory functions + interface hooks proved simpler and sufficient.

### Zifmia Phase 1-2 Design: Decoupling Story Code from Platform

By making `@sharpee/*` external in the story bundle and resolving them at runtime via importmap, we achieve true story portability:
- Story bundles are **immutable** — once built, they never need to be rebuilt
- Runner can be updated independently of story bundles
- Same story bundle works with multiple runner versions (within compatibility range)
- No need to ship multiple builds of the same story (one for web, one for Tauri, etc.)

This is the key architectural insight of the Zifmia project.

### Serialization Hooks Are Lightweight Platform Addition

The `getRunnerState`/`restoreRunnerState` pattern is elegant for daemons with internal mutable state. It's optional (methods can be omitted), non-breaking (doesn't change existing code), and transparent to the scheduler. More of these optional hooks should be considered for other plugin types that need state survival.

## Notes

**Session duration:** ~90 minutes (revert, verify, design, implement, document)

**Approach:**
1. Executed and verified ADR-123 undo plan methodically (delete classes, restore daemons, add serialization, test)
2. Implemented Zifmia Phase 1 build tooling from spec
3. Designed Phase 2 module resolution strategy, presented two approaches (importmap vs. global shim), user approved importmap

**Test coverage:** 148/148 Dungeo walkthroughs passing after all ADR-123 reversions

**Next critical decision:** Phase 2 implementation can use the approved importmap design. Key implementation detail: must bundle story from src/index.ts (not dist) to get clean ES module imports for externals.

---

**Progressive update:** Session completed 2026-01-29 05:54
