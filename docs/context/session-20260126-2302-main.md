# Session Summary: 2026-01-26 - main

## Status: Completed

## Goals
- Migrate PUTTING action to use the interceptor pattern (ADR-118)
- Follow the same approach used for THROWING and GOING actions
- Migrate balloon receptacle handler from event-based to interceptor-based

## Completed

### Platform Changes

#### PUTTING Action Interceptor Support
Modified `packages/stdlib/src/actions/standard/putting/` to support interceptors:

**putting.ts**:
- Added interceptor imports from world-model
- Added preValidate hook: Runs before standard validation, can abort with custom message
- Added postValidate hook: Runs after standard validation passes
- Added postExecute hook: Runs after standard execution (after containment changes)
- Added postReport hook: Runs after standard events, can add additional effects
- Added onBlocked hook: Runs when validation fails, can customize error messages
- Pattern matches THROWING and GOING actions exactly

**putting-types.ts**:
- Added `interceptor?: ActionInterceptor` field to PuttingSharedData
- Added `interceptorData?: InterceptorSharedData` field to PuttingSharedData
- Enables traits to inject custom behavior at any phase

### Story Changes (Dungeo)

#### Balloon Receptacle Migration
Migrated balloon inflation from event handler to interceptor pattern:

**New Files**:
- `stories/dungeo/src/traits/balloon-receptacle-trait.ts`:
  - Marker trait for entities that inflate balloons when items are put in them
  - Stores `balloonId` to connect receptacle to balloon state
  - Type: `dungeo.trait.balloon_receptacle`

- `stories/dungeo/src/interceptors/receptacle-putting-interceptor.ts`:
  - Intercepts PUT actions on entities with BalloonReceptacleTrait
  - postValidate: Detects if item being put is burning (checks LightSourceTrait and isLit)
  - postExecute: Updates balloon state, inflates cloth bag (changes BalloonStateTrait.isInflated)
  - postReport: Adds inflation message to output
  - Reuses existing message ID: `dungeo.balloon.inflating`

**Modified Files**:
- `stories/dungeo/src/traits/index.ts`:
  - Export BalloonReceptacleTrait
  - Export ReceptaclePuttingInterceptor

- `stories/dungeo/src/regions/volcano.ts`:
  - Added BalloonReceptacleTrait to receptacle entity during creation
  - Links receptacle to balloon via balloonId

- `stories/dungeo/src/index.ts`:
  - Import BalloonReceptacleTrait and ReceptaclePuttingInterceptor
  - Register interceptor in initializeWorld() via registerActionInterceptor()

- `stories/dungeo/src/orchestration/event-handlers.ts`:
  - Removed registerBalloonPutHandler() call (replaced by interceptor)

- `stories/dungeo/src/scheduler/index.ts`:
  - Removed registerBalloonPutHandler from exports (dead code)

## Key Decisions

### 1. Interceptor Runs on Target Entity
The interceptor is registered against the TARGET entity (the receptacle receiving the item), not the item being put. This matches the pattern where interceptors are entity-specific behaviors.

### 2. InterceptorData Structure
Standard fields passed to all interceptors:
- `itemId` - Entity being put
- `itemName` - Display name of item
- `targetId` - Container/supporter receiving the item
- `targetName` - Display name of target
- `preposition` - "in" or "on" depending on ContainerTrait vs SupporterTrait

### 3. Multi-Object Limitation
Current implementation doesn't support interceptors for multi-object commands (e.g., "PUT ALL IN BOX"). This is noted in code comments but not blocking since it's a rare edge case.

### 4. Message Reuse
Reused existing message ID `dungeo.balloon.inflating` instead of creating a new one. The interceptor pattern doesn't require new message IDs when existing ones are appropriate.

### 5. Hook Execution Order
Critical sequence for PUT actions:
1. preValidate - Can abort early with custom message
2. Standard validation - Checks ContainerTrait, SupporterTrait, capacity
3. postValidate - Additional checks after standard validation
4. Standard execute - Updates containment (moveEntity call)
5. postExecute - Side effects after containment changes
6. Standard report - Emits if.event.put_in/if.event.put_on
7. postReport - Additional messages

## Open Items

### Short Term
- None - migration is complete and tested

### Long Term
- Consider multi-object support for interceptors (would require sharedData changes)
- Evaluate other event handlers for potential interceptor migration
- Document interceptor pattern for story authors

## Files Modified

**Platform (stdlib)** (2 files):
- `packages/stdlib/src/actions/standard/putting/putting.ts` - Added 5 interceptor hooks
- `packages/stdlib/src/actions/standard/putting/putting-types.ts` - Added interceptor fields

**Story (dungeo)** (7 files):
- `stories/dungeo/src/traits/balloon-receptacle-trait.ts` - NEW: Marker trait for receptacle
- `stories/dungeo/src/interceptors/receptacle-putting-interceptor.ts` - NEW: PUT interceptor
- `stories/dungeo/src/traits/index.ts` - Export new trait/interceptor
- `stories/dungeo/src/regions/volcano.ts` - Add trait to receptacle
- `stories/dungeo/src/index.ts` - Register interceptor
- `stories/dungeo/src/orchestration/event-handlers.ts` - Remove old event handler call
- `stories/dungeo/src/scheduler/index.ts` - Remove old handler export

## Architectural Notes

### Interceptor Pattern Maturity
This is the third action to receive interceptor support (after THROWING and GOING), establishing the pattern as stable:

1. **THROWING** - Glacier handler intercepts throws at specific locations
2. **GOING** - Boat puncture handler intercepts movement on specific entities
3. **PUTTING** - Balloon handler intercepts puts into specific containers

The pattern is now well-understood:
- Traits mark entities that need special behavior
- Interceptors implement the custom logic
- Standard action provides 5 hooks (preValidate, postValidate, postExecute, postReport, onBlocked)
- sharedData carries both action data and interceptorData

### Event Handlers vs Interceptors
This migration clarifies when to use each pattern:

**Use Interceptors when**:
- Logic is entity-specific (trait-based)
- Need to modify validation before it runs
- Need to add side effects during execution
- Want to customize error messages

**Use Event Handlers when**:
- Logic is global (applies to all entities)
- Only need to react after action completes
- Don't need to modify validation or execution

The balloon puzzle is a perfect interceptor candidate: it's specific to one entity (the receptacle) and needs to detect state during execution (is the item burning?).

### InterceptorData vs ActionContext Pollution
The use of `interceptorData` in sharedData follows ADR-118's principle of keeping interceptor-specific data separate from core action data. This prevents "context pollution" where actions accumulate entity-specific fields over time.

Before interceptors:
```typescript
// Bad: Action knows about balloons
interface PuttingSharedData {
  // ... standard fields
  balloonId?: string;  // balloon-specific
  isItemBurning?: boolean;  // balloon-specific
}
```

With interceptors:
```typescript
// Good: Interceptor owns its data
interface PuttingSharedData {
  // ... standard fields
  interceptorData?: InterceptorSharedData;  // generic container
}
```

## Testing

**Build Status**: Success
- All packages compile cleanly
- Version: 0.9.60-beta

**Test Status**: 1295 passing, 25 failing
- Pre-existing failures: 25 (unrelated to this work)
- New failures: 0
- All stdlib tests pass
- All dungeo tests pass

**Manual Testing**: Not performed (interceptor pattern proven in THROWING/GOING migrations)

## Notes

**Session duration**: ~45 minutes

**Approach**: Followed established migration pattern from ADR-118. This was a straightforward application of an existing pattern rather than new design work. The balloon handler was already well-structured as an event handler, making the translation to interceptor pattern mechanical.

**Next Actions**: ADR-118 migration is now complete for all three identified actions. Future stdlib actions can be migrated on an as-needed basis when stories require interception capabilities.

---

**Progressive update**: Session completed 2026-01-26 23:02
