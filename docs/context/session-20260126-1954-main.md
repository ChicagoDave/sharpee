# Session Summary: 2026-01-26 - main

## Status: Completed

## Goals
- Analyze ADR-117 (Eliminate Broad Use of Event Handlers) and plan migration
- Audit all handler files in stories/dungeo/src/handlers/ to classify them
- Create migration plan for event handlers that should become traits/behaviors
- Define platform changes needed to support the migration

## Completed

### ADR-117 Analysis and Handler Audit

Analyzed all 27 handler files in `stories/dungeo/src/handlers/` and classified them into three categories:

**8 files using registerEventHandler (need migration):**
- `cliff-handler.ts` - Listens for JUMP in cliff location (should be CliffTrait)
- `glacier-handler.ts` - Listens for THROW at glacier (should be GlacierTrait)
- `rainbow-handler.ts` - Listens for WAVE sceptre (should be SceptreTrait)
- `timber-room-handler.ts` - Listens for CHOP/CUT timber (should be TimberRoomTrait)
- `troll-guardian-handler.ts` - Listens for going/giving to enforce troll (should be TrollGuardianTrait)
- `trophy-case-handler.ts` - Listens for PUT IN trophy case (should be TrophyCaseTrait)
- `coal-machine-switch-handler.ts` - Listens for TURN switch (should be CoalMachineTrait)
- `grating-handler.ts` - Listens for OPEN grating for state sync (should be GratingTrait)

**11 files are actually Daemons (correct pattern):**
- `sword-blade-daemon.ts`, `cyclops-daemon.ts`, `thief-daemon.ts`, etc.
- These use `registerDaemon()` and are already following ADR-071 pattern

**2 files are ParsedCommandTransformers (correct pattern):**
- `direction-transformer-handler.ts`
- `go-over-under-handler.ts`

### Key Discovery: Platform Gap

Discovered that most "high priority" migrations are blocked because **stdlib standard actions don't check for capability behaviors**. Only pure capability dispatch actions (LOWER, RAISE, TURN, WAVE) do.

Standard actions like ENTER, THROW, PUT have their own execute logic and don't look for trait-based behaviors. This creates a platform gap:
- Troll guardian blocks ENTER (standard action)
- Glacier intercepts THROW (standard action)
- Trophy case reacts to PUT (standard action)

These can't migrate to traits without platform changes.

### ADR-117 Migration Plan Created

Created comprehensive migration plan at `docs/work/dungeo/adr-117-migration-plan.md` covering:

**High Priority Migrations:**
1. Troll Guardian (blocks going)
2. Glacier (intercepts throwing)
3. Trophy Case (reacts to putting)

**Medium Priority Migrations:**
4. Grating (syncs state on opening)
5. Coal Machine Switch (intercepts turning)

**Low Priority Migrations:**
6. Cliff (blocks jumping)
7. Timber Room (intercepts chopping)
8. Rainbow (intercepts waving)

**Already Correct:**
- All Daemons (11 files) - following ADR-071
- All Transformers (2 files) - correct pattern
- Previous session completed all mutable state trait migrations

### Platform Change Decision: ADR-118

Discussed two options for enabling migrations:

**Option A: Full Delegation**
- Standard actions check `findTraitWithCapability()` before running their logic
- If trait has behavior, delegate completely to it
- Matches pure capability dispatch pattern (LOWER, RAISE)
- Example: TrophyCaseTrait fully handles putting logic

**Option B: Interceptor Pattern** (CHOSEN)
- Standard actions run their core logic
- Traits can hook into specific phases (preValidate, postValidate, postExecute, postReport)
- Matches Inform 6/7 Before/After model
- Example: TrophyCaseTrait adds scoring in postExecute hook

### ADR-118 Created: Stdlib Action Interceptors

Created `docs/architecture/adrs/adr-118-stdlib-action-interceptors.md` defining the interceptor pattern:

**Core Pattern:**
```typescript
interface ActionInterceptor {
  preValidate?(context: ActionContext, sharedData: SharedActionData): ValidationResult | void;
  postValidate?(context: ActionContext, sharedData: SharedActionData): ValidationResult | void;
  postExecute?(context: ActionContext, sharedData: SharedActionData): void;
  postReport?(context: ActionContext, sharedData: SharedActionData, effects: Effect[]): Effect[];
}
```

**Key Design Decisions:**
- Interceptors registered via trait capabilities system
- Multiple interceptors can run for same action (unlike full delegation)
- Standard action logic runs unless preValidate blocks it
- Hooks can modify sharedData, add effects, or block execution
- Pattern mirrors Inform 6/7 Before/After rules

**Examples:**
- TrollGuardianTrait uses preValidate to block going unless treasure given
- GlacierTrait uses postExecute to melt glacier and remove itself
- TrophyCaseTrait uses postExecute to add scoring effects

## Key Decisions

### 1. Interceptor Pattern Over Full Delegation
**Rationale:** Standard actions have well-tested core logic (move entity, update state, emit events). Interceptors let traits customize behavior without reimplementing basic mutations. Matches proven Inform 6/7 model where Before/After rules augment standard actions.

### 2. Keep Daemons and Transformers As-Is
**Rationale:** 11 daemon files and 2 transformer files are already following correct patterns (ADR-071, ADR-089). They don't need migration. Focus effort on the 8 event handler files.

### 3. Migration Priority Based on User Impact
**Rationale:** Troll guardian and glacier are mandatory puzzles that affect gameplay. Trophy case affects scoring. These are high priority. Cliff/timber room are edge cases with minimal gameplay impact (low priority).

## Open Items

### Short Term
- Implement ActionInterceptor system in stdlib action base class
- Migrate TrollGuardianTrait to use preValidate interceptor
- Migrate GlacierTrait to use postExecute interceptor
- Migrate TrophyCaseTrait to use postExecute interceptor
- Test that interceptors work correctly with action phase flow

### Long Term
- Migrate remaining 5 handlers (grating, coal machine, cliff, timber, rainbow)
- Document interceptor pattern in core-concepts.md
- Update CLAUDE.md with interceptor examples
- Consider if other stories need similar interceptor patterns

## Files Modified

**Documentation** (2 files):
- `docs/work/dungeo/adr-117-migration-plan.md` - Complete migration plan with priorities and platform gaps
- `docs/architecture/adrs/adr-118-stdlib-action-interceptors.md` - New ADR defining interceptor pattern

## Architectural Notes

### The "Standards Actions Can't Be Customized" Problem

The root issue: Sharpee has two action patterns that don't compose well:

1. **Pure capability dispatch** (LOWER, RAISE, TURN, WAVE) - Trait owns all logic
2. **Standard actions** (TAKE, DROP, OPEN, ENTER, THROW) - Action owns logic, traits provide data

This creates a gap: When you need to customize a standard action (block it, react to it, modify its effects), you can't use a trait behavior. You're forced to use event handlers.

ADR-118 bridges this gap by letting traits intercept standard actions at key points without reimplementing core logic.

### Why Interceptors Match Sharpee's Design

Sharpee's standard actions already have well-tested four-phase logic:
- **Validate**: Check preconditions
- **Execute**: Mutate world state
- **Report**: Generate effects
- **Blocked**: Handle validation failures

Interceptors augment these phases rather than replacing them. This preserves the investment in stdlib while enabling story-specific customization.

### Inform 6/7 Heritage

The interceptor pattern comes from decades of IF authoring experience:

**Inform 6:**
```inform
before [
  Enter -> "The troll blocks your way.";
]
```

**Inform 7:**
```inform
Before entering the Troll Room when the troll is alive:
  say "The troll blocks your way.";
  stop the action.
```

**Sharpee ADR-118:**
```typescript
preValidate(context: ActionContext): ValidationResult {
  if (troll.alive) {
    return ActionResult.blocked('dungeo.msg.troll_blocks_path');
  }
}
```

Same concept, different syntax. Proven pattern for customizing standard verbs.

## Notes

**Session duration**: ~2 hours

**Approach**: Systematic audit of all handler files, classification by pattern, identification of platform gaps, and collaborative design of ADR-118 to bridge those gaps. The session focused on understanding the problem space before implementing solutions.

**Context usage**: Session started at ~17% remaining tokens, stayed in good range throughout.

**No code changes**: This was a planning and design session. All outputs are documentation. Implementation of ADR-118 will occur in next session.

---

**Progressive update**: Session completed 2026-01-26 19:54
