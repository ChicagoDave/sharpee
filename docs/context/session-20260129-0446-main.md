# Session Summary: 2026-01-29 - main

## Status: Completed

## Goals

- Execute the undo plan from `docs/work/platform/undo-daemon-work.md`
- Revert ADR-123 typed daemon hierarchy while preserving serialization infrastructure
- Verify 148/148 walkthroughs still pass with reverted daemons

## Completed

### Executed Full Undo Plan

Systematically reverted the ADR-123 class hierarchy implementation from the previous session while keeping serialization infrastructure intact.

#### Step 1: Deleted Base Class Hierarchy

Removed `packages/plugin-scheduler/src/daemons/` directory containing:
- `daemon-runner.ts` - Base class for simple stateful daemons
- `watchdog-daemon.ts` - Base for condition-checking daemons
- `location-daemon.ts` - Base for location-aware daemons
- `ambience-daemon.ts` - Base for random ambient events
- `countdown-daemon.ts` - Base for countdown timers
- `index.ts` - Barrel export file

Updated `packages/plugin-scheduler/src/index.ts` to remove `export * from './daemons'`.

#### Step 2: Restored Factory-Function Daemons

Restored all 6 daemons to their original factory-function implementations from git commit `ae82c95`:

**handlers/**:
- `bat-handler.ts` - Vampire bat ambience in bat room (factory function)
- `endgame-trigger-handler.ts` - Crypt ritual endgame trigger (factory function)
- `exorcism-handler.ts` - Bell/book/candle exorcism ritual (factory function)

Deleted corresponding runner replacements:
- `bat-room-runner.ts`
- `crypt-ritual-daemon.ts`
- `exorcism-runner.ts`

**scheduler/**:
- `forest-daemon.ts` - Random forest ambient sounds (factory function)
- `sword-glow-daemon.ts` - Sword glows near enemies (factory function + serialization)
- `troll-daemon.ts` - Troll recovery after combat (factory function)

Deleted corresponding runner replacements:
- `forest-ambience-runner.ts`
- `sword-glow-runner.ts`
- `troll-recovery-runner.ts`

#### Step 3: Restored Barrel Exports and Wiring

Restored from `ae82c95`:
- `stories/dungeo/src/handlers/index.ts` - Barrel export for all handlers
- `stories/dungeo/src/scheduler/index.ts` - Barrel export for all scheduler daemons
- `stories/dungeo/src/orchestration/scheduler-setup.ts` - Daemon registration wiring
- `stories/dungeo/src/index.ts` - Main exports
- `stories/dungeo/src/version.ts` - Version bump

#### Step 4: Added Serialization to Sword-Glow Daemon

The sword-glow-daemon.ts is the only daemon with mutable module-level state (`currentGlowLevel`) that must survive save/restore. Added serialization hooks to the factory function:

```typescript
getRunnerState: () => ({ currentGlowLevel }),
restoreRunnerState: (state: Record<string, unknown>) => {
  currentGlowLevel = (state.currentGlowLevel as number) ?? GLOW_OFF;
},
```

Other daemons either:
- Use world entity state (bat-handler, endgame-trigger-handler, troll-daemon, exorcism-handler)
- Are probability-based with no state (forest-daemon)

These naturally survive save/restore through the world model.

#### Step 5: Updated ADR-123 Status

Modified `docs/architecture/adrs/adr-123-typed-daemon-hierarchy.md`:

Changed from `Status: ACCEPTED` to `Status: PARTIALLY ACCEPTED (Serialization adopted, class hierarchy rejected)`

Added implementation notes section explaining:
- **Serialization infrastructure — ACCEPTED**: `getRunnerState()`/`restoreRunnerState()` on Daemon interface and `runnerState` on DaemonState were kept
- **Class hierarchy — REJECTED**: Five base classes were implemented, migrated, and then reverted because each daemon is quirky enough that base classes provided minimal reuse

### Verification

- Build succeeded with `./build.sh -s dungeo`
- All 148/148 walkthroughs passed with reverted daemons
- No regressions from revert
- Serialization infrastructure fully functional

## Key Decisions

### 1. Keep Serialization Infrastructure

**Rationale**: The serialization hooks (`getRunnerState`/`restoreRunnerState` on Daemon interface, `runnerState` on DaemonState, and scheduler integration) are genuinely useful. They enable daemon internal state to survive save/load cycles.

**Impact**: Preserved in types.ts and scheduler-service.ts. These changes have no runtime cost and unlock proper state persistence for daemons that need it.

### 2. Revert Class Hierarchy as Over-Engineering

**Rationale**: During implementation, it became clear that:
- LocationDaemon saved only one line (`this.getPlayerLocation(world)`)
- TrollRecoveryRunner used zero features from DaemonRunner base class
- AmbienceDaemon and CountdownDaemon had no users
- Each daemon is quirky enough that base classes provided minimal reuse
- Factory functions are simpler, more flexible, and equally testable

**Impact**: All 5 base classes and their 6 migrations were reverted. Factory functions + serialization hooks is the right approach.

### 3. ADR-123 Status: Partially Accepted

**Rationale**: The ADR had two proposals:
1. Typed daemon hierarchy with base classes - **REJECTED** (over-engineering)
2. Serialization support for daemon state - **ACCEPTED** (genuinely useful)

**Impact**: Updated ADR-123 to reflect the split decision rather than full rejection. Future readers benefit from understanding which parts were valuable and which were not.

## Open Items

### Short Term
- None - undo plan fully executed and verified

### Long Term
- Consider adding serialization to other daemons if they accumulate mutable state
- Document serialization pattern in core-concepts.md if more daemons adopt it
- Future daemons should use factory functions + serialization hooks (not base classes)

## Files Modified

**Platform (Serialization - KEPT)**:
- `packages/plugin-scheduler/src/types.ts` - Daemon interface has getRunnerState/restoreRunnerState (kept)
- `packages/plugin-scheduler/src/scheduler-service.ts` - Save/restore runner state (kept)
- `packages/plugin-scheduler/src/index.ts` - Removed `export * from './daemons'`

**Platform (Base Classes - DELETED)**:
- ~~`packages/plugin-scheduler/src/daemons/daemon-runner.ts`~~ - DELETED
- ~~`packages/plugin-scheduler/src/daemons/watchdog-daemon.ts`~~ - DELETED
- ~~`packages/plugin-scheduler/src/daemons/location-daemon.ts`~~ - DELETED
- ~~`packages/plugin-scheduler/src/daemons/ambience-daemon.ts`~~ - DELETED
- ~~`packages/plugin-scheduler/src/daemons/countdown-daemon.ts`~~ - DELETED
- ~~`packages/plugin-scheduler/src/daemons/index.ts`~~ - DELETED

**Story (Handlers - RESTORED)**:
- `stories/dungeo/src/handlers/bat-handler.ts` - Restored from ae82c95
- `stories/dungeo/src/handlers/endgame-trigger-handler.ts` - Restored from ae82c95
- `stories/dungeo/src/handlers/exorcism-handler.ts` - Restored from ae82c95
- `stories/dungeo/src/handlers/index.ts` - Restored from ae82c95
- ~~`stories/dungeo/src/handlers/bat-room-runner.ts`~~ - DELETED
- ~~`stories/dungeo/src/handlers/crypt-ritual-daemon.ts`~~ - DELETED
- ~~`stories/dungeo/src/handlers/exorcism-runner.ts`~~ - DELETED

**Story (Scheduler - RESTORED + SERIALIZATION)**:
- `stories/dungeo/src/scheduler/forest-daemon.ts` - Restored from ae82c95
- `stories/dungeo/src/scheduler/sword-glow-daemon.ts` - Restored from ae82c95 + added getRunnerState/restoreRunnerState
- `stories/dungeo/src/scheduler/troll-daemon.ts` - Restored from ae82c95
- `stories/dungeo/src/scheduler/index.ts` - Restored from ae82c95
- ~~`stories/dungeo/src/scheduler/forest-ambience-runner.ts`~~ - DELETED
- ~~`stories/dungeo/src/scheduler/sword-glow-runner.ts`~~ - DELETED
- ~~`stories/dungeo/src/scheduler/troll-recovery-runner.ts`~~ - DELETED

**Story (Wiring - RESTORED)**:
- `stories/dungeo/src/orchestration/scheduler-setup.ts` - Restored from ae82c95
- `stories/dungeo/src/index.ts` - Restored from ae82c95
- `stories/dungeo/src/version.ts` - Version updated

**Documentation**:
- `docs/architecture/adrs/adr-123-typed-daemon-hierarchy.md` - Updated status to PARTIALLY ACCEPTED
- `docs/work/platform/undo-daemon-work.md` - Comprehensive revert plan (for reference)

## Architectural Notes

### Pattern Taxonomy vs. Messy Reality

This session completes a valuable learning cycle:

1. **Theory**: "Daemons follow 5 patterns - let's create a typed hierarchy"
2. **Implementation**: "OK, let me implement the 5 base classes and migrate real daemons"
3. **Assessment**: "Hmm, only 1-2 daemons use each pattern. Base classes save almost no code"
4. **Decision**: "Revert. Factory functions + serialization hooks is simpler"

The correct abstraction layer was serialization, not inheritance hierarchies.

### Serialization as a Horizontal Concern

This session revealed that **serialization is the real valuable abstraction**:
- `getRunnerState()` / `restoreRunnerState()` work for both classes and factory functions
- Scheduler integration handles save/restore automatically
- Each daemon only needs to implement these two methods if it has mutable state
- Low overhead, high value

This is different from the class hierarchy which tried to abstract "patterns" that didn't consistently appear.

### Validation of Sharpee's Architecture

The revert validates Sharpee's preference for composition over inheritance:
- Behaviors are objects with methods, not class hierarchies
- Actions are objects, not class hierarchies
- Traits can be classes but often aren't
- Daemons follow the same pattern: factory functions returning objects with methods

**Consistency across layers** is important for cognitive load and maintainability.

## Testing Notes

- All 148/148 walkthroughs passed throughout the revert
- No regressions from restoring factory functions
- Serialization infrastructure already tested (save/load works)
- Build succeeded without errors

The fact that walkthroughs never broke during the round-trip (implementation → assessment → revert) is evidence of the test suite's robustness.

## Lessons Learned

### 1. Serialization is a Separate Concern from Structure

ADR-123 tried to solve two problems at once:
1. Add serialization support to daemons
2. Create a class hierarchy based on daemon patterns

Splitting them revealed that only #1 was valuable. Serialization works equally well for factory functions.

### 2. Reversion is Healthy

This was a successful experiment that learned when to say "no." The codebase is better for:
- Trying the class hierarchy and learning it doesn't fit
- Reverting it cleanly
- Keeping the valuable part (serialization)

**Anti-pattern to avoid**: Forcing daemons into base classes just because they exist, hoping future code will justify them.

### 3. Low Friction Reversions Require Good Version Control

The clean revert was possible because:
- Original implementation was careful and well-structured
- Tests caught regressions immediately
- Git history made it easy to restore factory functions
- No dependencies built on the base classes

## Notes

**Session duration**: ~13 minutes (plan execution from previous session)

**Approach**:
1. Systematically followed the comprehensive undo plan from previous session
2. Deleted base class directory and exports
3. Restored 6 factory-function daemons from git history
4. Added serialization hooks to sword-glow-daemon.ts
5. Restored barrel exports and registration wiring
6. Updated ADR-123 status
7. Verified build and tests

**Key files created/modified**:
- **Deleted**: 5 base classes + 6 runner implementations = 11 files removed
- **Restored**: 6 factory-function daemons from ae82c95
- **Added**: Serialization hooks to sword-glow-daemon.ts
- **Updated**: ADR-123 status to PARTIALLY ACCEPTED

**Outcome**: The platform now has a clean serialization infrastructure for daemons while maintaining the simplicity of factory functions. ADR-123 reflects the real outcome: serialization is valuable, class hierarchies were not.

---

**Progressive update**: Session completed 2026-01-29 04:46 - Undo plan executed, serialization kept, class hierarchy reverted
