# Session Summary: 2026-02-01 - main

## Status: Completed

## Goals
- Debug why action interceptors don't fire in transcript tests (continuation from session-20260201-1700-main.md)
- Fix troll axe blocking behavior using ADR-118 interceptors
- Clean up debug logging once issue resolved

## Completed

### 1. Root Cause Discovery - Build System Bundle Resolution Bug

**Problem**: The CLI bundle (`dist/sharpee.js`) built by esbuild was resolving `@sharpee/*` package imports via `package.json` `main`/`exports` fields, which point to `dist-npm/` (ESM builds for npm publish). These ESM builds were stale - missing the interceptor code recently added to `packages/stdlib/src/actions/standard/taking/taking.ts`.

**Evidence**:
- Bundle contained TWO complete copies of every `@sharpee/*` package
- One copy from `dist/` (CJS, project references, current)
- One copy from `dist-npm/` (ESM, npm publish target, stale)
- The stale `dist-npm/` versions were winning because they were exported last in the spread
- Missing code: interceptor support in taking.ts, troll axe interceptor implementation

**Impact**:
- Transcript tests executed against stale stdlib code without interceptor hooks
- Interactive mode (`--play`) likely also affected
- npm packages (`dist-npm/`) unaffected - those are built separately for publishing

### 2. Fix Applied - esbuild --alias Flags

Modified `build.sh` to add explicit `--alias` flags to the esbuild command:

```bash
--alias:@sharpee/engine=packages/engine/dist \
--alias:@sharpee/world-model=packages/world-model/dist \
--alias:@sharpee/stdlib=packages/stdlib/dist \
--alias:@sharpee/parser-en-us=packages/parser-en-us/dist \
--alias:@sharpee/lang-en-us=packages/lang-en-us/dist \
--alias:@sharpee/tools=packages/tools/dist
```

**Result**:
- All `@sharpee/*` imports now resolve to their `dist/` (CJS project-references) directories
- Bundle reduced from containing duplicate packages to a single copy
- Bundle still builds at ~2.0MB (expected size)
- npm packages (`dist-npm/`) unaffected - remain ESM for publishing

### 3. Troll Axe Interceptor Now Working

**Test**: `stories/dungeo/tests/transcripts/troll-visibility.transcript`

**Before fix**: Failed - "take axe" succeeded, axe moved to inventory (stale stdlib without interceptor hooks)

**After fix**: **PASSED** - "take axe" correctly blocked with message:
```
The troll's axe is wickedly sharp and white-hot from the heat of battle! You can't take it while the troll is alive.
```

**Test Results**: 15 passed, 0 failed, 1 expected failure (troll recovery, separate issue)

**Verification**:
- Axe blocks taking while troll alive (interceptor fires)
- Axe can be taken after troll dies (interceptor allows)
- Visibility toggles correctly with troll state (OUT!/IN! states)

### 4. Debug Logging Cleanup

Removed temporary debug `console.warn` calls added during investigation:

**packages/stdlib/src/actions/standard/taking/taking.ts**:
```typescript
// REMOVED:
// console.warn('[TAKING] Running interceptors for target:', target?.id);
// console.warn('[TAKING] Interceptor check result:', interceptorError);
```

**packages/engine/src/command-executor.ts**:
```typescript
// REMOVED:
// console.warn('[CAPABILITY] Looking up behaviors for:', traitType, 'action:', actionId);
// console.warn('[CAPABILITY] Found behavior:', !!behavior);
```

### 5. Issues List Update

Updated `docs/work/issues/issues-list-02.md`:

**Added ISSUE-046**: "CLI Bundle Resolution Bug - esbuild resolving to stale dist-npm/"
- **Severity**: Critical (affected all transcript testing)
- **Status**: Fixed (esbuild --alias flags)
- **Impact**: Bundle contained duplicate packages with stale `dist-npm/` winning

**Updated Test Statistics**:
- Passing tests: Added `troll-visibility.transcript` to passing list
- Failure count: 28 remaining (down from 29)
- Categorized failures by root cause

**Updated Failure Categories**:
- Basket elevator: 7 failures (needs capability dispatch implementation)
- Trophy case scoring: 7 failures (needs event handler for scoring)
- Troll recovery: 5 failures (needs daemon/fuse for unconscious state)
- Flooding: 4 failures (needs reservoir dam mechanics)
- Troll interactions: 3 failures (needs combat refinement)
- Egg opening: 2 failures (needs openable with tool pattern)
- Save/restore: 1 failure (infrastructure issue)

## Key Decisions

### 1. Always Use --alias for Bundle Builds

**Decision**: Build system must use explicit `--alias` flags for all `@sharpee/*` packages to prevent esbuild from resolving via stale package.json exports.

**Rationale**:
- esbuild's default resolution follows Node.js semantics (package.json `main`/`exports`)
- Our monorepo has TWO build outputs per package: `dist/` (CJS, project refs) and `dist-npm/` (ESM, npm publish)
- Bundle must use current `dist/` builds, not stale `dist-npm/` builds
- Explicit --alias flags override package.json resolution

**Impact**:
- Single source of truth for bundle builds
- No more duplicate package copies in bundle
- Faster builds (less to bundle)
- Consistent behavior between development and testing

### 2. ADR-118 Interceptors Are Production-Ready

**Decision**: Action interceptor pattern (ADR-118) is now verified working in transcript tests. Proceed with using interceptors for blocking-only logic.

**Rationale**:
- Troll axe interceptor fires correctly with fixed bundle
- Interceptor pattern is cleaner than capability behaviors for blocking-only logic
- No mutation needed - just preValidate check and custom error message

**When to use interceptors**:
- Blocking actions with custom messages (troll axe, white-hot metal)
- Pre/post validation augmentation (safety checks, prerequisites)
- No mutation logic needed (stdlib action handles actual work)

**When NOT to use interceptors**:
- Entity-specific mutations (use capability dispatch - ADR-090)
- Custom action implementations (use story-specific actions)
- Event reactions (use event handlers - ADR-052)

## Open Items

### Short Term (Next Session)
1. Tackle next category of unit test failures:
   - **Basket elevator** (7 failures) - needs capability dispatch for lowering/raising
   - **Trophy case scoring** (7 failures) - needs event handler for put_in + scoring system
   - **Troll recovery** (5 failures) - needs daemon/fuse for unconscious state
2. Continue reducing unit test failures toward zero (28 remaining)

### Medium Term
1. Create walkthrough transcripts for remaining regions:
   - Coal mine region
   - Volcano/torch room
   - Well/tea room
   - Mirror rooms
   - Royal puzzle
   - Thief interactions
   - Endgame sequence
2. Address README sample code (ISSUE-045) - references nonexistent PortableTrait

### Long Term
1. Complete all region walkthroughs for Dungeo
2. Achieve zero unit test failures
3. Performance optimization (if needed)
4. Documentation updates (architecture, patterns, examples)

## Files Modified

**Build System** (1 file):
- `build.sh` - Added `--alias` flags to esbuild command for all `@sharpee/*` packages

**Platform - Engine** (1 file):
- `packages/engine/src/command-executor.ts` - Removed debug console.warn logging

**Platform - Stdlib** (1 file):
- `packages/stdlib/src/actions/standard/taking/taking.ts` - Removed debug console.warn logging

**Documentation** (1 file):
- `docs/work/issues/issues-list-02.md` - Added ISSUE-046, updated test stats, updated failure categories

## Architectural Notes

### Build System Bundle Resolution

This session revealed a critical misunderstanding of esbuild's module resolution in monorepo contexts.

**The Problem**:
```
packages/stdlib/package.json:
{
  "main": "dist-npm/index.js",      // ESM for npm publish
  "exports": {
    ".": "./dist-npm/index.js"
  }
}

esbuild resolves @sharpee/stdlib → follows package.json → uses dist-npm/ (stale)
```

**The Solution**:
```bash
esbuild --bundle cli.ts \
  --alias:@sharpee/stdlib=packages/stdlib/dist \
  # ... (explicit paths for all packages)
```

**Lessons Learned**:
1. **Dual build outputs require explicit resolution** - Can't rely on package.json when you have multiple build targets
2. **Bundle testing is critical** - The bundle is what users actually run, not the individual packages
3. **esbuild --alias is canonical** - Overrides all other resolution mechanisms
4. **Separate concerns**: `dist/` for project builds, `dist-npm/` for npm publishing

### Action Interceptor Pattern (ADR-118)

**Verified working** with correct bundle build. Pattern is clean and effective for blocking-only logic.

**Example - Troll Axe**:
```typescript
// Trait declares interceptor capability
class TrollAxeTrait implements ITrait {
  static readonly type = 'dungeo.trait.troll_axe';
  static readonly interceptors = ['if.action.taking'] as const;
  guardianId: string;
}

// Interceptor blocks action before validation
const TrollAxeTakingInterceptor: ActionInterceptor = {
  preValidate(entity, world, actorId, sharedData) {
    const trait = entity.getTrait<TrollAxeTrait>('dungeo.trait.troll_axe');
    if (!trait) return undefined;

    const guardian = world.getEntity(trait.guardianId);
    if (!guardian || !world.isAlive(guardian.id)) {
      return undefined; // Allow taking if troll dead
    }

    return { messageId: 'dungeo.troll_axe.too_hot' }; // Block if troll alive
  }
};

// Registration in story initialization
registerActionInterceptor(
  TrollAxeTrait.type,
  'if.action.taking',
  TrollAxeTakingInterceptor
);
```

**Flow**:
1. Player types "take axe"
2. Taking action starts
3. **Interceptor fires first** (preValidate)
4. If troll alive → returns error → action blocked with custom message
5. If troll dead → returns undefined → action proceeds to validation/execution

**Benefits**:
- Clean separation of concerns (blocking logic separate from mutation)
- No need to replace stdlib action
- Custom messages without touching platform code
- Story-specific logic stays in story package

### Interceptor vs Capability Dispatch vs Event Handler

Updated decision matrix based on this session:

| Pattern | When to Use | Example |
|---------|------------|---------|
| **Interceptor** | Block action with custom message, no mutation | Troll axe (can't take while hot) |
| **Capability Dispatch** | Entity-specific mutation for verb | Basket (lower = move down) |
| **Event Handler** | React to completed action | Trophy case scoring |
| **Story Action** | New verb not in stdlib | SAY, INCANT, RING |

**Critical insight**: The build bug masked the interceptor pattern's success. Now verified working, it should be the first choice for blocking-only scenarios.

## Test Progress

**Unit Transcripts**: 1291 passed, 28 failed, 10 expected failures, 3 skipped

**Failure Reduction**:
- Jan 22, 2026: 756 failures
- Feb 1, 2026 (17:00): 29 failures
- Feb 1, 2026 (19:58): 28 failures
- **Total reduction**: 96.3% (728 failures resolved)

**Walkthrough Transcripts**: All 7 pass (148 tests, 595ms)

**Next Target**: Basket elevator (7 failures) or trophy case scoring (7 failures) - both tied for highest count.

## Notes

**Session duration**: ~2.5 hours

**Approach**: Root cause analysis - traced from "interceptor not firing" → "bundle has stale code" → "esbuild resolution bug" → "need explicit --alias flags"

**Breakthrough moment**: Realizing the bundle contained TWO copies of every package, with the stale ESM builds winning. The --alias flags were the simple, correct fix.

**Architecture validation**: The interceptor pattern (ADR-118) was always correct and working. The bug was in the build system, not the design.

**Build system learning**: In monorepos with multiple build targets (CJS for project, ESM for npm), explicit module resolution (`--alias`) is critical for bundlers. Can't rely on package.json defaults.

---

**Progressive update**: Session completed 2026-02-01 19:58
