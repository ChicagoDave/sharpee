# Session Summary: 2026-01-27 - main

## Status: Completed

## Goals
- Resolve the "where should state machines live?" question from ADR-119
- Design a scalable architecture for turn-cycle subsystems
- Document the full migration plan from hardcoded to plugin-based

## Completed

### State Machine Package Location Assessment

Created `/mnt/c/repotemp/sharpee/docs/work/platform/state-machine.md` - A comprehensive 806-line analysis evaluating five options for where the FSM runtime from ADR-119 should live.

**Initial Analysis** (Options 1-4):
- **New package** (`@sharpee/state-machine`) - Clean separation, independent testing, but adds build complexity
- **Engine** - Natural integration with turn cycle, scheduler analogy, but engine gets larger
- **Stdlib** - Wrong abstraction level, rejected
- **World-model** - Wrong responsibility (passive data vs active orchestration), rejected

**Evolution**: Discussion revealed that the real problem wasn't "where does FSM live?" but "why is engine hardcoded to know about NPCs, scheduler, and (soon) FSM?"

**Breakthrough** (Option 5): Engine Plugin Architecture
- Engine defines hook points in turn cycle
- All subsystems (NPC, scheduler, FSM) become plugins implementing `TurnPlugin`
- One shared event-processing pipeline replaces ~120 lines of duplicated boilerplate
- Engine shrinks by ~400 lines, becomes pure orchestrator
- Future subsystems don't modify engine - just create new plugins

### ADR-120: Engine Plugin Architecture

Created `/mnt/c/repotemp/sharpee/docs/architecture/adrs/adr-120-engine-plugin-architecture.md` - Formal proposal for plugin-based turn cycle.

**Core Contract**:
```typescript
interface TurnPlugin {
  id: string;
  priority: number;
  onAfterAction(context: TurnPluginContext): ISemanticEvent[];
  getState?(): unknown;
  setState?(state: unknown): void;
}
```

**Package Architecture**:
- `@sharpee/plugins` - Contract package (TurnPlugin interface, PluginRegistry)
- `@sharpee/plugin-scheduler` - Extract scheduler from engine
- `@sharpee/plugin-npc` - Extract NPC service from engine/stdlib
- `@sharpee/plugin-state-machine` - New FSM system (ADR-119)

**Migration Plan** (5 phases):
1. Foundation: Create `@sharpee/plugins` contract package
2. First plugin: Extract scheduler (~4 files)
3. Second plugin: Extract NPC service from stdlib
4. New plugin: Build state machine system as plugin from day one
5. Cleanup: Remove ~120 lines of duplicated boilerplate, collapsed into single `processPluginEvents()` method

**Engine Before/After**:
```typescript
// Before: Hardcoded subsystems, duplicated pipeline
if (result.success) {
  // NPC tick - ~45 lines: enrich, filter, store, emit
  const npcEvents = this.npcService.tick({ ... });
  // ... boilerplate ...

  // Scheduler tick - ~45 lines: same boilerplate
  const schedulerResult = this.scheduler.tick(...);
  // ... boilerplate ...
}

// After: Plugin loop, shared pipeline
if (result.success) {
  const ctx = this.buildPluginContext(result, turn);
  for (const plugin of this.pluginRegistry.getAll()) {
    const events = plugin.onAfterAction(ctx);
    this.processPluginEvents(events, turn);
  }
}
```

### ADR-119 Updates

Updated `/mnt/c/repotemp/sharpee/docs/architecture/adrs/adr-119-state-machines.md`:
- Added `Depends On: ADR-120` dependency
- Resolved Open Question #1 (Package Location) → `@sharpee/plugin-state-machine`
- Added ADR-120 to references section

Now ADR-119 has a clear answer: state machines live in `@sharpee/plugin-state-machine`, implementing the plugin contract from ADR-120.

## Key Decisions

### 1. Plugin Contract Lives in `@sharpee/plugins` (Not if-domain)

**Rationale**: `TurnPluginContext` needs `WorldModel`, but if-domain cannot depend on world-model (dependency flows the other direction). Creating a separate contract package avoids circular dependencies while keeping the plugin interface small and focused.

**Dependency Graph**:
```
core → if-domain → world-model → plugins → engine
                                         → plugin-*
```

### 2. All Turn-Cycle Subsystems Migrate to Plugins

**Scope**: Not just FSM - scheduler, NPC service, and any future subsystems all become plugins.

**Why Not Hybrid?**: Keeping scheduler hardcoded while making FSM a plugin would add the abstraction without the full benefit. The scheduler analogy (both are "story-registered, engine-evaluated, turn-cycle-integrated, serializable reactive systems") means they should use the same pattern.

### 3. Engine Becomes Thin Orchestrator

**What Engine Keeps**:
- Turn lifecycle (start/stop/counter)
- Command execution pipeline (parse → validate → execute → report)
- Action context creation
- Event sequencing
- Save/restore coordination
- Platform operations (save/restore/quit/undo/again)
- Plugin registry and event-processing pipeline

**What Engine Loses**:
- `scheduler/` directory (4 files → plugin-scheduler)
- NPC service creation and tick call (→ plugin-npc)
- Direct dependency on stdlib for `INpcService`
- ~120 lines of duplicated event-processing boilerplate

**Net Result**: ~400 lines removed, gains extensibility

### 4. Plugin Priority Convention

| Plugin | Priority | Rationale |
|--------|----------|-----------|
| NPC | 100 | NPCs act first - their actions may trigger FSM transitions |
| State Machine | 75 | Reacts to player action and NPC events |
| Scheduler | 50 | Temporal events run last - daemons/fuses are background |

Priority is a convention, not enforced - stories can adjust ordering.

### 5. Start Minimal on Hook Points

Initial contract has one hook: `onAfterAction`. Future hooks (`onBeforeAction`, `onAfterExecute`, `onGameStart`, `onGameEnd`) will be added only when concrete use cases require them.

**Philosophy**: Add hooks when something needs them, not speculatively.

## Architectural Notes

### The Scheduler Analogy Was the Key Insight

Compare scheduler (daemons/fuses) to state machines:

| Aspect | Scheduler | State Machines |
|--------|-----------|----------------|
| Registered by | Story at init | Story at init |
| Evaluated by | Engine, end of turn | Engine, during/after action |
| State stored | SchedulerState | FSM state |
| Reactive to | Turn ticks, conditions | Actions, events, conditions |
| Mutations via | Returns ISemanticEvent[] | Returns ISemanticEvent[] |

Structurally identical. If scheduler lives in engine, FSM should too - unless there's a reason to separate them. The plugin architecture provides that reason: both become plugins, engine loses knowledge of both.

### Why Not Simpler Options?

**Why not just put FSM in engine alongside scheduler?**
- Adds FSM (~10 files) to engine without solving the duplication problem
- Next subsystem (quest tracker, achievement system) means yet another hardcoded block
- Engine grows linearly with every turn-cycle participant

**Why not just extract FSM to new package, leave scheduler alone?**
- Inconsistent - two structurally identical subsystems treated differently
- Doesn't solve the boilerplate duplication problem
- Still means modifying engine for the next subsystem

**Why plugin architecture?**
- Solves the root problem (hardcoded subsystems, duplicated pipeline)
- Makes engine extensible without modification (Open/Closed Principle)
- All subsystems use same pattern - consistency
- One-time investment pays off for every future subsystem

### Relationship to ADR-119 Open Questions

This resolves ADR-119 Question #1 (Package Location) and partially resolves Question #3 (Action Ownership):

- **Package location**: `@sharpee/plugin-state-machine`, consumed by engine via `TurnPlugin`
- **Action ownership**: Plugin evaluates transitions in `onAfterAction` - mutations happen after the action completes, but are triggered by the action's result. This is "Option B" from ADR-119 but framed as a plugin rather than engine magic.

The ADR-051 concern ("actions own mutations") is less problematic in this model. The FSM plugin fires after the action's four phases complete. It's a reactive system, like event handlers, not a mutation within the action.

## Open Items

### Short Term
- Get user approval for ADR-120 (plugin architecture)
- Begin Phase 1 implementation: `@sharpee/plugins` contract package
- Update `build.sh` with new package targets

### Long Term
- Phase 2: Extract scheduler to `@sharpee/plugin-scheduler`
- Phase 3: Extract NPC service to `@sharpee/plugin-npc`
- Phase 4: Implement state machines as `@sharpee/plugin-state-machine`
- Phase 5: Remove dead code from engine, verify 148 walkthrough tests pass

## Files Modified

**Documentation** (3 files):
- `/mnt/c/repotemp/sharpee/docs/work/platform/state-machine.md` - New assessment document (806 lines)
- `/mnt/c/repotemp/sharpee/docs/architecture/adrs/adr-120-engine-plugin-architecture.md` - New ADR (323 lines)
- `/mnt/c/repotemp/sharpee/docs/architecture/adrs/adr-119-state-machines.md` - Updated dependency and resolution

## Design Evolution

**Starting Question**: "Where should the FSM runtime from ADR-119 live?"

**Initial Frame**: Four options - new package, engine, stdlib, world-model

**Shift**: "Actually, why is engine hardcoded to know about NPCs and scheduler?"

**Breakthrough**: "What if all turn-cycle subsystems are plugins?"

**Final Architecture**: Plugin-based engine with all subsystems (NPC, scheduler, FSM) extracted to plugin packages

This is a good example of how asking "where does X go?" can reveal deeper architectural questions. The FSM package location question led to discovering that engine has a structural problem (hardcoded subsystems, duplicated boilerplate) that affects more than just FSM.

## Notes

**Session duration**: ~2 hours

**Approach**: Started with focused assessment of FSM package location, evolved into broader plugin architecture proposal. Created detailed migration plan with 5 phases to minimize risk.

**Key Insight**: The scheduler analogy (both FSM and scheduler are turn-cycle reactive systems) was the pivot point. Once we saw they're structurally identical, the question became "should we treat identical things differently?" Answer: No - use same pattern for both.

**Prior Art**: Unity MonoBehaviour, Unreal Subsystems, Webpack Tapable, VSCode Extensions all use plugin/hook patterns. This is a well-established solution to the "host with extensible behavior" problem.

**Risk Mitigation**: 5-phase plan allows incremental migration. Each phase validates the pattern before the next. Phase 1 is additive (no breaking changes). Phases 2-3 extract existing code. Phase 4 builds new code on proven foundation. Phase 5 cleanup is safe because walkthrough tests catch any missed wiring.

**Backward Compatibility**: We don't care about it (per CLAUDE.md), but the plan supports it - Phase 1 adds plugin loop without removing hardcoded code. Both run in parallel. Subsequent phases remove old code once plugins are proven.

**Package Count**: Goes from 14 to 18 packages (+4). Acceptable because:
- Each new package has clear single responsibility
- Build script handles package orchestration
- Only one story (dungeo) currently, so no broad ecosystem impact
- Engine shrinks by ~400 lines - net complexity reduction

---

**Progressive update**: Session completed 2026-01-27 22:54
