# Session Summary: 2026-01-29 - main

## Status: Completed (with revert planned)

## Goals
- Implement ADR-123 typed daemon hierarchy with serialization support
- Migrate existing daemons to use base classes
- Assess real-world value of the class abstraction

## Completed

### Phase 1: ADR-123 Implementation

#### Created Base Class Hierarchy
Created 5 base classes in `packages/plugin-scheduler/src/daemons/`:
- **DaemonRunner** - Base class for simple stateful daemons
- **WatchdogDaemon** - Base for condition-checking daemons (checks every N turns)
- **LocationDaemon** - Base for daemons tied to player location
- **AmbienceDaemon** - Base for random ambient events (extends LocationDaemon)
- **CountdownDaemon** - Base for countdown timers with completion handlers

Each base class includes:
- Standard lifecycle methods (`tick`, `pause`, `resume`, `stop`)
- Serialization hooks (`getRunnerState`/`restoreRunnerState`)
- Common patterns abstracted from existing daemons

#### Added Serialization Infrastructure
Modified `packages/plugin-scheduler/src/types.ts`:
- Added `getRunnerState(): Record<string, unknown>` to Daemon interface
- Added `restoreRunnerState(state: Record<string, unknown>): void` to Daemon interface
- Added `runnerState?: Record<string, unknown>` to DaemonState type

Modified `packages/plugin-scheduler/src/scheduler-service.ts`:
- `getState()` now captures runner state via `daemon.getRunnerState()`
- `setState()` now restores runner state via `daemon.restoreRunnerState(runnerState)`
- Enables save/load preservation of daemon internal state

#### Migrated 6 Daemons to Typed Runners

**CryptRitualDaemon** (WatchdogDaemon):
- Endgame trigger that monitors crypt ritual state
- File: `stories/dungeo/src/endgame/crypt-ritual-daemon.ts`
- Uses watchdog pattern (checks every 3 turns)
- State: `ritualsCompleted`, `endgameTriggered`

**TrollRecoveryRunner** (DaemonRunner):
- Handles troll knockout recovery after combat
- File: `stories/dungeo/src/npcs/troll/troll-recovery-runner.ts`
- State: `turnsRemaining` (counts down from 10)
- Uses no base class features (just extends DaemonRunner)

**ForestAmbienceRunner** (LocationDaemon):
- Emits random forest sounds in forest locations
- File: `stories/dungeo/src/regions/forest/forest-ambience-daemon.ts`
- State: `turnsSinceLastAmbience`, `ambienceInterval`
- Randomizes interval between 8-12 turns

**BatRoomRunner** (LocationDaemon):
- Vampire bat ambience in bat room
- File: `stories/dungeo/src/regions/bat-room/bat-room-daemon.ts`
- State: `turnsSinceLastBat`, `batInterval`
- Similar pattern to forest ambience

**SwordGlowRunner** (DaemonRunner):
- Sword glows when near trolls/thief
- File: `stories/dungeo/src/regions/sword-glow/sword-glow-daemon.ts`
- State: `lastGlowState` (tracks whether sword was glowing)
- Detects state changes and emits glow/dim messages

**ExorcismRunner** (LocationDaemon):
- Monitors bell/book/candle ritual in South Temple
- File: `stories/dungeo/src/regions/south-temple-daemon.ts`
- State: `requiredItems`, `exorcismComplete`
- Checks for all three items present each turn

**Post-Migration Cleanup**:
- Deleted old factory-function files after each migration
- Updated exports in `packages/plugin-scheduler/src/index.ts`
- All 148/148 walkthroughs passed throughout implementation

### Phase 2: Honest Reassessment & Decision to Revert

#### Realizations During Implementation

**Minimal Code Reuse**:
- LocationDaemon saves exactly one line (`this.getPlayerLocation(world)`)
- TrollRecoveryRunner uses zero features from DaemonRunner base class
- ForestAmbienceRunner is actually longer than the factory function it replaced
- AmbienceDaemon and CountdownDaemon base classes exist but nothing uses them

**Each Daemon is Unique**:
- Daemons have quirky, puzzle-specific logic that doesn't fit clean abstractions
- Watchdog pattern sounds good in theory, but CryptRitualDaemon is the only watchdog
- Ambience pattern only applies to forest sounds (bat room is similar but different enough)
- Countdown pattern has no users (troll recovery counts down but doesn't use CountdownDaemon)

**Over-Engineering**:
- The class hierarchy creates cognitive overhead without delivering value
- Pattern taxonomies look clean on paper but don't match messy reality
- Forcing daemons into base classes adds boilerplate, not clarity

#### The Real Value: Serialization

The **serialization infrastructure is genuinely useful**:
- `getRunnerState()`/`restoreRunnerState()` on Daemon interface: KEEP
- `runnerState` field on DaemonState: KEEP
- Scheduler save/restore integration: KEEP
- Allows save/load to preserve daemon internal state

The **class hierarchy provides minimal value**:
- Base classes abstract patterns that only apply to 1-2 daemons each
- Factory functions are simpler, more flexible, and just as testable
- Each daemon needs serialization hooks regardless of base class

#### Decision: Revert to Factory Functions + Serialization

**Keep**:
- Serialization hooks on Daemon interface
- Scheduler save/restore integration
- The concept of serializable daemon state

**Revert**:
- All 5 base classes (DaemonRunner, WatchdogDaemon, LocationDaemon, AmbienceDaemon, CountdownDaemon)
- All 6 daemon migrations back to factory functions
- Update ADR-123 status from ACCEPTED to PROPOSED (noting serialization adopted, hierarchy rejected)

#### Created Undo Plan

Wrote comprehensive revert plan: `docs/work/platform/undo-daemon-work.md`

**Checklist format with 6 main steps**:
1. Revert plugin-scheduler base classes
2. Revert crypt ritual daemon
3. Revert troll recovery daemon
4. Revert forest ambience daemon
5. Revert bat room daemon
6. Revert sword glow daemon (add serialization)
7. Revert exorcism daemon
8. Update ADR-123

**Special case**: sword-glow-daemon.ts is the only daemon that actually needs serialization (tracks `lastGlowState`). The factory function version needs explicit `getRunnerState`/`restoreRunnerState` hooks added.

## Key Decisions

### 1. Serialization Infrastructure is Worth Keeping

**Rationale**: Several daemons need to preserve internal state across save/load:
- Sword glow needs `lastGlowState` to detect transitions
- Forest ambience needs `turnsSinceLastAmbience` for timing
- Troll recovery needs `turnsRemaining` for countdown

Adding serialization hooks to the Daemon interface is a clean, minimal solution that works for both class-based and factory-function daemons.

**Impact**: Keep serialization changes in types.ts and scheduler-service.ts. Only sword-glow-daemon needs explicit hooks in its factory function.

### 2. Class Hierarchy is Over-Engineering

**Rationale**:
- Pattern taxonomies don't match the messy reality of puzzle-specific game logic
- Each daemon is unique enough that base classes provide minimal reuse
- LocationDaemon saves one line, TrollRecoveryRunner uses zero base features
- AmbienceDaemon and CountdownDaemon have no users at all

**Impact**: Revert all base classes and migrations. Factory functions + serialization hooks is simpler and sufficient.

### 3. ADR-123 Status: Partially Accepted

**Rationale**: The ADR had two main proposals:
1. Typed daemon hierarchy with base classes - **REJECTED** (over-engineering)
2. Serialization support for daemon state - **ACCEPTED** (genuinely useful)

**Impact**: Update ADR-123 to reflect split decision. Keep serialization infrastructure, remove hierarchy recommendation.

## Open Items

### Short Term
- Execute undo plan from `docs/work/platform/undo-daemon-work.md`
- Add serialization hooks to factory-function version of sword-glow-daemon.ts
- Update ADR-123 status and rationale
- Verify all 148 walkthroughs still pass after revert
- Delete base class files from `packages/plugin-scheduler/src/daemons/`

### Long Term
- Consider whether other daemons need serialization (currently only sword glow)
- Document serialization pattern in core-concepts.md if more daemons adopt it
- Future daemons should use factory functions + serialization hooks (not base classes)

## Files Modified

### Platform (Serialization - KEEP)
- `packages/plugin-scheduler/src/types.ts` - Added getRunnerState/restoreRunnerState to Daemon interface, runnerState to DaemonState
- `packages/plugin-scheduler/src/scheduler-service.ts` - Save/restore runner state in getState/setState

### Platform (Base Classes - REVERT)
- `packages/plugin-scheduler/src/index.ts` - Export base classes (revert to just types)
- `packages/plugin-scheduler/src/daemons/daemon-runner.ts` - Created, to be deleted
- `packages/plugin-scheduler/src/daemons/watchdog-daemon.ts` - Created, to be deleted
- `packages/plugin-scheduler/src/daemons/location-daemon.ts` - Created, to be deleted
- `packages/plugin-scheduler/src/daemons/ambience-daemon.ts` - Created, to be deleted
- `packages/plugin-scheduler/src/daemons/countdown-daemon.ts` - Created, to be deleted

### Story (Migrations - ALL REVERT)
- `stories/dungeo/src/endgame/crypt-ritual-daemon.ts` - Migrated to WatchdogDaemon (revert)
- `stories/dungeo/src/npcs/troll/troll-recovery-runner.ts` - Migrated to DaemonRunner (revert)
- `stories/dungeo/src/regions/forest/forest-ambience-daemon.ts` - Migrated to LocationDaemon (revert)
- `stories/dungeo/src/regions/bat-room/bat-room-daemon.ts` - Migrated to LocationDaemon (revert)
- `stories/dungeo/src/regions/sword-glow/sword-glow-daemon.ts` - Migrated to DaemonRunner (revert + add serialization)
- `stories/dungeo/src/regions/south-temple-daemon.ts` - Migrated to LocationDaemon (revert)

### Documentation
- `docs/work/platform/undo-daemon-work.md` - Comprehensive revert plan with checklist

## Architectural Notes

### Pattern Recognition vs. Reality

This session is a great lesson in **when abstraction helps vs. when it hurts**:

**Abstraction helps when**:
- Multiple implementations share significant logic (not just one line)
- The pattern is stable and well-understood
- The abstraction reduces cognitive load

**Abstraction hurts when**:
- Each "instance" of the pattern is quirky and unique
- The base class forces awkward inheritance just to get one helper
- The taxonomy looks clean on paper but doesn't match messy reality

### Factory Functions + Composition > Class Hierarchy

Sharpee already follows this principle elsewhere:
- Behaviors are objects with methods, not classes
- Action definitions are objects, not classes
- Traits can be classes but often aren't

Daemons should follow the same pattern:
- Factory function returns a Daemon object
- Daemon object implements the interface (tick/pause/resume/stop + serialization)
- No forced inheritance, maximum flexibility

### The Value of Serialization Hooks

The **real win** from this work is the serialization infrastructure:
- `getRunnerState()` / `restoreRunnerState()` on Daemon interface
- Scheduler integration for save/load
- Preserves daemon internal state across sessions

This is valuable whether daemons are classes or factory functions. The interface method approach works for both.

## Testing Notes

- All 148 walkthroughs passed throughout Phase 1 implementation
- No regression from adding base classes or migrating daemons
- Serialization infrastructure is testable (can verify save/load preserves state)
- After revert, expect same 148/148 pass rate

## Lessons Learned

### 1. Implement First, Assess Second

ADR-123 looked good in theory, but the value only became clear during implementation:
- LocationDaemon: "This just saves one line"
- TrollRecoveryRunner: "Why am I extending DaemonRunner? I use nothing from it"
- AmbienceDaemon: "I created this class but nothing uses it"

**Takeaway**: Paper design can't predict real-world fit. Build it, use it, then decide.

### 2. Split Decisions Are Valid

ADR-123 had two proposals. We're keeping one (serialization) and rejecting the other (hierarchy). That's fine! ADRs can have nuanced outcomes.

**Takeaway**: Update the ADR to reflect what we learned. Future readers benefit from understanding why the hierarchy was rejected.

### 3. Simplicity Wins

Factory functions + serialization hooks is simpler than base classes + inheritance:
- Less ceremony (no extends, super(), protected)
- More flexible (can return any object shape)
- Just as testable and type-safe

**Takeaway**: Prefer composition and simple patterns. Only use classes when they genuinely reduce complexity.

## Notes

**Session duration**: ~2 hours (implementation + assessment + planning)

**Approach**:
1. Implemented ADR-123 fully and carefully
2. Migrated real daemons to base classes
3. Observed minimal code reuse and awkward fits
4. Made honest assessment: hierarchy isn't worth the complexity
5. Created detailed revert plan for next session

**Honesty over pride**: The class hierarchy looked clean in the ADR, but implementation revealed it was over-engineering. Better to recognize this and revert than to force it.

**Next session**: Execute undo plan, preserve serialization infrastructure, update ADR-123 to reflect split decision.

---

**Progressive update**: Session completed 2026-01-29 04:33 - Honest assessment led to planned revert
