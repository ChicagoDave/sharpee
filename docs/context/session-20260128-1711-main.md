# Session Summary: 2026-01-28 - main

## Status: In Progress (Debugging)

## Goals
- Implement ADR-120 Phase 4: Create @sharpee/plugin-state-machine package
- Implement ADR-119: Declarative state machine runtime
- Migrate first handler (trapdoor) to state machine pattern
- Verify walkthrough transcripts continue passing

## Completed

### @sharpee/plugin-state-machine Package Creation

Created full declarative state machine plugin with comprehensive type system and runtime:

**Package Structure** (8 new files):
- `packages/plugin-state-machine/package.json` - Dependencies on core, world-model, plugins
- `packages/plugin-state-machine/tsconfig.json` - TypeScript configuration
- `packages/plugin-state-machine/src/index.ts` - Barrel exports for public API
- `packages/plugin-state-machine/src/types.ts` - Complete type system (see below)
- `packages/plugin-state-machine/src/guard-evaluator.ts` - Condition evaluation engine
- `packages/plugin-state-machine/src/effect-executor.ts` - World mutation engine
- `packages/plugin-state-machine/src/state-machine-runtime.ts` - Registry and execution
- `packages/plugin-state-machine/src/state-machine-plugin.ts` - TurnPlugin wrapper

**Type System** (`types.ts`):
```typescript
// Core definition structure
StateMachineDefinition {
  id: string
  name: string
  states: Record<string, StateDefinition>
  initialState: string
}

StateDefinition {
  name: string
  transitions?: TransitionDefinition[]  // Optional for terminal states
}

TransitionDefinition {
  targetState: string
  trigger: ActionTrigger | EventTrigger | ConditionTrigger
  guard?: Guard
  effects: Effect[]
}

// Trigger types
ActionTrigger { type: 'action', actionId: string, filter?: object }
EventTrigger { type: 'event', eventId: string, filter?: object }
ConditionTrigger { type: 'condition' }

// Guard types (declarative conditions)
EntityGuard { type: 'entity', entityRef: string, hasTrait?: string, condition?: object }
StateGuard { type: 'state', stateRef: string, equals: string }
LocationGuard { type: 'location', entityRef: string, locationRef: string }
InventoryGuard { type: 'inventory', entityRef: string, hasItem: string }
CompositeGuard { type: 'and' | 'or', guards: Guard[] }
CustomGuard { type: 'custom', evaluate: (context, bindings, world) => boolean }

// Effect types (declarative mutations)
MoveEntityEffect { type: 'move_entity', entityRef: string, toRef: string }
SetTraitEffect { type: 'set_trait', entityRef: string, traitType: string, updates: object }
SetStateEffect { type: 'set_state', stateRef: string, newState: string }
MessageEffect { type: 'message', messageId: string, data?: object }
EmitEventEffect { type: 'emit_event', eventId: string, data: object }
RemoveEntityEffect { type: 'remove_entity', entityRef: string }
CustomEffect { type: 'custom', execute: (context, bindings, world) => void }
```

**Guard Evaluator** (`guard-evaluator.ts`):
- Resolves `$`-prefixed entity references from bindings (e.g., `$trapdoor` → actual entity ID)
- Evaluates entity conditions (trait presence, trait property values)
- Checks state machine states
- Verifies entity locations and inventory containment
- Handles composite AND/OR logic
- Invokes custom guard functions with full context

**Effect Executor** (`effect-executor.ts`):
- Applies world mutations (entity movement via `world.moveEntity()`)
- Updates trait properties via `world.mutate()` with TraitPatcher
- Changes state machine states
- Emits semantic events and messages
- Removes entities from world
- Executes custom effect callbacks

**State Machine Runtime** (`state-machine-runtime.ts`):
- `StateMachineRegistry` singleton
- Register/unregister machines with entity bindings map
- Per-turn evaluation: check all registered machines for transition triggers
- Serialization/restoration for save/load support
- Execution: evaluate guard → apply effects → transition state

**Turn Plugin Integration** (`state-machine-plugin.ts`):
- Implements `TurnPlugin` interface
- Priority 75 (between NPCs at 100 and scheduler at 50)
- `executeTurn()` delegates to registry's `evaluateTransitions()`
- Automatically participates in turn cycle

### Build System Integration

**Modified Files**:
- `build.sh` - Added `plugin-state-machine` to PACKAGES array after `plugin-npc`
- `stories/dungeo/package.json` - Added `"@sharpee/plugin-state-machine": "workspace:*"` dependency
- `stories/dungeo/tsconfig.json` - Added path mapping for `@sharpee/plugin-state-machine`

### Engine Fix: Pass Action Context to Plugins

**Problem**: The `TurnPluginContext` interface defined `actionResult` and `actionEvents` fields, but `GameEngine.runTurn()` never populated them when calling plugins.

**Solution** (`packages/engine/src/game-engine.ts`):
```typescript
// After action execution, populate plugin context with action results
const pluginContext: TurnPluginContext = {
  // ... existing fields ...
  actionResult: result.validatedCommand
    ? {
        actionId: result.validatedCommand.actionId,
        success: result.success,
        targetId: result.validatedCommand.slots?.target,
      }
    : undefined,
  actionEvents: effectStream,
};
```

This enables EventTrigger and ActionTrigger to detect specific actions and events in state machine transitions.

### First Handler Migration: Trapdoor State Machine

**Created** `stories/dungeo/src/state-machines/trapdoor-machine.ts`:

Converted the trapdoor puzzle from imperative handler to declarative state machine:

**States**:
1. `open` - Initial state (rug present, trapdoor open, exit available)
2. `barred` - Terminal state (rug gone, trapdoor closed/locked, no exit)

**Transition**:
```typescript
{
  targetState: 'barred',
  trigger: {
    type: 'event',
    eventId: 'if.event.actor_moved',
    filter: {
      fromRoom: '$livingRoom',
      toRoom: '$cellar'
    }
  },
  effects: [
    { type: 'remove_entity', entityRef: '$rug' },
    {
      type: 'set_trait',
      entityRef: '$trapdoor',
      traitType: 'openable',
      updates: { isOpen: false, isLocked: true }
    },
    {
      type: 'set_trait',
      entityRef: '$trapdoor',
      traitType: 'identity',
      updates: { description: 'The door is closed, and is securely fastened with a heavy iron bolt.' }
    },
    {
      type: 'custom',
      execute: (context, bindings, world) => {
        const cellarId = bindings.get('$cellar');
        const exits = world.getExits(cellarId);
        // Delete the UP exit
      }
    }
  ]
}
```

**Key Insight**: Using `EventTrigger` with `if.event.actor_moved` and a filter on `fromRoom`/`toRoom` eliminates the need for a tracking daemon. The event system already provides room transition context.

**Story Integration** (`stories/dungeo/src/orchestration/index.ts`):
```typescript
import { StateMachinePlugin, StateMachineRegistry } from '@sharpee/plugin-state-machine';
import { trapdoorMachine } from '../state-machines/trapdoor-machine';

// Helper to find entities by name
function findEntityByName(world: WorldModel, name: string): string | undefined {
  return world.getAllEntities().find(e =>
    world.getTraitByType(e.id, 'identity')?.name === name
  )?.id;
}

// In orchestration.create():
const plugin = new StateMachinePlugin();
engine.getPluginRegistry().register(plugin);

// Register trapdoor state machine with entity bindings
const bindings = new Map([
  ['$trapdoor', findEntityByName(world, 'trapdoor')!],
  ['$rug', findEntityByName(world, 'oriental rug')!],
  ['$livingRoom', findEntityByName(world, 'living room')!],
  ['$cellar', findEntityByName(world, 'cellar')!]
]);
StateMachineRegistry.getInstance().register(
  trapdoorMachine,
  world,
  'trapdoor-instance',
  bindings
);
```

**Removed** trapdoor handler registration from `scheduler-setup.ts`.

### Testing Results

**Walkthrough Transcripts**: All 148 tests PASS
```
wt-01-get-torch-early.transcript: 23/23 tests passed
wt-02-white-house-to-cellar.transcript: 25/25 tests passed
wt-03-living-room-check.transcript: 11/11 tests passed
wt-04-troll-puzzle.transcript: 17/17 tests passed
wt-05-buttons-and-dam.transcript: 52/52 tests passed
wt-06-coal-machine-bottle.transcript: 11/11 tests passed
wt-07-magic-word.transcript: 9/9 tests passed
```

The trapdoor state machine works perfectly in walkthrough mode.

## Key Decisions

### 1. Trait Type Strings Are Lowercase

**Issue**: During build, `set_trait` effects failed to find traits using class name strings like `'OpenableTrait'`.

**Resolution**: Trait types are registered as lowercase strings (`'openable'`, `'identity'`, `'container'`). Updated all `set_trait` effects to use lowercase:

```typescript
// WRONG
{ type: 'set_trait', traitType: 'OpenableTrait', ... }

// CORRECT
{ type: 'set_trait', traitType: 'openable', ... }
```

### 2. StateDefinition.transitions Made Optional

**Rationale**: Terminal states (like trapdoor's `barred` state) don't transition anywhere. Requiring an empty `transitions: []` array is redundant.

**Change**: Updated `StateDefinition` interface:
```typescript
transitions?: TransitionDefinition[];  // Was: transitions: TransitionDefinition[]
```

### 3. EventTrigger Eliminates Tracking Daemons

**Insight**: The trapdoor puzzle previously used a daemon to track player's previous location and detect entering the cellar from the living room.

**Better Approach**: The `if.event.actor_moved` event already carries `fromRoom` and `toRoom` in its data. State machines can filter on these fields declaratively:

```typescript
{
  type: 'event',
  eventId: 'if.event.actor_moved',
  filter: {
    fromRoom: '$livingRoom',
    toRoom: '$cellar'
  }
}
```

No polling, no state tracking, fully declarative.

### 4. Escape Hatches: CustomGuard and CustomEffect

**Design Philosophy**: State machines are 90% declarative, but complex logic (like deleting specific exits, score calculations) needs programmatic escape hatches.

**Implementation**:
- `CustomGuard`: Accepts an `evaluate()` function with full context
- `CustomEffect`: Accepts an `execute()` function that can mutate world directly

**Future Work**: Add more declarative effect types (e.g., `BlockExitEffect`, `ModifyScoreEffect`) to reduce need for custom effects.

## Open Items

### Critical: Hang in Play Mode and Unit Transcripts

**Symptom**:
- `node dist/sharpee.js --play` hangs at "Loading story from: stories/dungeo"
- `node dist/sharpee.js --test <single-file.transcript>` also hangs
- `node dist/sharpee.js --test --chain <files>` works perfectly (148/148 pass)

**Investigation Needed**:

The hang was initially suspected to be new, but testing with `git stash` suggested it might be pre-existing. However, **this needs re-verification** as the git stash test was interrupted. The fact that `--chain` mode works but single-file mode doesn't is suspicious.

**Possible Causes**:

1. **State machine registration during orchestration**:
   - `findEntityByName()` iterates over `getAllEntities()` - could behave differently in non-chain mode
   - Plugin registration might interfere with story loading lifecycle

2. **Engine action context change**:
   - Populating `actionResult`/`actionEvents` in plugin context could cause issues if `result.validatedCommand` has unexpected shape in some code paths
   - Might only manifest in certain initialization sequences (play/single-test vs chain)

3. **Pre-existing transcript runner issue**:
   - Less likely since play mode also hangs
   - Would need to check if unit transcript runner has different initialization

**Next Steps**:

1. Temporarily comment out state machine registration in `orchestration/index.ts`
2. Test play mode - if still hangs, it's not the state machine
3. If play mode works, add back state machine registration but skip the `findEntityByName()` calls (hardcode dummy IDs)
4. Isolate whether the issue is in entity lookup, plugin registration, or the machine definition itself
5. If state machine is fine, revert engine changes and test again

**Workaround**: Walkthrough chain mode (`--chain`) works perfectly for integration testing. Development can continue using this mode while debugging the hang.

### Short Term

- **Debug hang issue** - Isolate cause (state machine vs engine vs pre-existing)
- **Add BlockExitEffect** - Eliminate CustomEffect from trapdoor machine
- **Test state machine save/load** - Verify serialization works in practice
- **Migrate second handler** - Choose another simple handler (thief appearance?) to validate pattern

### Long Term

- **Migrate all event handlers to state machines** - 15+ remaining handlers in dungeo
- **ADR-120 Phase 5** - Extract remaining services (combat, inventory, etc.)
- **Documentation** - Write guide for authoring state machines
- **Developer tools** - State machine visualization, debugging UI

## Files Modified

### New Files (9 total)

**Plugin Package** (8 files):
- `packages/plugin-state-machine/package.json` - Package definition
- `packages/plugin-state-machine/tsconfig.json` - TypeScript config
- `packages/plugin-state-machine/src/types.ts` - Type system (triggers, guards, effects)
- `packages/plugin-state-machine/src/guard-evaluator.ts` - Condition evaluation
- `packages/plugin-state-machine/src/effect-executor.ts` - World mutations
- `packages/plugin-state-machine/src/state-machine-runtime.ts` - Registry and execution
- `packages/plugin-state-machine/src/state-machine-plugin.ts` - TurnPlugin wrapper
- `packages/plugin-state-machine/src/index.ts` - Barrel exports

**Story Files** (1 file):
- `stories/dungeo/src/state-machines/trapdoor-machine.ts` - Trapdoor puzzle as state machine

### Modified Files (6 total)

**Build System** (1 file):
- `build.sh` - Added plugin-state-machine to PACKAGES array

**Engine** (1 file):
- `packages/engine/src/game-engine.ts` - Populate actionResult/actionEvents in plugin context

**Story Configuration** (2 files):
- `stories/dungeo/package.json` - Added plugin-state-machine dependency
- `stories/dungeo/tsconfig.json` - Added plugin-state-machine path mapping

**Story Orchestration** (2 files):
- `stories/dungeo/src/orchestration/index.ts` - Register state machine plugin and trapdoor machine
- `stories/dungeo/src/orchestration/scheduler-setup.ts` - Removed trapdoor handler registration

## Architectural Notes

### State Machine Plugin Architecture

The state machine plugin follows Sharpee's standard plugin pattern:

**Lifecycle Integration**:
1. Plugin registered with `PluginRegistry` during orchestration setup
2. Engine calls `executeTurn()` at priority 75 (after NPCs, before scheduler)
3. Plugin delegates to `StateMachineRegistry.evaluateTransitions()`
4. Registry checks all registered machines for transition triggers
5. Matching transitions execute: evaluate guards → apply effects → transition state

**Turn Order**:
```
Priority 100: NPC Plugin (NPCs take actions)
Priority 75:  State Machine Plugin (puzzle state updates)
Priority 50:  Scheduler Service (daemons/fuses fire)
```

This ensures state machines react to NPC actions but run before time-based events.

### Entity Binding Pattern

State machines are generic - the same machine can control multiple puzzle instances. Entity bindings map placeholder names to actual entity IDs:

```typescript
// Generic machine definition
const machine = {
  id: 'trapdoor',
  // Uses $trapdoor, $rug, $livingRoom, $cellar
};

// Bind to specific entities when registering
const bindings = new Map([
  ['$trapdoor', livingRoomTrapdoorId],
  ['$rug', orientalRugId],
  // ...
]);

StateMachineRegistry.getInstance().register(
  machine,
  world,
  'instance-1',  // Unique instance ID
  bindings
);
```

This allows:
- Reusable puzzle templates
- Multiple instances of same puzzle in different locations
- Clear separation between logic and content

### EventTrigger Design Pattern

**Key Insight**: Events already carry rich context. Use filters to match specific scenarios without custom tracking logic.

**Example - Room Transitions**:
```typescript
// OLD WAY: Track previous location with daemon
const trackingDaemon = {
  execute() {
    const currentRoom = world.getLocation(playerId);
    if (prevRoom === livingRoomId && currentRoom === cellarId) {
      // Spring trap
    }
    prevRoom = currentRoom;
  }
};

// NEW WAY: Filter on event data
{
  trigger: {
    type: 'event',
    eventId: 'if.event.actor_moved',
    filter: {
      fromRoom: '$livingRoom',
      toRoom: '$cellar'
    }
  }
}
```

**Benefits**:
- No polling (runs only when event fires)
- No state tracking (event carries all context)
- Declarative (clear what condition is being checked)
- Reusable (same pattern for all room-transition puzzles)

### Trait Property Updates

The `set_trait` effect uses the same mutation system as action execute phases:

```typescript
// Effect definition
{
  type: 'set_trait',
  entityRef: '$trapdoor',
  traitType: 'openable',
  updates: { isOpen: false, isLocked: true }
}

// Execution (effect-executor.ts)
world.mutate(entity, traitType, (trait) =>
  TraitPatcher.patch(trait, updates)
);
```

This ensures:
- Type safety (TraitPatcher validates property types)
- Audit trail (mutations are tracked)
- Consistency (same system as actions use)

## Notes

**Session duration**: ~2 hours (21:49 start, debugging ongoing at 23:11)

**Approach**: Incremental implementation with continuous testing. Built type system → evaluators → runtime → plugin wrapper → story integration → handler migration. Verified walkthroughs pass after each major step.

**Next Session Goals**:
1. Resolve hang issue (critical blocker)
2. Migrate second handler to validate pattern further
3. Begin systematic migration of remaining 15+ handlers

---

**Progressive update**: Session active - debugging hang issue - 2026-01-28 17:11 CST
