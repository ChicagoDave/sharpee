# Session Summary: 2026-01-29 03:00 - main

## Status: Completed

## Goals
- Migrate reality-altered handler to declarative state machine pattern (ADR-119/120)
- Migrate victory handler to declarative state machine pattern (ADR-119/120)
- Continue systematically replacing imperative handlers with declarative state machines

## Completed

### Reality-Altered Handler → State Machine Migration

Migrated the reality-altered handler from two-phase imperative approach (event handler + daemon) to declarative state machine.

**New file**: `stories/dungeo/src/state-machines/reality-altered-machine.ts`

**States**:
- `inactive` → waiting for thief death and player to check score
- `shown` → message displayed (terminal)

**Transition**:
- Triggered by `if.event.score_displayed` event
- Guard checks `scoring.realityAlteredPending === true`
- Single `CustomEffect` clears both pending/queued flags and emits the message

**Design choices**:
- Collapsed the old two-phase approach (event handler sets flag → daemon checks flag each turn) into a single transition triggered by the score event
- Uses `StandardCapabilities.SCORING` to access scoring capability for state checks
- Terminal state machine (never transitions back) - simpler than rainbow's bidirectional pattern
- No entity bindings needed (pure scoring logic)

**Files modified**:
- `stories/dungeo/src/state-machines/reality-altered-machine.ts` — New terminal state machine
- `stories/dungeo/src/orchestration/index.ts` — Registered reality-altered machine
- `stories/dungeo/src/orchestration/scheduler-setup.ts` — Removed daemon registration
- `stories/dungeo/src/index.ts` — Removed event handler registration

**Old handler** (`stories/dungeo/src/handlers/reality-altered-handler.ts`) left in place but no longer wired up.

### Victory Handler → State Machine Migration

Migrated the victory handler from daemon polling to declarative state machine.

**New file**: `stories/dungeo/src/state-machines/victory-machine.ts`

**States**:
- `playing` → game in progress (initial)
- `victory` → player has won (terminal)

**Transition**:
- Triggered by `if.event.actor_moved` event with `filter: { toRoom: treasuryId }`
- StateGuard checks `game.endgameStarted === true`
- `CustomEffect` awards 35 points, sets victory/ended state, emits 4 messages + victory event

**Design choices**:
- Event-driven instead of daemon polling (more efficient, clearer logic)
- Uses `StateGuard` for simple boolean check (cleaner than custom guard)
- Event filter on `toRoom` ensures machine only reacts to Treasury entrance
- Parameterized with `treasuryId` from config (reusable pattern)
- Emits `game.victory` event for potential future handlers

**Files modified**:
- `stories/dungeo/src/state-machines/victory-machine.ts` — New terminal state machine with room filter and state guard
- `stories/dungeo/src/orchestration/index.ts` — Registered victory machine with treasury ID from config
- `stories/dungeo/src/orchestration/scheduler-setup.ts` — Removed daemon registration

**Old handler** (`stories/dungeo/src/handlers/victory-handler.ts`) left in place but no longer wired up.

### Test Results
- **Walkthroughs**: 148/148 pass
- **Unit transcripts**: No new regressions (all pre-existing failures remain stable)

## Key Decisions

### 1. Event Filtering for Room-Specific Transitions
The victory machine uses the event filter pattern (`filter: { toRoom: treasuryId }`) on the transition trigger. This is more efficient than using a guard to check room location - the state machine runtime only evaluates the transition when the player enters the specific room. This pattern should be preferred for location-based triggers.

### 2. StateGuard vs CustomGuard
Victory machine uses `StateGuard` (checking `game.endgameStarted`) rather than a `CustomGuard`. This is the right choice for simple boolean checks on world state. Use `CustomGuard` only when logic is complex (like reality-altered checking capability properties).

### 3. Terminal vs Linear vs Bidirectional Machines
We now have examples of all three patterns:
- **Terminal**: Reality-altered, victory (inactive → shown, never return)
- **Linear**: Death penalty, trapdoor (cascade through states)
- **Bidirectional**: Rainbow (toggle between inactive/active)

### 4. Collapsing Daemon + Event Handler Patterns
Both migrations replaced polling daemons with event-driven transitions. The old pattern (event sets flag → daemon checks flag every turn → daemon clears flag) is now (event triggers transition → guard checks flag → effect clears flag and acts). This is more declarative and efficient.

## Architectural Notes

### Event Filters vs Guards
Event filters (`filter: { toRoom: treasuryId }`) are evaluated by the state machine runtime before considering the transition. Guards are evaluated only if the event matches the trigger + filter. Use filters for structural constraints (room IDs, entity types), guards for logical constraints (game state, capability values).

### Scoring via World State
Both machines manipulate scoring through world state:
- Reality-altered: Reads `scoring.realityAlteredPending` via capability
- Victory: Reads/writes `scoring.endgameScore` via `world.getStateValue()`/`setStateValue()`

This demonstrates two valid approaches - capabilities for complex scoring state, state values for simple counters.

### Message-Heavy Transitions
The victory transition emits 4 messages + 1 event in a single effect. This is correct - state machines should emit all relevant narrative/UX effects during transitions. The report service will display them in order.

### Migration Pattern Established
```
Old:
  Event handler registers listener
    → Sets flag on world/capability
  Daemon polls every turn
    → Checks flag
    → Performs action
    → Clears flag

New:
  State machine registers transition
    → Trigger: specific event
    → Guard: checks flag
    → Effect: performs action + clears flag
```

This eliminates polling overhead and makes causality explicit.

## Files Modified

**State Machines** (2 files):
- `stories/dungeo/src/state-machines/reality-altered-machine.ts` - Terminal machine for "reality altered" message after thief death + score check
- `stories/dungeo/src/state-machines/victory-machine.ts` - Terminal machine for victory condition with room filter and state guard

**Orchestration** (2 files):
- `stories/dungeo/src/orchestration/index.ts` - Registered both new state machines (victory with treasury ID parameter)
- `stories/dungeo/src/orchestration/scheduler-setup.ts` - Removed daemon registrations for reality-altered and victory

**Story Entry** (1 file):
- `stories/dungeo/src/index.ts` - Removed reality-altered event handler registration

## Progress Tracking

### Handler → State Machine Migration Status
- ✅ Death penalty (ADR-119/120)
- ✅ Trapdoor (ADR-119/120)
- ✅ Rainbow (bidirectional, ADR-119/120)
- ✅ Reality altered (this session)
- ✅ Victory (this session)
- ⏳ Remaining: 20+ handlers/daemons in `stories/dungeo/src/handlers/`

**Pattern categories established**:
- Terminal machines (reality-altered, victory)
- Linear progressions (death-penalty, trapdoor)
- Bidirectional toggles (rainbow)

## Next Steps

### Short Term
- Continue migrating remaining handlers in priority order (glacier, endgame, lamp timers, etc.)
- Consider creating state machine migration guide in `docs/work/dungeo/` to document patterns

### Long Term
- Evaluate if `ScoreEffect` type should be added to plugin-state-machine (currently using CustomEffect for scoring)
- Review all daemons in `scheduler-setup.ts` for migration candidates
- Consider deprecating old handler files once all migrations are verified stable

## Session Notes

**Duration**: ~45 minutes

**Approach**:
- Analyzed reality-altered's two-phase pattern (event → daemon)
- Created terminal state machine with capability-based guard
- Analyzed victory's daemon polling pattern
- Created terminal state machine with event filter + state guard
- Verified no test regressions across 148 walkthroughs

**Key Learning**: Event filters are a powerful optimization for location-based or entity-specific transitions. By filtering at the trigger level (`filter: { toRoom: treasuryId }`), the state machine runtime avoids evaluating guards for irrelevant events. This is especially valuable for high-frequency events like `if.event.actor_moved`.

**Migration velocity**: With clear patterns established, handler → state machine migrations are now straightforward. Each migration follows the same checklist:
1. Identify trigger event(s)
2. Determine state structure (terminal/linear/bidirectional)
3. Extract guard logic (filter vs guard)
4. Wrap effect logic in CustomEffect
5. Register machine, remove old handler/daemon

---

**Progressive update**: Session completed 2026-01-29 03:00
