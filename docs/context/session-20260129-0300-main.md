# Session Summary: 2026-01-29 03:00 - main

## Status: Completed

## Goals
- Migrate reality-altered handler to declarative state machine pattern (ADR-119/120)
- Migrate victory handler to declarative state machine pattern (ADR-119/120)
- Continue systematically replacing imperative handlers with declarative state machines

## Completed

### Reality-Altered Handler → State Machine Migration

Migrated the reality-altered handler from two-phase imperative approach (event handler + daemon) to declarative state machine.

**New file**: `stories/dungeo/src/state-machines/reality-altered-machine.ts`

**States**:
- `inactive` → waiting for thief death and player to check score
- `shown` → message displayed (terminal)

**Transition**:
- Triggered by `if.event.score_displayed` event
- Guard checks `scoring.realityAlteredPending === true`
- Single `CustomEffect` clears both pending/queued flags and emits the message

**Design choices**:
- Collapsed the old two-phase approach (event handler sets flag → daemon checks flag each turn) into a single transition triggered by the score event
- Uses `StandardCapabilities.SCORING` to access scoring capability for state checks
- Terminal state machine (never transitions back) - simpler than rainbow's bidirectional pattern
- No entity bindings needed (pure scoring logic)

**Files modified**:
- `stories/dungeo/src/state-machines/reality-altered-machine.ts` — New terminal state machine
- `stories/dungeo/src/orchestration/index.ts` — Registered reality-altered machine
- `stories/dungeo/src/orchestration/scheduler-setup.ts` — Removed daemon registration
- `stories/dungeo/src/index.ts` — Removed event handler registration

**Old handler** (`stories/dungeo/src/handlers/reality-altered-handler.ts`) left in place but no longer wired up.

### Victory Handler → State Machine Migration

Migrated the victory handler from daemon polling to declarative state machine.

**New file**: `stories/dungeo/src/state-machines/victory-machine.ts`

**States**:
- `playing` → game in progress (initial)
- `victory` → player has won (terminal)

**Transition**:
- Triggered by `if.event.actor_moved` event with `filter: { toRoom: treasuryId }`
- StateGuard checks `game.endgameStarted === true`
- `CustomEffect` awards 35 points, sets victory/ended state, emits 4 messages + victory event

**Design choices**:
- Event-driven instead of daemon polling (more efficient, clearer logic)
- Uses `StateGuard` for simple boolean check (cleaner than custom guard)
- Event filter on `toRoom` ensures machine only reacts to Treasury entrance
- Parameterized with `treasuryId` from config (reusable pattern)
- Emits `game.victory` event for potential future handlers

**Files modified**:
- `stories/dungeo/src/state-machines/victory-machine.ts` — New terminal state machine with room filter and state guard
- `stories/dungeo/src/orchestration/index.ts` — Registered victory machine with treasury ID from config
- `stories/dungeo/src/orchestration/scheduler-setup.ts` — Removed daemon registration

**Old handler** (`stories/dungeo/src/handlers/victory-handler.ts`) left in place but no longer wired up.

### Endgame Trigger Handler Assessment

Analyzed the endgame trigger handler for potential state machine migration and determined it does NOT fit the pattern.

**Key finding**: The endgame handler is a **continuous condition monitor** with turn accumulation and reset logic, not event-driven state transitions.

**Pattern characteristics**:
- Monitors sustained condition: "treasures exist BUT not in trophy case"
- Accumulates turns while condition holds (0 → 1 → 2 → ...)
- Resets counter when condition breaks
- Triggers action at threshold (50 turns)
- Condition can oscillate (player puts treasure in case, resets; removes treasure, starts counting again)

**Why not a state machine**:
- No discrete states to model (it's a counter, not a mode)
- No triggering event (it's a passive condition check every turn)
- Reset logic is essential (state machines don't naturally model "start counting over")
- Threshold check is continuous (can't use event filter)

**Correct pattern**: This is a **watchdog daemon** - monitors a condition over time, accumulates evidence, triggers when threshold met.

**Document created**: `docs/work/platform/end-game-assessment.md`

### ADR-123: Typed Daemon Hierarchy

Created comprehensive ADR addressing the "Domain-Driven Daemons" (DDD) problem - daemons are anonymous callbacks with no domain identity, encapsulation, or lifecycle management.

**New document**: `docs/architecture/adrs/adr-123-typed-daemon-hierarchy.md`

**Problem identified**:
- Current daemons are raw callbacks registered inline in `scheduler-setup.ts`
- No type identity (can't query "is this a watchdog?")
- No encapsulation (state scattered across closures)
- No lifecycle hooks (startup/teardown, pause/resume)
- No debuggability (can't inspect daemon state)
- No testability (must run full scheduler to test daemon logic)

**Survey results**: Analyzed all ~15 daemons in Dungeo and categorized into 5 patterns:
1. **Watchdog daemons** (4) - sustained condition monitoring with turn accumulation, reset, threshold triggers
2. **Location daemons** (3) - room-specific reactions (cyclops, thief, lamp timer)
3. **Ambience daemons** (2) - atmospheric messages with cooldown
4. **Countdown daemons** (3) - fixed turn delays with optional tick conditions
5. **Global tickers** (3) - every-turn logic (lamp drain, candles burn, volcano)

**Designed class hierarchy**:

```typescript
// Base class - adapts to existing Daemon interface
abstract class DaemonRunner {
  abstract shouldRun(world: WorldModel): boolean;
  abstract execute(world: WorldModel): void;

  // Lifecycle hooks
  onRegister?(world: WorldModel): void;
  onUnregister?(world: WorldModel): void;

  // Adapter method - produces Daemon callback
  toDaemon(): Daemon;
}

// Specialized types
class WatchdogDaemon extends DaemonRunner {
  // Turn accumulation, reset on condition break, threshold trigger
}

class LocationDaemon extends DaemonRunner {
  // Room-specific reactions, auto-filters by player location
}

class AmbienceDaemon extends DaemonRunner {
  // Atmosphere messages with cooldown management
}

class CountdownDaemon extends DaemonRunner {
  // Fixed turn delay with optional tick condition
}
```

**Decision matrix**: When to use state machines vs daemon types:
- Event-driven with discrete states → State machine
- Continuous monitoring with accumulation → WatchdogDaemon
- Room-specific reactions → LocationDaemon
- Periodic messages with cooldown → AmbienceDaemon
- Fixed countdown with trigger → CountdownDaemon

**Implementation plan**: Phased approach
1. Implement base classes in `@sharpee/engine` (`engine/src/daemons/`)
2. Proof of concept: Migrate endgame handler to `WatchdogDaemon`
3. Incremental migration: Convert remaining daemons (no scheduler changes - `.toDaemon()` adapts to existing interface)
4. Future enhancement: Scheduler APIs for daemon introspection/lifecycle

**Files created**:
- `docs/work/platform/end-game-assessment.md` - Assessment document explaining why endgame handler doesn't fit state machine pattern
- `docs/architecture/adrs/adr-123-typed-daemon-hierarchy.md` - Full ADR with problem, survey, design, decision matrix, and implementation plan

### Test Results
- **Walkthroughs**: 148/148 pass
- **Unit transcripts**: No new regressions (all pre-existing failures remain stable)

## Key Decisions

### 1. Event Filtering for Room-Specific Transitions
The victory machine uses the event filter pattern (`filter: { toRoom: treasuryId }`) on the transition trigger. This is more efficient than using a guard to check room location - the state machine runtime only evaluates the transition when the player enters the specific room. This pattern should be preferred for location-based triggers.

### 2. StateGuard vs CustomGuard
Victory machine uses `StateGuard` (checking `game.endgameStarted`) rather than a `CustomGuard`. This is the right choice for simple boolean checks on world state. Use `CustomGuard` only when logic is complex (like reality-altered checking capability properties).

### 3. Terminal vs Linear vs Bidirectional Machines
We now have examples of all three patterns:
- **Terminal**: Reality-altered, victory (inactive → shown, never return)
- **Linear**: Death penalty, trapdoor (cascade through states)
- **Bidirectional**: Rainbow (toggle between inactive/active)

### 4. Collapsing Daemon + Event Handler Patterns
Both migrations replaced polling daemons with event-driven transitions. The old pattern (event sets flag → daemon checks flag every turn → daemon clears flag) is now (event triggers transition → guard checks flag → effect clears flag and acts). This is more declarative and efficient.

### 5. State Machines vs Daemons - Clear Boundaries
The endgame handler assessment revealed clear criteria:
- **State machines**: Event-driven logic with discrete states (death penalty, victory, rainbow)
- **Daemons**: Continuous condition monitoring with accumulation/reset (endgame threshold, lamp timers)

Not all handlers should become state machines. Watchdog patterns (monitor condition over time, accumulate turns, reset when condition breaks) require daemon infrastructure.

### 6. Typed Daemons Solve the DDD Problem
Current daemons are anonymous callbacks with no domain identity. ADR-123's typed hierarchy brings:
- **Type identity**: Can query "is this a watchdog?"
- **Encapsulation**: State lives in class properties, not scattered closures
- **Lifecycle hooks**: `onRegister()`, `onUnregister()`, pause/resume capability
- **Testability**: Can unit test daemon logic without scheduler
- **Debuggability**: Can inspect daemon state via class instance

The `.toDaemon()` adapter method means zero scheduler changes - typed daemons produce standard `Daemon` callbacks.

## Architectural Notes

### Event Filters vs Guards
Event filters (`filter: { toRoom: treasuryId }`) are evaluated by the state machine runtime before considering the transition. Guards are evaluated only if the event matches the trigger + filter. Use filters for structural constraints (room IDs, entity types), guards for logical constraints (game state, capability values).

### Scoring via World State
Both machines manipulate scoring through world state:
- Reality-altered: Reads `scoring.realityAlteredPending` via capability
- Victory: Reads/writes `scoring.endgameScore` via `world.getStateValue()`/`setStateValue()`

This demonstrates two valid approaches - capabilities for complex scoring state, state values for simple counters.

### Message-Heavy Transitions
The victory transition emits 4 messages + 1 event in a single effect. This is correct - state machines should emit all relevant narrative/UX effects during transitions. The report service will display them in order.

### Migration Pattern Established
```
Old:
  Event handler registers listener
    → Sets flag on world/capability
  Daemon polls every turn
    → Checks flag
    → Performs action
    → Clears flag

New:
  State machine registers transition
    → Trigger: specific event
    → Guard: checks flag
    → Effect: performs action + clears flag
```

This eliminates polling overhead and makes causality explicit.

### Watchdog Pattern Recognition
The endgame handler analysis revealed the **watchdog daemon pattern**: continuous condition monitoring with turn accumulation, reset on condition break, and threshold-based triggers. This is fundamentally different from event-driven state transitions:

```
Watchdog (endgame):
  Every turn: Check "treasures exist BUT not in trophy case"
    → Condition true: turns++ (0→1→2→...→50)
    → Condition false: turns = 0 (reset)
    → Threshold met (turns === 50): trigger action

State machine (victory):
  Event "player enters treasury" + guard "endgame started"
    → Trigger action immediately
```

State machines react to discrete events; watchdogs monitor sustained conditions over time. The daemon type hierarchy in ADR-123 provides proper abstractions for both patterns.

### DDD Problem Articulation
The "Domain-Driven Daemons" problem is that current daemons lack:
1. **Identity**: No way to ask "what kind of daemon is this?"
2. **Encapsulation**: State scattered in closures, not cohesive objects
3. **Lifecycle**: No startup/shutdown, pause/resume
4. **Testability**: Must run full scheduler to test daemon logic
5. **Debuggability**: Can't inspect running daemon state

ADR-123's class hierarchy addresses all five issues while maintaining backward compatibility via the `.toDaemon()` adapter pattern.

## Files Modified

**State Machines** (2 files):
- `stories/dungeo/src/state-machines/reality-altered-machine.ts` - Terminal machine for "reality altered" message after thief death + score check
- `stories/dungeo/src/state-machines/victory-machine.ts` - Terminal machine for victory condition with room filter and state guard

**Orchestration** (2 files):
- `stories/dungeo/src/orchestration/index.ts` - Registered both new state machines (victory with treasury ID parameter)
- `stories/dungeo/src/orchestration/scheduler-setup.ts` - Removed daemon registrations for reality-altered and victory

**Story Entry** (1 file):
- `stories/dungeo/src/index.ts` - Removed reality-altered event handler registration

**Documentation** (2 files):
- `docs/work/platform/end-game-assessment.md` - Assessment explaining why endgame handler doesn't fit state machine pattern
- `docs/architecture/adrs/adr-123-typed-daemon-hierarchy.md` - Comprehensive ADR for typed daemon class hierarchy (DDD solution)

## Progress Tracking

### Handler → State Machine Migration Status
- ✅ Death penalty (ADR-119/120)
- ✅ Trapdoor (ADR-119/120)
- ✅ Rainbow (bidirectional, ADR-119/120)
- ✅ Reality altered (this session)
- ✅ Victory (this session)
- ❌ Endgame trigger (assessed - NOT a state machine, requires WatchdogDaemon)
- ⏳ Remaining: 20+ handlers/daemons in `stories/dungeo/src/handlers/`

**Pattern categories established**:
- **State machines**: Terminal (reality-altered, victory), Linear (death-penalty, trapdoor), Bidirectional (rainbow)
- **Daemons**: Watchdog (endgame), Location (cyclops, thief), Ambience (sounds), Countdown (timers), Global (lamp drain)

## Next Steps

### Short Term
- **Implement ADR-123 base classes**: Create `DaemonRunner`, `WatchdogDaemon`, `LocationDaemon`, `AmbienceDaemon`, `CountdownDaemon` in `@sharpee/engine`
- **Proof of concept**: Migrate endgame handler to `WatchdogDaemon` class (demonstrates pattern works)
- Continue migrating event-driven handlers to state machines (glacier, etc.)
- Create decision matrix guide: "Is this a state machine or daemon?" (reference ADR-123 criteria)

### Medium Term
- Incrementally migrate remaining daemons to typed classes (cyclops → LocationDaemon, lamp timer → CountdownDaemon, etc.)
- Add lifecycle hooks to scheduler for daemon registration/unregistration events
- Create daemon inspector tool for runtime debugging (query all daemons, inspect state)

### Long Term
- Evaluate if `ScoreEffect` type should be added to plugin-state-machine (currently using CustomEffect for scoring)
- Consider deprecating old handler files once all migrations are verified stable
- Document patterns in `docs/patterns/` (state machines vs daemons, when to use each)

## Session Notes

**Duration**: ~2 hours

**Approach**:
1. Migrated reality-altered handler to terminal state machine (event-driven)
2. Migrated victory handler to terminal state machine (event filter + state guard)
3. Assessed endgame trigger handler - determined it does NOT fit state machine pattern
4. Wrote comprehensive ADR-123 for typed daemon hierarchy (DDD solution)
5. Verified 148/148 walkthroughs pass throughout session

**Key Learning - Event Filters**: Event filters are a powerful optimization for location-based or entity-specific transitions. By filtering at the trigger level (`filter: { toRoom: treasuryId }`), the state machine runtime avoids evaluating guards for irrelevant events. This is especially valuable for high-frequency events like `if.event.actor_moved`.

**Key Learning - State Machines vs Daemons**: Not all handlers should become state machines. Clear decision criteria:
- **Event-driven with discrete states** → State machine
- **Continuous condition monitoring with turn accumulation** → Watchdog daemon
- **Room-specific reactions** → Location daemon
- **Periodic atmosphere** → Ambience daemon
- **Fixed countdown** → Countdown daemon

**Migration velocity**: State machine migrations are straightforward (5 completed). Daemon migrations require new infrastructure (ADR-123 base classes). Both patterns are now well-understood.

**Architectural insight**: The endgame handler analysis revealed that watchdog daemons serve a fundamentally different purpose than state machines. Watchdogs monitor sustained conditions over time with accumulation/reset logic; state machines react to discrete events with mode changes. Both patterns are essential - forcing watchdogs into state machines would create convoluted designs.

---

**Progressive update**: Session completed 2026-01-29 05:30
