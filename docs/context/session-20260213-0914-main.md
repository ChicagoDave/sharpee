# Session Summary: 2026-02-13 - main (09:14 CST)

## Status: Completed

## Goals
- Fix ISSUE-052: Capability registry behaviors not shared across require() boundaries in CLI bundle

## Completed

### ISSUE-052: Capability Registry Global State Fix

**Problem Identified:**
- `capability-registry.ts` used module-level `const Map` for storing capability behaviors
- When CLI bundle loads a story via `require()`, the story gets its own copy of `@sharpee/world-model`
- Result: Capability behaviors registered by story code were invisible to platform dispatch code
- This broke entity-specific actions like LOWER/RAISE basket, despite registration code running

**Root Cause:**
- Module-level Maps don't survive across require() boundaries in bundled scenarios
- Story code and platform code get separate instances of the same module
- Each instance has its own Map, so registrations in one aren't visible to lookups in the other

**Solution Applied:**
- Changed `capability-registry.ts` to use `globalThis` for storage, matching the proven pattern from `interceptor-registry.ts`
- Added proxy object for backwards compatibility with existing code
- Fixed `getAllCapabilityBindings()` to copy from real Map instead of proxy

**Files Modified:**
- `packages/world-model/src/capabilities/capability-registry.ts` - Switch to globalThis-backed registry
- `docs/work/issues/issues-list-03.md` - Mark ISSUE-052 as fixed (2026-02-13)

## Key Decisions

### 1. Use Existing GlobalThis Pattern
**Decision:** Used exact same `globalThis` pattern already proven in `interceptor-registry.ts`

**Rationale:**
- Pattern already validated and working in production
- Minimal risk - no new architectural patterns introduced
- Consistency across codebase for registry implementations
- Simple to understand and maintain

### 2. Add Proxy for Backwards Compatibility
**Decision:** Kept `capabilityBehaviors` export as proxy object

**Rationale:**
- Allows existing code using `capabilityBehaviors.get()` or `.set()` to continue working
- Zero breaking changes for consumers
- Clean migration path if direct Map access was used anywhere

## Test Results

**Full Walkthrough Chain:**
```
359 tests total
347 passed
11 skipped
1 pre-existing failure (torch timing in wt-12, unrelated)
```

**Build Status:** Clean build, no errors

**Verification:** Capability dispatch now works correctly in CLI bundle mode

## Files Modified

**Platform** (2 files):
- `packages/world-model/src/capabilities/capability-registry.ts` - GlobalThis-backed registry implementation
- `docs/work/issues/issues-list-03.md` - Issue tracking update

## Architectural Notes

### Module Boundaries and Bundled Code

This fix reveals an important pattern for **global registries in bundled JavaScript**:

**Problem:** Module-level `const` variables don't survive `require()` boundaries when code is bundled. Each `require()` gets a fresh module instance with its own variables.

**Solution:** Use `globalThis` for truly global state that must be shared across all require() contexts:

```typescript
// WRONG - breaks in bundles
const myRegistry = new Map();
export function register(k, v) { myRegistry.set(k, v); }

// RIGHT - survives require() boundaries
const GLOBAL_KEY = Symbol.for('@my-package/registry');
globalThis[GLOBAL_KEY] = globalThis[GLOBAL_KEY] || new Map();
export function register(k, v) {
  globalThis[GLOBAL_KEY].set(k, v);
}
```

**When to Use:**
- Event handlers (interceptor-registry.ts)
- Capability behaviors (capability-registry.ts)
- Plugin registrations
- Any state that MUST be shared between platform and story code in bundled scenarios

**When NOT to Use:**
- State that should be scoped to a single module
- Data that should be isolated per-instance
- Anything that doesn't need to cross require() boundaries

### Registry Patterns in Sharpee

All Sharpee registries now follow this pattern:
1. **interceptor-registry.ts** - Event handler registration (original globalThis pattern)
2. **capability-registry.ts** - Capability behavior registration (fixed in this session)

If adding new registries, use this same pattern for consistency.

## Notes

**Session duration**: ~30 minutes

**Approach**: Bug investigation and minimal fix using proven pattern

**Impact**: This was a critical bug that would have blocked all capability dispatch in production use. The globalThis pattern ensures story-registered behaviors are visible to platform code regardless of bundling or require() semantics.

---

**Progressive update**: Session completed 2026-02-13 09:14 CST
