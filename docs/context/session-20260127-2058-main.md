# Session Summary: 2026-01-27 - main

## Status: Completed

## Goals
- Complete handler migration audit for Dungeo story
- Eliminate remaining mutation violations in event handlers
- Assess architectural patterns for complex puzzle coordination

## Completed

### 1. Handler Assessment Update
Updated `docs/work/dungeo/handler-assessment.md` to reflect dam-handler migration completed in previous session (marked as MIGRATED, updated violation counts from 5 to 4).

### 2. River Handler Migration
**Finding**: `registerBoatMovementHandler()` in `river-handler.ts` was dead code - exported but never called anywhere in the codebase.

**Analysis**: The stdlib GOING action already handles vehicle movement natively (lines 302-303 of `packages/stdlib/src/actions/standard/going/going.ts`). When `vehicleId` is set, the action moves the vehicle entity instead of the player entity.

**Changes**:
- Deleted the dead `registerBoatMovementHandler()` function
- Removed unused imports (`GameEngine`, `ISemanticEvent`)
- Preserved the command transformer (read-only, blocks water room entry without boat - legitimate use case)

**Tests**: 148/148 walkthrough tests pass.

### 3. Coal Machine Assessment
**Finding**: The `coal-machine-handler.ts` file never existed. The coal→diamond puzzle was already implemented as a story-specific action (`turn-switch-action.ts`) with proper four-phase pattern.

**Action**: Removed incorrect entry from handler assessment. No migration needed.

### 4. Ghost Ritual Handler Cleanup
**Finding**: `GhostRitualDroppingInterceptor` already existed and was properly registered in ADR-118 migration. The old `ghost-ritual-handler.ts` was dead code - the exported `registerGhostRitualHandler()` function was never called.

**Changes**:
- Deleted `stories/dungeo/src/handlers/ghost-ritual-handler.ts`
- Moved `GhostRitualMessages` constant to `ghost-ritual-dropping-interceptor.ts` (single source of truth)
- Added re-export in `traits/index.ts` for external consumers
- Updated imports in `index.ts` and `messages/puzzle-messages.ts`
- Removed export from `handlers/index.ts`

**Tests**: 148/148 walkthrough tests pass.

### 5. Tiny Room Handler Assessment
**Finding**: `tiny-room-handler.ts` is NOT an event handler. It's a utility module with helper functions called directly from story action execute phases:
- `put-under-action.ts` calls `putItemUnderMat()`
- `push-key-action.ts` calls `pushKeyFromUnderMat()`
- `pull-mat-action.ts` calls `pullMat()`

**Analysis**: Mutations are action-owned (actions call the helpers), not handler-owned. This is a legitimate pattern for puzzle orchestration where multiple actions share state coordination logic.

**New Pattern Identified**: "Puzzle Orchestrator" - utility modules that coordinate shared puzzle state across multiple story actions. Different from event handlers (reactive) or capabilities (entity-centric dispatch).

**Action**: Reclassified in assessment as NOT a violation. Tiny room handler follows proper architecture.

### 6. ADR-119: State Machines for Puzzles and Narratives
Wrote comprehensive ADR proposing declarative state machine system for Sharpee.

**Core Model**:
- States with enter/exit effects
- Transitions with guards and effects
- Entity role bindings (`$door`, `$key`) for reusable patterns

**Trigger Types**:
1. **ActionTrigger**: React to player commands ("when player OPENS $door")
2. **EventTrigger**: React to game events ("when if.event.opened")
3. **ConditionTrigger**: Poll world state ("when $door.isOpen AND $light.isOn")

**Examples**:
- Tiny room puzzle (5 states, 11 transitions)
- Thief narrative arc (3 states, action/event/condition triggers)

**Design Choice**: ONE runtime serving both puzzle orchestration and narrative orchestration, rather than separate systems. Different usage patterns, shared implementation.

**Comparison**: Detailed analysis vs. Inform 7 scenes system - similarities in polling/conditions, differences in scope and granularity.

**File**: `docs/architecture/adrs/adr-119-state-machines.md`

## Key Decisions

### 1. Dead Code Elimination Strategy
When finding dead code (exported but never called), delete immediately rather than attempting migration. River handler boat movement and ghost ritual handler were both dead code - stdlib and interceptors already handled the functionality.

### 2. Puzzle Orchestrators Are Not Violations
Utility modules that coordinate shared puzzle state across multiple story actions (like `tiny-room-handler.ts`) are legitimate patterns. The key distinction:
- **Event handlers**: React to events, should NOT mutate
- **Puzzle orchestrators**: Helper functions called by actions, mutations are action-owned

### 3. State Machine Unification
Puzzle orchestration and narrative orchestration should use ONE state machine system with two usage patterns, not separate systems. Benefits:
- Shared runtime reduces code duplication
- Consistent mental model for authors
- Puzzles and narratives can interact (thief storyline affects puzzle availability)

### 4. ConditionTrigger Inclusion
Include Inform 7-style polling (`when $door.isOpen AND $light.isOn`) alongside action and event triggers. Addresses the gap where event-driven systems struggle with compound conditions spread across multiple actions.

## Handler Assessment Final Status

**Violations**: 1 → 0 (all resolved or reclassified)

| Handler               | Status        | Resolution                                    |
| --------------------- | ------------- | --------------------------------------------- |
| dam-handler           | MIGRATED      | Turn-bolt action owns mutations (prev session)|
| river-handler         | RESOLVED      | Dead code deleted, stdlib handles vehicles    |
| coal-machine-handler  | NEVER EXISTED | Already a story action, assessment error      |
| ghost-ritual-handler  | RESOLVED      | Dead code deleted, interceptor already exists |
| tiny-room-handler     | RECLASSIFIED  | Puzzle orchestrator, not event handler        |

## Open Items

### Short Term
- Review ADR-119 with user for feedback/approval
- Consider whether other handler patterns need reclassification
- Document "Puzzle Orchestrator" pattern in architecture docs

### Long Term
- Implement state machine system (ADR-119)
- Migrate tiny room puzzle to state machine as proof-of-concept
- Evaluate thief narrative arc for state machine migration

## Files Modified

**Story Code** (5 files):
- `stories/dungeo/src/handlers/river-handler.ts` - Removed dead `registerBoatMovementHandler` function
- `stories/dungeo/src/handlers/ghost-ritual-handler.ts` - DELETED (dead code)
- `stories/dungeo/src/handlers/index.ts` - Removed ghost-ritual-handler export
- `stories/dungeo/src/index.ts` - Updated GhostRitualMessages import path
- `stories/dungeo/src/messages/puzzle-messages.ts` - Updated GhostRitualMessages import path

**Story Interceptors** (2 files):
- `stories/dungeo/src/interceptors/ghost-ritual-dropping-interceptor.ts` - Added GhostRitualMessages constant
- `stories/dungeo/src/traits/index.ts` - Added GhostRitualMessages re-export

**Documentation** (2 files):
- `docs/work/dungeo/handler-assessment.md` - Updated throughout (status changes, counts, analysis)
- `docs/architecture/adrs/adr-119-state-machines.md` - NEW (comprehensive state machine proposal)

## Architectural Notes

### Pattern Discovery: Three Types of Mutation Ownership

1. **Actions**: Own mutations in execute phase (standard pattern)
2. **Behaviors**: Own mutations for capability dispatch (entity-centric)
3. **Puzzle Orchestrators**: Helper functions called by actions (action delegates mutation)

All three are valid. Event handlers should NEVER mutate.

### State Machine Design Insight

The key insight for ADR-119 was recognizing that puzzles and narratives are the SAME underlying concept:
- Both have discrete states with transitions
- Both react to player actions and world events
- Both need guards (conditions) and effects (mutations)
- The only difference is granularity (puzzle = single mechanic, narrative = arc of scenes)

Rather than create `PuzzleStateMachine` and `NarrativeStateMachine` classes, create ONE system with example patterns for each use case.

### Stdlib Vehicle Movement

The GOING action in stdlib has native vehicle support (lines 302-303):
```typescript
const entityToMove = vehicleId || actorId;
world.moveEntity(entityToMove, targetRoomId);
```

No need for handlers to intercept vehicle movement - just set `vehicleId` in shared data during validation.

## Notes

**Session duration**: ~90 minutes

**Approach**: Systematic audit of remaining event handlers, eliminating dead code and reclassifying legitimate patterns. Led to architectural insight about state machines as unified system.

**Test Coverage**: 148/148 walkthrough tests pass throughout all changes. No functionality broken.

**Next Session**: Review ADR-119 with user, potentially begin state machine implementation.

---

**Progressive update**: Session completed 2026-01-27 22:28
